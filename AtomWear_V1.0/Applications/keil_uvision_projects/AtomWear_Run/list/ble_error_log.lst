L 1 "..\..\..\Software\Source\ble_lib\ble_error_log.c"
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 410000
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 14 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 15 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include <stdbool.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 16 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include <nrf51.h>
L 1 "..\..\..\Software\Include\nrf51.h" 1
N
N/****************************************************************************************************//**
N * @file     nRF51.h
N *
N * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
N *           nRF51 from Nordic Semiconductor.
N *
N * @version  V2.4C
N * @date     26. September 2013
N *
N * @note     Generated with SVDConv V2.77p 
N *           from CMSIS SVD File 'nRF51.xml' Version 2.4C,
N *
N * @par      Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved. 
N *           
N *           The information contained herein is property of Nordic Semiconductor ASA. 
N *           Terms and conditions of usage are described in detail in NORDIC 
N *           SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
N *           
N *           Licensees are granted free, non-transferable use of the information. NO 
N *           WARRANTY of ANY KIND is provided. This heading must NOT be removed from 
N *           the file. 
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nRF51
N  * @{
N  */
N
N#ifndef NRF51_H
N#define NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nRF51 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UART0_IRQn                    =   2,              /*!<   2  UART0                                                            */
N  SPI0_TWI0_IRQn                =   3,              /*!<   3  SPI0_TWI0                                                        */
N  SPI1_TWI1_IRQn                =   4,              /*!<   4  SPI1_TWI1                                                        */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  LPCOMP_COMP_IRQn              =  19,              /*!<  19  LPCOMP_COMP                                                      */
N  SWI0_IRQn                     =  20,              /*!<  20  SWI0                                                             */
N  SWI1_IRQn                     =  21,              /*!<  21  SWI1                                                             */
N  SWI2_IRQn                     =  22,              /*!<  22  SWI2                                                             */
N  SWI3_IRQn                     =  23,              /*!<  23  SWI3                                                             */
N  SWI4_IRQn                     =  24,              /*!<  24  SWI4                                                             */
N  SWI5_IRQn                     =  25               /*!<  25  SWI5                                                             */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the cm0 Processor and Core Peripherals---------------- */
N#define __CM0_REV                 0x0301            /*!< Cortex-M0 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm0.h>                               /*!< Cortex-M0 processor and core peripherals                              */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.02
N * @date     16. July 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.02
N * @date     08. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 113 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.02
N * @date     24. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 114 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 102 "..\..\..\Software\Include\nrf51.h" 2
N#include "system_nrf51.h"                           /*!< nRF51 System                                                          */
L 1 "..\..\..\Software\Include\system_nrf51.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef SYSTEM_NRF51_H
N#define SYSTEM_NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF51_H */
L 103 "..\..\..\Software\Include\nrf51.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __IO uint32_t  CPU0;                              /*!< Configurable priority configuration register for CPU0.                */
X  volatile uint32_t  CPU0;                               
N  __IO uint32_t  SPIS1;                             /*!< Configurable priority configuration register for SPIS1.               */
X  volatile uint32_t  SPIS1;                              
N  __IO uint32_t  RADIO;                             /*!< Configurable priority configuration register for RADIO.               */
X  volatile uint32_t  RADIO;                              
N  __IO uint32_t  ECB;                               /*!< Configurable priority configuration register for ECB.                 */
X  volatile uint32_t  ECB;                                
N  __IO uint32_t  CCM;                               /*!< Configurable priority configuration register for CCM.                 */
X  volatile uint32_t  CCM;                                
N  __IO uint32_t  AAR;                               /*!< Configurable priority configuration register for AAR.                 */
X  volatile uint32_t  AAR;                                
N} AMLI_RAMPRI_Type;
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Enable channel group.                                                 */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Disable channel group.                                                */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Channel event end-point.                                              */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Channel task end-point.                                               */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power Control. (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode.                                         */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency).                             */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning.                                                */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason.                                                         */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System off register.                                                  */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED5[3];
X  volatile const  uint32_t  RESERVED5[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure configuration.                                          */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED6[2];
X  volatile const  uint32_t  RESERVED6[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register. This register is a retained
X  volatile uint32_t  GPREGRET;                          
N                                                         register.                                                             */
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __IO uint32_t  RAMON;                             /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMON;                              
N  __I  uint32_t  RESERVED8[7];
X  volatile const  uint32_t  RESERVED8[7];
N  __IO uint32_t  RESET;                             /*!< Pin reset functionality configuration register. This register
X  volatile uint32_t  RESET;                             
N                                                         is a retained register.                                               */
N  __I  uint32_t  RESERVED9[12];
X  volatile const  uint32_t  RESERVED9[12];
N  __IO uint32_t  DCDCEN;                            /*!< DCDC converter enable configuration register.                         */
X  volatile uint32_t  DCDCEN;                             
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control. (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFCLK RC oscillator.                             */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer.                                              */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer.                                               */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Callibration of LFCLK RC oscillator completed.                        */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Callibration timer timeout.                                           */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __I  uint32_t  HFCLKSTAT;                         /*!< High frequency clock status.                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4[2];
X  volatile const  uint32_t  RESERVED4[2];
N  __I  uint32_t  LFCLKSTAT;                         /*!< Low frequency clock status.                                           */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  RESERVED5[63];
X  volatile const  uint32_t  RESERVED5[63];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK clock.                                     */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval.                                           */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[5];
X  volatile const  uint32_t  RESERVED7[5];
N  __IO uint32_t  XTALFREQ;                          /*!< Crystal frequency.                                                    */
X  volatile uint32_t  XTALFREQ;                           
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                       MPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Protection Unit. (MPU)
N  */
N
Ntypedef struct {                                    /*!< MPU Structure                                                         */
N  __I  uint32_t  RESERVED0[330];
X  volatile const  uint32_t  RESERVED0[330];
N  __IO uint32_t  PERR0;                             /*!< Configuration of peripherals in mpu regions.                          */
X  volatile uint32_t  PERR0;                              
N  __IO uint32_t  RLENR0;                            /*!< Length of RAM region 0.                                               */
X  volatile uint32_t  RLENR0;                             
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  PROTENSET0;                        /*!< Protection bit enable set register for low addresses.                 */
X  volatile uint32_t  PROTENSET0;                         
N  __IO uint32_t  PROTENSET1;                        /*!< Protection bit enable set register for high addresses.                */
X  volatile uint32_t  PROTENSET1;                         
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable protection mechanism in debug mode.                           */
X  volatile uint32_t  DISABLEINDEBUG;                     
N} NRF_MPU_Type;
N
N
N/* ================================================================================ */
N/* ================                       PU                       ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Patch unit. (PU)
N  */
N
Ntypedef struct {                                    /*!< PU Structure                                                          */
N  __I  uint32_t  RESERVED0[384];
X  volatile const  uint32_t  RESERVED0[384];
N  __IO uint32_t  REPLACEADDR[8];                    /*!< Address of first instruction to replace.                              */
X  volatile uint32_t  REPLACEADDR[8];                     
N  __I  uint32_t  RESERVED1[24];
X  volatile const  uint32_t  RESERVED1[24];
N  __IO uint32_t  PATCHADDR[8];                      /*!< Relative address of patch instructions.                               */
X  volatile uint32_t  PATCHADDR[8];                       
N  __I  uint32_t  RESERVED2[24];
X  volatile const  uint32_t  RESERVED2[24];
N  __IO uint32_t  PATCHEN;                           /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHEN;                            
N  __IO uint32_t  PATCHENSET;                        /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHENSET;                         
N  __IO uint32_t  PATCHENCLR;                        /*!< Patch disable register.                                               */
X  volatile uint32_t  PATCHENCLR;                         
N} NRF_PU_Type;
N
N
N/* ================================================================================ */
N/* ================                      AMLI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AHB Multi-Layer Interface. (AMLI)
N  */
N
Ntypedef struct {                                    /*!< AMLI Structure                                                        */
N  __I  uint32_t  RESERVED0[896];
X  volatile const  uint32_t  RESERVED0[896];
N  AMLI_RAMPRI_Type RAMPRI;                          /*!< RAM configurable priority configuration structure.                    */
N} NRF_AMLI_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief The radio. (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one sample of the receive signal strength.    */
X  volatile  uint32_t  TASKS_RSSISTART;                    
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement.                                            */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter.                                                */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter.                                                 */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< End event.                                                            */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< Disable event.                                                        */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of the receive signal strength complete. A new RSSI
X  volatile uint32_t  EVENTS_RSSIEND;                    
N                                                         sample is ready for readout at the RSSISAMPLE register.               */
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value specified in BC register.         */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the radio.                                               */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status of received packet.                                        */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< Received CRC.                                                         */
X  volatile const  uint32_t  RXCRC;                              
N  __IO uint32_t  DAI;                               /*!< Device address match index.                                           */
X  volatile uint32_t  DAI;                                
N  __I  uint32_t  RESERVED6[60];
X  volatile const  uint32_t  RESERVED6[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer. Decision point: START task.                           */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency.                                                            */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power.                                                         */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation.                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration 0.                                               */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration 1.                                               */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration.                                                    */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial.                                                       */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value.                                                    */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  TEST;                              /*!< Test features enable register.                                        */
X  volatile uint32_t  TEST;                               
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in microseconds.                                  */
X  volatile uint32_t  TIFS;                               
N  __IO uint32_t  RSSISAMPLE;                        /*!< RSSI sample.                                                          */
X  volatile uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value.                                         */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare.                                                  */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED9[39];
X  volatile const  uint32_t  RESERVED9[39];
N  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED10[56];
X  volatile const  uint32_t  RESERVED10[56];
N  __IO uint32_t  OVERRIDE0;                         /*!< Trim value override register 0.                                       */
X  volatile uint32_t  OVERRIDE0;                          
N  __IO uint32_t  OVERRIDE1;                         /*!< Trim value override register 1.                                       */
X  volatile uint32_t  OVERRIDE1;                          
N  __IO uint32_t  OVERRIDE2;                         /*!< Trim value override register 2.                                       */
X  volatile uint32_t  OVERRIDE2;                          
N  __IO uint32_t  OVERRIDE3;                         /*!< Trim value override register 3.                                       */
X  volatile uint32_t  OVERRIDE3;                          
N  __IO uint32_t  OVERRIDE4;                         /*!< Trim value override register 4.                                       */
X  volatile uint32_t  OVERRIDE4;                          
N  __I  uint32_t  RESERVED11[561];
X  volatile const  uint32_t  RESERVED11[561];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter, version 1.0. (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver.                                                  */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver.                                                   */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter.                                               */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter.                                                */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART.                                                         */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[58];
X  volatile const  uint32_t  RESERVED1[58];
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD.                                                 */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD.                                                   */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout.                                                     */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[111];
X  volatile const  uint32_t  RESERVED5[111];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[93];
X  volatile const  uint32_t  RESERVED6[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source. Write error field to 1 to clear error.                  */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED7[31];
X  volatile const  uint32_t  RESERVED7[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART and acquire IOs.                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS.                                                   */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD.                                                   */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS.                                                   */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD.                                                   */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
X  volatile const  uint32_t  RXD;                               
N                                                         Once read the character is consummed. If read when no character
N                                                          available, the UART will stop working.                               */
N  __O  uint32_t  TXD;                               /*!< TXD register.                                                         */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  BAUDRATE;                          /*!< UART Baudrate.                                                        */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED10[17];
X  volatile const  uint32_t  RESERVED10[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control register.           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED11[675];
X  volatile const  uint32_t  RESERVED11[675];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI master 0. (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __IO uint32_t  RXD;                               /*!< RX data.                                                              */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data.                                                              */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED7[681];
X  volatile const  uint32_t  RESERVED7[681];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Two-wire interface master 0. (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start 2-Wire master receive sequence.                                 */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start 2-Wire master transmit sequence.                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop 2-Wire transaction.                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend 2-Wire transaction.                                           */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume 2-Wire transaction.                                            */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Two-wire stopped.                                                     */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< Two-wire finished sending last TXD byte.                              */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Two-wire error detected.                                              */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< Two-wire byte boundary.                                               */
X  volatile uint32_t  EVENTS_BB;                          
N  __I  uint32_t  RESERVED7[49];
X  volatile const  uint32_t  RESERVED7[49];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for TWI.                                                    */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[64];
X  volatile const  uint32_t  RESERVED8[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[110];
X  volatile const  uint32_t  RESERVED9[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Two-wire error source. Write error field to 1 to clear error.         */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED10[14];
X  volatile const  uint32_t  RESERVED10[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable two-wire master.                                               */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL.                                                   */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA.                                                   */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED12[2];
X  volatile const  uint32_t  RESERVED12[2];
N  __IO uint32_t  RXD;                               /*!< RX data register.                                                     */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data register.                                                     */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  FREQUENCY;                         /*!< Two-wire frequency.                                                   */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
X  volatile uint32_t  ADDRESS;                            
N  __I  uint32_t  RESERVED15[668];
X  volatile const  uint32_t  RESERVED15[668];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI slave 1. (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed.                                        */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[8];
X  volatile const  uint32_t  RESERVED2[8];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired.                                                   */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED3[53];
X  volatile const  uint32_t  RESERVED3[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for SPIS.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED4[64];
X  volatile const  uint32_t  RESERVED4[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED5[61];
X  volatile const  uint32_t  RESERVED5[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status.                                                     */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED6[15];
X  volatile const  uint32_t  RESERVED6[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction.                                         */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED7[47];
X  volatile const  uint32_t  RESERVED7[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIS.                                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELCSN;                           /*!< Pin select for CSN.                                                   */
X  volatile uint32_t  PSELCSN;                            
N  __I  uint32_t  RESERVED9[7];
X  volatile const  uint32_t  RESERVED9[7];
N  __IO uint32_t  RXDPTR;                            /*!< RX data pointer.                                                      */
X  volatile uint32_t  RXDPTR;                             
N  __IO uint32_t  MAXRX;                             /*!< Maximum number of bytes in the receive buffer.                        */
X  volatile uint32_t  MAXRX;                              
N  __IO uint32_t  AMOUNTRX;                          /*!< Number of bytes received in last granted transaction.                 */
X  volatile uint32_t  AMOUNTRX;                           
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  TXDPTR;                            /*!< TX data pointer.                                                      */
X  volatile uint32_t  TXDPTR;                             
N  __IO uint32_t  MAXTX;                             /*!< Maximum number of bytes in the transmit buffer.                       */
X  volatile uint32_t  MAXTX;                              
N  __IO uint32_t  AMOUNTTX;                          /*!< Number of bytes transmitted in last granted transaction.              */
X  volatile uint32_t  AMOUNTTX;                           
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  DEF;                               /*!< Default character.                                                    */
X  volatile uint32_t  DEF;                                
N  __I  uint32_t  RESERVED13[24];
X  volatile const  uint32_t  RESERVED13[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
X  volatile uint32_t  ORC;                                
N  __I  uint32_t  RESERVED14[654];
X  volatile const  uint32_t  RESERVED14[654];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO tasks and events. (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile  uint32_t  TASKS_OUT[4];                       
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_IN[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile uint32_t  EVENTS_IN[4];                       
N  __I  uint32_t  RESERVED1[27];
X  volatile const  uint32_t  RESERVED1[27];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple pins.                                   */
X  volatile uint32_t  EVENTS_PORT;                        
N  __I  uint32_t  RESERVED2[97];
X  volatile const  uint32_t  RESERVED2[97];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[129];
X  volatile const  uint32_t  RESERVED3[129];
N  __IO uint32_t  CONFIG[4];                         /*!< Channel configuration registers.                                      */
X  volatile uint32_t  CONFIG[4];                          
N  __I  uint32_t  RESERVED4[695];
X  volatile const  uint32_t  RESERVED4[695];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                       ADC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to digital converter. (ADC)
N  */
N
Ntypedef struct {                                    /*!< ADC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
X  volatile const  uint32_t  BUSY;                               
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer 0. (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (In counter mode).                                    */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear timer.                                                          */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __I  uint32_t  RESERVED0[12];
X  volatile const  uint32_t  RESERVED0[12];
N  __O  uint32_t  TASKS_CAPTURE[4];                  /*!< Capture Timer value to CC[n] registers.                               */
X  volatile  uint32_t  TASKS_CAPTURE[4];                   
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[44];
X  volatile const  uint32_t  RESERVED2[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for Timer.                                                  */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer Mode selection.                                                 */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Sets timer behaviour.                                                 */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< 4-bit prescaler to source clock frequency (max value 9). Source
X  volatile uint32_t  PRESCALER;                         
N                                                         clock frequency is divided by 2^SCALE.                                */
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED7[683];
X  volatile const  uint32_t  RESERVED7[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0. (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC Counter.                                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFFFF0.                                            */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment.                                           */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow.                                            */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Configures event enable routing to PPI for each RTC event.            */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
X  volatile uint32_t  EVTENSET;                          
N                                                         the value of EVTEN.                                                   */
N  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
X  volatile uint32_t  EVTENCLR;                          
N                                                         gives the value of EVTEN.                                             */
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __IO uint32_t  COUNTER;                           /*!< Current COUNTER value.                                                */
X  volatile uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
X  volatile uint32_t  PRESCALER;                         
N                                                         Must be written when RTC is STOPed.                                   */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED6[683];
X  volatile const  uint32_t  RESERVED6[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor. (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement.                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement.                                         */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Die temperature in degC, 2's complement format, 0.25 degC pecision.   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[700];
X  volatile const  uint32_t  RESERVED3[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator. (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the random number generator.                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the random number generator.                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< New random number generated and written to VALUE register.            */
X  volatile uint32_t  EVENTS_VALRDY;                      
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the RNG.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register                                         */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register                                       */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< RNG random number.                                                    */
X  volatile const  uint32_t  VALUE;                              
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption. (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt. If a crypto operation is running, this
X  volatile  uint32_t  TASKS_STARTECB;                    
N                                                         will not initiate a new encryption and the ERRORECB event will
N                                                          be triggered.                                                        */
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Stop current ECB encryption. If a crypto operation is running,
X  volatile  uint32_t  TASKS_STOPECB;                     
N                                                         this will will trigger the ERRORECB event.                            */
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete.                                           */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted due to a STOPECB task or due to an
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         error.                                                                */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointer.                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N  __I  uint32_t  RESERVED3[701];
X  volatile const  uint32_t  RESERVED3[701];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver. (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure.                                                       */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status.                                                    */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of Identity root Keys in the IRK data structure.               */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to the IRK data structure.                                    */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 3 bytes must be reserved.                    */
N  __I  uint32_t  RESERVED6[697];
X  volatile const  uint32_t  RESERVED6[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption. (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encrypt/decrypt. This operation will stop by itself when
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         completed.                                                            */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encrypt/decrypt.                                                 */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Keystream generation completed.                                       */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt completed.                                            */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error happened.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the CCM.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< CCM RX MIC check result.                                              */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< CCM enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode.                                                       */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to data structure holding AES key and NONCE vector.           */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Pointer to input packet.                                              */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Pointer to output packet.                                             */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 43 bytes must be reserved.                   */
N  __I  uint32_t  RESERVED5[697];
X  volatile const  uint32_t  RESERVED5[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer. (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog.                                                   */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout.                                                     */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Watchdog running status.                                              */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status.                                                       */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
X  volatile  uint32_t  RR[8];                              
N  __I  uint32_t  RESERVED5[631];
X  volatile const  uint32_t  RESERVED5[631];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Rotary decoder. (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
X  volatile  uint32_t  TASKS_READCLRACC;                  
N                                                         and clears the ACC registers.                                         */
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< A new sample is written to the sample register.                       */
X  volatile uint32_t  EVENTS_SAMPLERDY;                   
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< REPORTPER number of samples accumulated in ACC register, and
X  volatile uint32_t  EVENTS_REPORTRDY;                  
N                                                         ACC register different than zero.                                     */
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow.                                      */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the QDEC.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the QDEC.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity.                                              */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period.                                                        */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value.                                                  */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to generate an EVENT_REPORTRDY.                     */
X  volatile uint32_t  REPORTPER;                          
N  __I  int32_t   ACC;                               /*!< Accumulated valid transitions register.                               */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task.                                                                 */
N  __IO uint32_t  PSELLED;                           /*!< Pin select for LED output.                                            */
X  volatile uint32_t  PSELLED;                            
N  __IO uint32_t  PSELA;                             /*!< Pin select for phase A input.                                         */
X  volatile uint32_t  PSELA;                              
N  __IO uint32_t  PSELB;                             /*!< Pin select for phase B input.                                         */
X  volatile uint32_t  PSELB;                              
N  __IO uint32_t  DBFEN;                             /*!< Enable debouncer input filters.                                       */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time LED is switched ON before the sample.                            */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Accumulated double (error) transitions register.                      */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task.                                                                 */
N  __I  uint32_t  RESERVED5[684];
X  volatile const  uint32_t  RESERVED5[684];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Wakeup Comparator. (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the LPCOMP.                                              */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Result of last compare.                                               */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the LPCOMP.                                                    */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[694];
X  volatile const  uint32_t  RESERVED6[694];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                      COMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Comparator. (COMP)
N  */
N
Ntypedef struct {                                    /*!< COMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< COMP is ready and output is valid.                                    */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the COMP.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Compare result.                                                       */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the COMP.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[8];
X  volatile const  uint32_t  RESERVED5[8];
N  __IO uint32_t  TH;                                /*!< Threshold configuration for hysteresis unit.                          */
X  volatile uint32_t  TH;                                 
N  __IO uint32_t  MODE;                              /*!< Mode configuration.                                                   */
X  volatile uint32_t  MODE;                               
N  __I  uint32_t  RESERVED6[689];
X  volatile const  uint32_t  RESERVED6[689];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_COMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SW Interrupts. (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller. (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __IO uint32_t  ERASEPAGE;                         /*!< Register for erasing a non-protected non-volatile memory page.        */
X  volatile uint32_t  ERASEPAGE;                          
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory.                    */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPROTECTEDPAGE;                /*!< Register for erasing a protected non-volatile memory page.            */
X  volatile uint32_t  ERASEPROTECTEDPAGE;                 
N  __IO uint32_t  ERASEUICR;                         /*!< Register for start erasing User Information Congfiguration Registers. */
X  volatile uint32_t  ERASEUICR;                          
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PPI controller. (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[4];                  /*!< Channel group tasks.                                                  */
N  __I  uint32_t  RESERVED0[312];
X  volatile const  uint32_t  RESERVED0[312];
N  __IO uint32_t  CHEN;                              /*!< Channel enable.                                                       */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set.                                                   */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear.                                                 */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[16];                               /*!< PPI Channel.                                                          */
N  __I  uint32_t  RESERVED2[156];
X  volatile const  uint32_t  RESERVED2[156];
N  __IO uint32_t  CHG[4];                            /*!< Channel group configuration.                                          */
X  volatile uint32_t  CHG[4];                             
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration. (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size in bytes.                                       */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size in pages.                                            */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __I  uint32_t  CLENR0;                            /*!< Length of code region 0 in bytes.                                     */
X  volatile const  uint32_t  CLENR0;                             
N  __I  uint32_t  PPFC;                              /*!< Pre-programmed factory code present.                                  */
X  volatile const  uint32_t  PPFC;                               
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __I  uint32_t  NUMRAMBLOCK;                       /*!< Number of individualy controllable RAM blocks.                        */
X  volatile const  uint32_t  NUMRAMBLOCK;                        
N  __I  uint32_t  SIZERAMBLOCK[4];                   /*!< Size of RAM block in bytes.                                           */
X  volatile const  uint32_t  SIZERAMBLOCK[4];                    
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __I  uint32_t  CONFIGID;                          /*!< Configuration identifier.                                             */
X  volatile const  uint32_t  CONFIGID;                           
N  __I  uint32_t  DEVICEID[2];                       /*!< Device identifier.                                                    */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED4[6];
X  volatile const  uint32_t  RESERVED4[6];
N  __I  uint32_t  ER[4];                             /*!< Encryption root.                                                      */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Identity root.                                                        */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
X  volatile const  uint32_t  OVERRIDEEN;                         
N  __I  uint32_t  RESERVED5[15];
X  volatile const  uint32_t  RESERVED5[15];
N  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
X  volatile const  uint32_t  BLE_1MBIT[5];                      
N                                                         mode.                                                                 */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration. (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  CLENR0;                            /*!< Length of code region 0.                                              */
X  volatile uint32_t  CLENR0;                             
N  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
X  volatile uint32_t  RBPCONF;                            
N  __IO uint32_t  XTALFREQ;                          /*!< Reset value for CLOCK XTALFREQ register.                              */
X  volatile uint32_t  XTALFREQ;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __I  uint32_t  FWID;                              /*!< Firmware ID.                                                          */
X  volatile const  uint32_t  FWID;                               
N  __IO uint32_t  BOOTLOADERADDR;                    /*!< Bootloader start address.                                             */
X  volatile uint32_t  BOOTLOADERADDR;                     
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief General purpose input and output. (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port.                                                      */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port.                                     */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port.                                   */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins.                                               */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register.                                                     */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register.                                                   */
X  volatile uint32_t  DIRCLR;                             
N  __I  uint32_t  RESERVED1[120];
X  volatile const  uint32_t  RESERVED1[120];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Configuration of GPIO pins.                                           */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_MPU_BASE                    0x40000000UL
N#define NRF_PU_BASE                     0x40000000UL
N#define NRF_AMLI_BASE                   0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_ADC_BASE                    0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_COMP_BASE                   0x40013000UL
N#define NRF_SWI_BASE                    0x40014000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_GPIO_BASE                   0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_MPU                         ((NRF_MPU_Type            *) NRF_MPU_BASE)
N#define NRF_PU                          ((NRF_PU_Type             *) NRF_PU_BASE)
N#define NRF_AMLI                        ((NRF_AMLI_Type           *) NRF_AMLI_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_COMP                        ((NRF_COMP_Type           *) NRF_COMP_BASE)
N#define NRF_SWI                         ((NRF_SWI_Type            *) NRF_SWI_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_GPIO                        ((NRF_GPIO_Type           *) NRF_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nRF51 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nRF51_H */
N
L 17 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include "ble_error_log.h"
L 1 "..\..\..\Software\Include\ble_error_log.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_error_log_module Error Log Module
N * @{
N * @ingroup ble_sdk_lib
N * @brief Module for writing error and stack to flash memory.
N *
N * @details It contains functions for writing an error code, line number, filename/message and
N *          the stack to the flash during an error, e.g. in the assert handler.
N *
N */
N#ifndef BLE_ERROR_LOG_H__
N#define BLE_ERROR_LOG_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "ble_nrf6310_pins.h"
L 1 "..\..\..\Software\Include\ble_nrf6310_pins.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_sdk_lib_nrf6310_pins nRF6310 Board LEDs and Buttons Pin Assignments
N * @{
N * @ingroup ble_sdk_lib
N * @brief Pin assignments for LEDs and Buttons on the nRF6310 board
N *
N * @details Pin assignments for LEDs and Buttons to be used in all SDK applications.
N */
N
N#ifndef BLE_NRF6310_PINS_H__
N#define BLE_NRF6310_PINS_H__
N
N#define NRF6310_LED_0           8
N#define NRF6310_LED_1           9
N#define NRF6310_LED_2           10
N#define NRF6310_LED_3           11
N#define NRF6310_LED_4           12
N#define NRF6310_LED_5           13
N#define NRF6310_LED_6           14
N#define NRF6310_LED_7           15
N
N#define NRF6310_BUTTON_0        0
N#define NRF6310_BUTTON_1        1
N#define NRF6310_BUTTON_2        2
N#define NRF6310_BUTTON_3        3
N#define NRF6310_BUTTON_4        4
N#define NRF6310_BUTTON_5        5
N#define NRF6310_BUTTON_6        6
N#define NRF6310_BUTTON_7        7
N
N#define ADVERTISING_LED_PIN_NO  NRF6310_LED_0
N#define CONNECTED_LED_PIN_NO    NRF6310_LED_1
N#define ASSERT_LED_PIN_NO       NRF6310_LED_7
N
N#endif // BLE_NRF6310_PINS_H__
N
N/** @} */
L 30 "..\..\..\Software\Include\ble_error_log.h" 2
N#include "ble_flash.h"
L 1 "..\..\..\Software\Include\ble_flash.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_flash_module Flash Manager
N * @{
N * @ingroup ble_sdk_lib
N * @brief Module for accessing flash memory.
N *
N * @details It contains functions for reading, writing and erasing one page in flash.
N *
N *          The module uses the first 32 bits of the flash page to write a magic number in order to
N *          determine if the page has been written or not.
N *
N * @note Be careful not to use a page number in the SoftDevice area (which currently occupies the
N *       range 0 to 127), or in your application space! In both cases, this would end up
N *       with a hard fault.
N */
N
N#ifndef BLE_FLASH_H__
N#define BLE_FLASH_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include <nrf51.h>
N
N#define BLE_FLASH_PAGE_SIZE     ((uint16_t)NRF_FICR->CODEPAGESIZE)  /**< Size of one flash page. */
N#define BLE_FLASH_MAGIC_NUMBER  0x45DE0000                          /**< Magic value to identify if flash contains valid data. */
N#define BLE_FLASH_EMPTY_MASK    0xFFFFFFFF                          /**< Bit mask that defines an empty address in flash. */
N
N
N/**@brief Macro for getting the end of the flash available for application.
N * 
N * @details    The result flash page number indicates the end boundary of the flash available 
N *             to the application. If a bootloader is used, the end will be the start of the 
N *             bootloader region. Otherwise, the end will be the size of the flash. 
N */
N#define BLE_FLASH_PAGE_END \
N    ((NRF_UICR->BOOTLOADERADDR != BLE_FLASH_EMPTY_MASK) \
N        ? (NRF_UICR->BOOTLOADERADDR / BLE_FLASH_PAGE_SIZE) \
N        : NRF_FICR->CODESIZE)
X#define BLE_FLASH_PAGE_END     ((NRF_UICR->BOOTLOADERADDR != BLE_FLASH_EMPTY_MASK)         ? (NRF_UICR->BOOTLOADERADDR / BLE_FLASH_PAGE_SIZE)         : NRF_FICR->CODESIZE)
N
N/**@brief Function for erasing the specified flash page, and then writes the given data to this page.
N *
N * @warning This operation blocks the CPU. DO NOT use while in a connection!
N *
N * @param[in]  page_num     Page number to update.
N * @param[in]  p_in_array   Pointer to a RAM area containing the elements to write in flash.
N *                          This area has to be 32 bits aligned.
N * @param[in]  word_count   Number of 32 bits words to write in flash.
N *
N * @return     NRF_SUCCESS on successful flash write, otherwise an error code.
N */
Nuint32_t ble_flash_page_write(uint8_t page_num, uint32_t * p_in_array, uint8_t word_count);
N
N/**@brief Function for reading data from flash to RAM.
N *
N * @param[in]  page_num       Page number to read.
N * @param[out] p_out_array    Pointer to a RAM area where the found data will be written. 
N *                            This area has to be 32 bits aligned.
N * @param[out] p_word_count   Number of 32 bits words read.
N *
N * @return     NRF_SUCCESS on successful upload, NRF_ERROR_NOT_FOUND if no valid data has been found
N *             in flash (first 32 bits not equal to the MAGIC_NUMBER+CRC).
N */
Nuint32_t ble_flash_page_read(uint8_t page_num, uint32_t * p_out_array, uint8_t * p_word_count);
N
N/**@brief Function for erasing a flash page.
N *
N * @note This operation blocks the CPU, so it should not be done while the radio is running!
N *
N * @param[in]  page_num   Page number to erase.
N *
N * @return     NRF_SUCCESS on success, an error_code otherwise.
N */
Nuint32_t ble_flash_page_erase(uint8_t page_num);
N
N/**@brief Function for writing one word to flash.
N *
N * @note Flash location to be written must have been erased previously.
N *
N * @param[in]  p_address   Pointer to flash location to be written.
N * @param[in]  value       Value to write to flash.
N *
N * @return     NRF_SUCCESS.
N */
Nuint32_t ble_flash_word_write(uint32_t * p_address, uint32_t value);
N
N/**@brief Function for writing a data block to flash.
N *
N * @note Flash locations to be written must have been erased previously.
N *
N * @param[in]  p_address    Pointer to start of flash location to be written.
N * @param[in]  p_in_array   Pointer to start of flash block to be written.
N * @param[in]  word_count   Number of words to be written.
N *
N * @return     NRF_SUCCESS.
N */
Nuint32_t ble_flash_block_write(uint32_t * p_address, uint32_t * p_in_array, uint16_t word_count);
N
N/**@brief Function for computing pointer to start of specified flash page.
N *
N * @param[in]  page_num       Page number.
N * @param[out] pp_page_addr   Pointer to start of flash page.
N *
N * @return     NRF_SUCCESS.
N */
Nuint32_t ble_flash_page_addr(uint8_t page_num, uint32_t ** pp_page_addr);
N
N/**@brief Function for calculating a 16 bit CRC using the CRC-16-CCITT scheme.
N * 
N * @param[in]  p_data   Pointer to data on which the CRC is to be calulated.
N * @param[in]  size     Number of bytes on which the CRC is to be calulated.
N * @param[in]  p_crc    Initial CRC value (if NULL, a preset value is used as the initial value).
N *
N * @return     Calculated CRC.
N */
Nuint16_t ble_flash_crc16_compute(uint8_t * p_data, uint16_t size, uint16_t * p_crc);
N
N/**@brief Function for handling flashing module Radio Notification event.
N *
N * @note For flash writing to work safely while in a connection or while advertising, this function
N *       MUST be called from the Radio Notification module's event handler (see
N *       @ref ble_radio_notification for details).
N *
N * @param[in]  radio_active   TRUE if radio is active (or about to become active), FALSE otherwise.
N */
Nvoid ble_flash_on_radio_active_evt(bool radio_active);
Xvoid ble_flash_on_radio_active_evt(_Bool radio_active);
N
N#endif // BLE_FLASH_H__
N
N/** @} */
L 31 "..\..\..\Software\Include\ble_error_log.h" 2
N
N#define ERROR_MESSAGE_LENGTH  128                                /**< Length of error message to stored. */
N#define STACK_DUMP_LENGTH     256                                /**< Length of stack to be stored at max: 64 entries of 4 bytes each. */
N#define FLASH_PAGE_ERROR_LOG  (BLE_FLASH_PAGE_END - 2)           /**< Address in flash where stack trace can be stored. */
N#define LOG_LED_PIN_NO        NRF6310_LED_6                      /**< Use LED 6 to identify messages in log. */
N
N/**@brief Error Log Data structure.
N *
N * @details The structure contains the error, message/filename, line number as well as the current
N *          stack, at the time where an error occured.
N */
Ntypedef struct
N{
N    uint16_t                  failure;                           /**< Indication that a major failure has occurred during last execution of the application. */
N    uint16_t                  line_number;                       /**< Line number indicating at which line the failure occurred. */
N    uint32_t                  err_code;                          /**< Error code when failure occurred. */
N    uint8_t                   message[ERROR_MESSAGE_LENGTH];     /**< Will just use the first 128 bytes of filename to store for debugging purposes. */
X    uint8_t                   message[128];      
N    uint32_t                  stack_info[STACK_DUMP_LENGTH / 4]; /**< Will contain stack information, can be manually unwinded for debug purposes. */
X    uint32_t                  stack_info[256 / 4];  
N} ble_error_log_data_t;
N
N
N/**@brief Function for writing the file name/message, line number, and current program stack
N *        to flash.
N * 
N * @note This function will force the writing to flash, and disregard any radio communication.
N *       USE THIS FUNCTION WITH CARE.
N *
N * @param[in]   err_code    Error code to be logged.
N * @param[in]   p_message   Message to be written to the flash together with stack dump, usually
N *                          the file name where the error occured.
N * @param[in]   line_number Line number where the error occured.
N *
N * @return      NRF_SUCCESS on successful writing of the error log.
N *
N */
Nuint32_t ble_error_log_write(uint32_t err_code, const uint8_t * p_message, uint16_t line_number);
N
N
N/**@brief Function for reading Error Log from flash.
N *
N * @details If an error is present, this function will light LED6 and block current execution.
N *          Execution will continue when @see ble_error_log_clear() is called from application.
N *          @see ble_error_log_clear()  will also delete the error present in the flash.
N *
N * @param[in]   error_log   Pointer to the structure where the Error log present in the flash
N *                          will be put. If no error was present, this structure will not be 
N *                          changed.
N *
N * @return      NRF_SUCCESS if access to the flash was successful and no error was present in the
N *              flash.
N */
Nuint32_t ble_error_log_read(ble_error_log_data_t * error_log);
N
N
N/**@brief Function for clearing the Error Log in flash.
N *
N * @details If an error was present and execution is blocked at @see ble_error_log_read() then this
N *          function will notify the read and ensure operation continues. This function is expected
N *          to be called from an interrupt, e.g. on button press.
N */
Nvoid ble_error_log_clear(void);
N
N
N/**@brief Function for initializing the error log module.
N *
N * @details The init funtion will ensure the flash is initialized so that error can be logged.
N */
Nvoid ble_error_log_init(void);
N
N
N#endif /* BLE_ERROR_LOG_H__ */
N
N/** @} */
L 18 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include "app_util.h"
L 1 "..\..\..\Software\Include\app_util.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include "compiler_abstraction.h"
L 1 "..\..\..\Software\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic
N * Semiconductor ASA.Terms and conditions of usage are described in detail
N * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S  #define __current_sp() __get_SP()
S  
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
Sstatic __INLINE unsigned int __current_sp(void)
S  {
S      register unsigned sp asm("sp");
S      return sp;
S  }
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 27 "..\..\..\Software\Include\app_util.h" 2
N#include "nrf51.h"
N#include "app_error.h"
L 1 "..\..\..\Software\Include\app_error.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N 
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler and macros for utilizing a common error handler.
N */
N
N#ifndef APP_ERROR_H__
N#define APP_ERROR_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf_error.h"
L 1 "..\..\..\Software\Include\nrf_error.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @defgroup nrf_error SoftDevice Global Error Codes
N  @{
N   
N  @brief Global Error definitions
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_H__
N#define NRF_ERROR_H__
N
N/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
N * @{ */
N#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
N#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
N#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
N#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
N/** @} */
N
N#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
N#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
N#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
N#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
N#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
N#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
N#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
N#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
N#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
N#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
N#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
N#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
N#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Data size exceeds limit
N#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
N#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
N#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
N#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
N#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
N
N#endif // NRF_ERROR_H__
N
N/**
N  @}
N*/
L 28 "..\..\..\Software\Include\app_error.h" 2
N
N/**@brief Function for error handling, which is called when an error has occurred. 
N *
N * @param[in] error_code  Error code supplied to the handler.
N * @param[in] line_num    Line number where the handler is called.
N * @param[in] p_file_name Pointer to the file name. 
N */
Nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name);
N
N/**@brief Macro for calling error handler function. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#define APP_ERROR_HANDLER(ERR_CODE)                         \
N    do                                                      \
N    {                                                       \
N        app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);  \
N    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                             do                                                          {                                                               app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);      } while (0)
N
N/**@brief Macro for calling error handler function if supplied error code any other than NRF_SUCCESS. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */    
N#define APP_ERROR_CHECK(ERR_CODE)                           \
N    do                                                      \
N    {                                                       \
N        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);         \
N        if (LOCAL_ERR_CODE != NRF_SUCCESS)                  \
N        {                                                   \
N            APP_ERROR_HANDLER(LOCAL_ERR_CODE);              \
N        }                                                   \
N    } while (0)    
X#define APP_ERROR_CHECK(ERR_CODE)                               do                                                          {                                                               const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 if (LOCAL_ERR_CODE != NRF_SUCCESS)                          {                                                               APP_ERROR_HANDLER(LOCAL_ERR_CODE);                      }                                                       } while (0)    
N    
N/**@brief Macro for calling error handler function if supplied boolean value is false. 
N *
N * @param[in] BOOLEAN_VALUE Boolean value to be evaluated.
N */    
N#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                 \
N    do                                                      \
N    {                                                       \
N        const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);   \
N        if (!LOCAL_BOOLEAN_VALUE)                           \
N        {                                                   \
N            APP_ERROR_HANDLER(0);                           \
N        }                                                   \
N    } while (0)        
X#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                     do                                                          {                                                               const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);           if (!LOCAL_BOOLEAN_VALUE)                                   {                                                               APP_ERROR_HANDLER(0);                                   }                                                       } while (0)        
N
N#endif // APP_ERROR_H__
N
N/** @} */
L 29 "..\..\..\Software\Include\app_util.h" 2
N
N/**@brief The interrupt priorities available to the application while the softdevice is active. */
Ntypedef enum
N{
N    APP_IRQ_PRIORITY_HIGH = 1,
N    APP_IRQ_PRIORITY_LOW  = 3
N} app_irq_priority_t;
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N#define NRF_APP_PRIORITY_THREAD    4                    /**< "Interrupt level" when running in Thread Mode. */
N
N/**@cond NO_DOXYGEN */
N#define EXTERNAL_INT_VECTOR_OFFSET 16
N/**@endcond */
N
N#define PACKED(TYPE) __packed TYPE
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N *
N * @note If the assertion fails when compiling using Keil, the compiler will report error message
N *       "error: #94: the size of an array must be greater than zero" (while gcc will list the
N *       symbol static_assert_failed, making the error message more readable).
N *       If the supplied expression can not be evaluated at compile time, Keil will report
N *       "error: #28: expression must have a constant value".
N *
N * @note The macro is intentionally implemented not using do while(0), allowing it to be used
N *       outside function blocks (e.g. close to global type- and variable declarations).
N *       If used in a code block, it must be used before any executable code in this block.
N *
N * @param[in]   EXPR   Constant expression to be verified.
N */
N
N#define STATIC_ASSERT(EXPR) typedef char static_assert_failed[(EXPR) ? 1 : -1]
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N/**@cond NO_DOXYGEN */
N#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N    do{                                                                               \
N        NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                 \
N            ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                  \
N            ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                  \
N            ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                  \
N            ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                  \
N            ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                   \
N    } while (0)
X#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)     do{                                                                                       NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                             ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                              ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                              ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                              ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                              ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                       } while (0)
N/**@endcond */
N
N/**@brief Macro to configure an I/O.
N *
N * @details This macro configures a given I/O to input or output with pullup/buffer configuration.
N *
N * @param[in]  PIN_NO     I/O pin to configure.
N * @param[in]  IO_DIR     I/O pin direction.
N * @param[in]  IO_INPUT   Connect or disconnect input path.
N * @param[in]  IO_PULL    Pull-up or -down configuration.
N * @param[in]  IO_DRIVE   Drive configuration.
N * @param[in]  IO_SENSE   Pin sensing mechanism.
N */
N#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N            INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
X#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)             INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
N
N/**@brief Configure a PIN to be used as a LED.
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_LED_CONFIG(PIN_NO)                       \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_LED_CONFIG(PIN_NO)                           do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a debug pin (e.g. to be monitored using a logic analyzer).
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                 \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_CONFIG(PIN_NO)                    \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_CONFIG(PIN_NO)                        do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)             \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)                 do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Configure a PIN to be used as a Button, with a pullup resistor enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)        \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)            do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source, with a pullup resistor
N *        enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO) \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Macro for entering a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_ENTER()                                                             \
N    {                                                                                       \
N        uint8_t IS_NESTED_CRITICAL_REGION = 0;                                              \
N        uint32_t CURRENT_INT_PRI = current_int_priority_get();                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);  \
N            if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                __disable_irq();                                                            \
N            }                                                                               \
N            else                                                                            \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }        
X#define CRITICAL_REGION_ENTER()                                                                 {                                                                                               uint8_t IS_NESTED_CRITICAL_REGION = 0;                                                      uint32_t CURRENT_INT_PRI = current_int_priority_get();                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);              if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               __disable_irq();                                                                        }                                                                                           else                                                                                        {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }        
N    
N/**@brief Macro for leaving a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_EXIT()                                                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE;                                                              \
N            __enable_irq();                                                                 \
N            ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);             \
N            if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }                                                                                   \
N    }
X#define CRITICAL_REGION_EXIT()                                                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE;                                                                          __enable_irq();                                                                             ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);                         if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }                                                                                       }
N    
N/**@brief Perform rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N/**@brief Check if the integer provided is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N/**@brief To convert ticks to millisecond
N * @param[in] time          Number of millseconds that needs to be converted.
N * @param[in] resolution    Units to be converted.
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Perform integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    /*lint -save -e573 */   \
N    ((((A) - 1) / (B)) + 1) \
N    /*lint -restore */
X#define CEIL_DIV(A, B)                  ((((A) - 1) / (B)) + 1)      
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N    
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) | 
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N    
N/**@brief Function for finding the current interrupt level.
N *
N * @return   Current interrupt level.
N * @retval   APP_IRQ_PRIORITY_HIGH    We are running in Application High interrupt level.
N * @retval   APP_IRQ_PRIORITY_LOW     We are running in Application Low interrupt level.
N * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
N */
Nstatic __INLINE uint8_t current_int_priority_get(void)
Xstatic __inline uint8_t current_int_priority_get(void)
N{
N    uint32_t isr_vector_num = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
X    uint32_t isr_vector_num = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICSR & (0x1FFUL << 0));
N    if (isr_vector_num > 0)
N    {
N        int32_t irq_type = ((int32_t)isr_vector_num - EXTERNAL_INT_VECTOR_OFFSET);
X        int32_t irq_type = ((int32_t)isr_vector_num - 16);
N        return (NVIC_GetPriority((IRQn_Type)irq_type) & 0xFF);
N    }
N    else
N    {
N        return NRF_APP_PRIORITY_THREAD;
X        return 4;
N    }
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void * p)
Xstatic __inline _Bool is_word_aligned(void * p)
N{
N    return (((uint32_t)p & 0x00000003) == 0);
N}
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 19 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include "app_error.h"
N#include "nrf_gpio.h"
L 1 "..\..\..\Software\Include\nrf_gpio.h" 1
N#ifndef NRF_GPIO_H__
N#define NRF_GPIO_H__
N
N#include "nrf51.h"
N#include "nrf51_bitfields.h"
L 1 "..\..\..\Software\Include\nrf51_bitfields.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef __NRF51_BITS_H
N#define __NRF51_BITS_H
N
N/*lint ++flb "Enter library region */
N
N#include <core_cm0.h>
L 1 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.02
N * @date     16. July 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
S#define __CORE_CM0_H_GENERIC
S
S/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/** \ingroup Cortex_M0
S  @{
S */
S
S/*  CMSIS CM0 definitions */
S#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
S#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
S#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
S                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
S
S#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
S*/
S#define __FPU_USED       0
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S#endif
S
S#include <stdint.h>                      /* standard types definitions                      */
S#include <core_cmInstr.h>                /* Core Instruction Access                         */
S#include <core_cmFunc.h>                 /* Core Function Access                            */
S
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
S#define __CORE_CM0_H_DEPENDANT
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions                */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
S
S/*@} end of group Cortex_M0 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S ******************************************************************************/
S/** \defgroup CMSIS_core_register Defines and Type Definitions
S    \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_CORE  Status and Control Registers
S    \brief  Core Register type definitions.
S  @{
S */
S
S/** \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
S#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
S#endif
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} APSR_Type;
S
S
S/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} IPSR_Type;
S
S
S/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
S#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
S#endif
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} xPSR_Type;
S
S
S/** \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} CONTROL_Type;
S
S/*@} end of group CMSIS_CORE */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S    \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
S       uint32_t RESERVED0[31];
S  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
S       uint32_t RSERVED1[31];
S  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
S       uint32_t RESERVED2[31];
S  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
S       uint32_t RESERVED3[31];
S       uint32_t RESERVED4[64];
S  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
S}  NVIC_Type;
S
S/*@} end of group CMSIS_NVIC */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCB     System Control Block (SCB)
S    \brief      Type definitions for the System Control Block Registers
S  @{
S */
S
S/** \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
S  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
S       uint32_t RESERVED0;
S  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
S  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
S  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
S       uint32_t RESERVED1;
S  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
S  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S    \brief      Type definitions for the System Timer Registers.
S  @{
S */
S
S/** \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
S  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
S  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
S                are only accessible over DAP and not via processor. Therefore
S                they are not covered by the Cortex-M0 header file.
S  @{
S */
S/*@} end of group CMSIS_CoreDebug */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_core_base     Core Definitions
S    \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M0 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
S
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S    \brief      Functions that manage interrupts and exceptions via the NVIC.
S    @{
S */
S
S/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
S/* The following MACROS handle generation of the register offset and byte masks */
S#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
S#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
S#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
S
S
S/** \brief  Enable External Interrupt
S
S    The function enables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Disable External Interrupt
S
S    The function disables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Get Pending Interrupt
S
S    The function reads the pending register in the NVIC and returns the pending bit
S    for the specified interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not pending.
S    \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
S}
S
S
S/** \brief  Set Pending Interrupt
S
S    The function sets the pending bit of an external interrupt.
S
S    \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Clear Pending Interrupt
S
S    The function clears the pending bit of an external interrupt.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
S}
S
S
S/** \brief  Set Interrupt Priority
S
S    The function sets the priority of an interrupt.
S
S    \note The priority cannot be set for every core interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S    \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if(IRQn < 0) {
S    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S  else {
S    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S}
S
S
S/** \brief  Get Interrupt Priority
S
S    The function reads the priority of an interrupt. The interrupt
S    number can be positive to specify an external (device specific)
S    interrupt, or negative to specify an internal (core) interrupt.
S
S
S    \param [in]   IRQn  Interrupt number.
S    \return             Interrupt Priority. Value is aligned automatically to the implemented
S                        priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if(IRQn < 0) {
S    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
S  else {
S    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
S}
S
S
S/** \brief  System Reset
S
S    The function initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                     /* Ensure all outstanding memory accesses included
S                                                                  buffered write are completed before reset */
S  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
S                 SCB_AIRCR_SYSRESETREQ_Msk);
S  __DSB();                                                     /* Ensure completion of memory access */
S  while(1);                                                    /* wait until reset */
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S    \brief      Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0)
S
S/** \brief  System Tick Configuration
S
S    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
S    Counter is in free running mode to generate periodic interrupts.
S
S    \param [in]  ticks  Number of ticks between two interrupts.
S
S    \return          0  Function succeeded.
S    \return          1  Function failed.
S
S    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S    must contain a vendor-specific implementation of this function.
S
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
S
S  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
S  return (0);                                                  /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 20 "..\..\..\Software\Include\nrf51_bitfields.h" 2
N
N/* Peripheral: AAR */
N/* Description: Accelerated Address Resolver. */
N
N/* Register: AAR_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on NOTRESOLVED event. */
N#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on RESOLVED event. */
N#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: AAR_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on NOTRESOLVED event. */
N#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on RESOLVED event. */
N#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: AAR_STATUS */
N/* Description: Resolution status. */
N
N/* Bits 3..0 : The IRK used last time an address was resolved. */
N#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N
N/* Register: AAR_ENABLE */
N/* Description: Enable AAR. */
N
N/* Bits 1..0 : Enable AAR. */
N#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled AAR. */
N#define AAR_ENABLE_ENABLE_Enabled (0x03UL) /*!< Enable AAR. */
N
N/* Register: AAR_NIRK */
N/* Description: Number of Identity root Keys in the IRK data structure. */
N
N/* Bits 4..0 : Number of Identity root Keys in the IRK data structure. */
N#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
N#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
N
N/* Register: AAR_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define AAR_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define AAR_POWER_POWER_Msk (0x1UL << AAR_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define AAR_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define AAR_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ADC */
N/* Description: Analog to digital converter. */
N
N/* Register: ADC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define ADC_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENSET_END_Msk (0x1UL << ADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ADC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on END event. */
N#define ADC_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENCLR_END_Msk (0x1UL << ADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ADC_BUSY */
N/* Description: ADC busy register. */
N
N/* Bit 0 : ADC busy register. */
N#define ADC_BUSY_BUSY_Pos (0UL) /*!< Position of BUSY field. */
N#define ADC_BUSY_BUSY_Msk (0x1UL << ADC_BUSY_BUSY_Pos) /*!< Bit mask of BUSY field. */
N#define ADC_BUSY_BUSY_Ready (0UL) /*!< No ongoing ADC conversion is taking place. ADC is ready. */
N#define ADC_BUSY_BUSY_Busy (1UL) /*!< An ADC conversion is taking place. ADC is busy. */
N
N/* Register: ADC_ENABLE */
N/* Description: ADC enable. */
N
N/* Bits 1..0 : ADC enable. */
N#define ADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Msk (0x3UL << ADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Disabled (0x00UL) /*!< ADC is disabled. */
N#define ADC_ENABLE_ENABLE_Enabled (0x01UL) /*!< ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input. */
N
N/* Register: ADC_CONFIG */
N/* Description: ADC configuration register. */
N
N/* Bits 17..16 : ADC external reference pin selection. */
N#define ADC_CONFIG_EXTREFSEL_Pos (16UL) /*!< Position of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_Msk (0x3UL << ADC_CONFIG_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_None (0UL) /*!< Analog external reference inputs disabled. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference0 (1UL) /*!< Use analog reference 0 as reference. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference1 (2UL) /*!< Use analog reference 1 as reference. */
N
N/* Bits 15..8 : ADC analog pin selection. */
N#define ADC_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define ADC_CONFIG_PSEL_Msk (0xFFUL << ADC_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define ADC_CONFIG_PSEL_Disabled (0UL) /*!< Analog input pins disabled. */
N#define ADC_CONFIG_PSEL_AnalogInput0 (1UL) /*!< Use analog input 0 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput1 (2UL) /*!< Use analog input 1 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput2 (4UL) /*!< Use analog input 2 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput3 (8UL) /*!< Use analog input 3 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput4 (16UL) /*!< Use analog input 4 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput5 (32UL) /*!< Use analog input 5 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput6 (64UL) /*!< Use analog input 6 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput7 (128UL) /*!< Use analog input 7 as analog input. */
N
N/* Bits 6..5 : ADC reference selection. */
N#define ADC_CONFIG_REFSEL_Pos (5UL) /*!< Position of REFSEL field. */
N#define ADC_CONFIG_REFSEL_Msk (0x3UL << ADC_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define ADC_CONFIG_REFSEL_VBG (0x00UL) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */
N#define ADC_CONFIG_REFSEL_External (0x01UL) /*!< Use external source configured by EXTREFSEL as reference for conversion. */
N#define ADC_CONFIG_REFSEL_SupplyOneHalfPrescaling (0x02UL) /*!< Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V. */
N#define ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling (0x03UL) /*!< Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V. */
N
N/* Bits 4..2 : ADC input selection. */
N#define ADC_CONFIG_INPSEL_Pos (2UL) /*!< Position of INPSEL field. */
N#define ADC_CONFIG_INPSEL_Msk (0x7UL << ADC_CONFIG_INPSEL_Pos) /*!< Bit mask of INPSEL field. */
N#define ADC_CONFIG_INPSEL_AnalogInputNoPrescaling (0x00UL) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputTwoThirdsPrescaling (0x01UL) /*!< Analog input specified by PSEL with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling (0x02UL) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyTwoThirdsPrescaling (0x05UL) /*!< Supply voltage with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling (0x06UL) /*!< Supply voltage with 1/3 prescaling used as input for the conversion. */
N
N/* Bits 1..0 : ADC resolution. */
N#define ADC_CONFIG_RES_Pos (0UL) /*!< Position of RES field. */
N#define ADC_CONFIG_RES_Msk (0x3UL << ADC_CONFIG_RES_Pos) /*!< Bit mask of RES field. */
N#define ADC_CONFIG_RES_8bit (0x00UL) /*!< 8bit ADC resolution. */
N#define ADC_CONFIG_RES_9bit (0x01UL) /*!< 9bit ADC resolution. */
N#define ADC_CONFIG_RES_10bit (0x02UL) /*!< 10bit ADC resolution. */
N
N/* Register: ADC_RESULT */
N/* Description: Result of ADC conversion. */
N
N/* Bits 9..0 : Result of ADC conversion. */
N#define ADC_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define ADC_RESULT_RESULT_Msk (0x3FFUL << ADC_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N
N/* Register: ADC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ADC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ADC_POWER_POWER_Msk (0x1UL << ADC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ADC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ADC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: AMLI */
N/* Description: AHB Multi-Layer Interface. */
N
N/* Register: AMLI_RAMPRI_CPU0 */
N/* Description: Configurable priority configuration register for CPU0. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_CPU0_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_CPU0_RAM3_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_CPU0_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_CPU0_RAM2_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_CPU0_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_CPU0_RAM1_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_CPU0_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_CPU0_RAM0_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_SPIS1 */
N/* Description: Configurable priority configuration register for SPIS1. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_SPIS1_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_SPIS1_RAM3_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_SPIS1_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_SPIS1_RAM2_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_SPIS1_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_SPIS1_RAM1_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_SPIS1_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_SPIS1_RAM0_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_RADIO */
N/* Description: Configurable priority configuration register for RADIO. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_RADIO_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_RADIO_RAM3_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_RADIO_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_RADIO_RAM2_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_RADIO_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_RADIO_RAM1_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_RADIO_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_RADIO_RAM0_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_ECB */
N/* Description: Configurable priority configuration register for ECB. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_ECB_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_ECB_RAM3_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_ECB_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_ECB_RAM2_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_ECB_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_ECB_RAM1_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_ECB_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_ECB_RAM0_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_CCM */
N/* Description: Configurable priority configuration register for CCM. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_CCM_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_CCM_RAM3_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_CCM_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_CCM_RAM2_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_CCM_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_CCM_RAM1_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_CCM_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_CCM_RAM0_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_AAR */
N/* Description: Configurable priority configuration register for AAR. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_AAR_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_AAR_RAM3_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_AAR_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_AAR_RAM2_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_AAR_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_AAR_RAM1_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_AAR_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_AAR_RAM0_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Peripheral: CCM */
N/* Description: AES CCM Mode Encryption. */
N
N/* Register: CCM_SHORTS */
N/* Description: Shortcut for the CCM. */
N
N/* Bit 0 : Short-cut between ENDKSGEN event and CRYPT task. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Shortcut disabled. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: CCM_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ERROR event. */
N#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ENDCRYPT event. */
N#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDKSGEN event. */
N#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CCM_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ERROR event. */
N#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ENDCRYPT event. */
N#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CCM_MICSTATUS */
N/* Description: CCM RX MIC check result. */
N
N/* Bit 0 : Result of the MIC check performed during the previous CCM RX STARTCRYPT */
N#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed. */
N#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed. */
N
N/* Register: CCM_ENABLE */
N/* Description: CCM enable. */
N
N/* Bits 1..0 : CCM enable. */
N#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Disabled (0x00UL) /*!< CCM is disabled. */
N#define CCM_ENABLE_ENABLE_Enabled (0x02UL) /*!< CCM is enabled. */
N
N/* Register: CCM_MODE */
N/* Description: Operation mode. */
N
N/* Bit 0 : CCM mode operation. */
N#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define CCM_MODE_MODE_Encryption (0UL) /*!< CCM mode TX */
N#define CCM_MODE_MODE_Decryption (1UL) /*!< CCM mode TX */
N
N/* Register: CCM_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define CCM_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define CCM_POWER_POWER_Msk (0x1UL << CCM_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define CCM_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define CCM_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CLOCK */
N/* Description: Clock control. */
N
N/* Register: CLOCK_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 4 : Enable interrupt on CTTO event. */
N#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on DONE event. */
N#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CLOCK_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 4 : Disable interrupt on CTTO event. */
N#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on DONE event. */
N#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CLOCK_HFCLKSTAT */
N/* Description: High frequency clock status. */
N
N/* Bit 16 : State for the HFCLK. */
N#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK clock not running. */
N#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK clock running. */
N
N/* Bit 0 : Active clock source for the HF clock. */
N#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< Internal 16MHz RC oscillator running and generating the HFCLK clock. */
N#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock. */
N
N/* Register: CLOCK_LFCLKSTAT */
N/* Description: Low frequency clock status. */
N
N/* Bit 16 : State for the LF clock. */
N#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK clock not running. */
N#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK clock running. */
N
N/* Bits 1..0 : Active clock source for the LF clock. */
N#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< External 32KiHz crystal oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock. */
N
N/* Register: CLOCK_LFCLKSRC */
N/* Description: Clock source for the LFCLK clock. */
N
N/* Bits 1..0 : Clock source. */
N#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_CTIV */
N/* Description: Calibration timer interval. */
N
N/* Bits 6..0 : Calibration timer interval in 0.25s resolution. */
N#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
N#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
N
N/* Register: CLOCK_XTALFREQ */
N/* Description: Crystal frequency. */
N
N/* Bits 7..0 : External Xtal frequency selection. */
N#define CLOCK_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_Msk (0xFFUL << CLOCK_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz xtal is used. */
N#define CLOCK_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz xtal is used. */
N
N
N/* Peripheral: COMP */
N/* Description: Comparator. */
N
N/* Register: COMP_SHORTS */
N/* Description: Shortcut for the COMP. */
N
N/* Bit 4 : Short-cut between CROSS event and STOP task. */
N#define COMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Msk (0x1UL << COMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Short-cut between UP event and STOP task. */
N#define COMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Msk (0x1UL << COMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Short-cut between DOWN event and STOP task. */
N#define COMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Msk (0x1UL << COMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Short-cut between RADY event and STOP task. */
N#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between READY event and SAMPLE task. */
N#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: COMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define COMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENSET_CROSS_Msk (0x1UL << COMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define COMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENSET_UP_Msk (0x1UL << COMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define COMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENSET_DOWN_Msk (0x1UL << COMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: COMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define COMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENCLR_CROSS_Msk (0x1UL << COMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define COMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENCLR_UP_Msk (0x1UL << COMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define COMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENCLR_DOWN_Msk (0x1UL << COMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: COMP_RESULT */
N/* Description: Compare result. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define COMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define COMP_RESULT_RESULT_Msk (0x1UL << COMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define COMP_RESULT_RESULT_Bellow (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define COMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: COMP_ENABLE */
N/* Description: Enable the COMP. */
N
N/* Bits 1..0 : Enable or disable COMP. */
N#define COMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Msk (0x3UL << COMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled COMP. */
N#define COMP_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable COMP. */
N
N/* Register: COMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define COMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define COMP_PSEL_PSEL_Msk (0x7UL << COMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define COMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: COMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define COMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Msk (0x7UL << COMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Int1V5 (0UL) /*!< Use internal 1V5 as reference. */
N#define COMP_REFSEL_REFSEL_Int2V0 (1UL) /*!< Use internal 2V0 as reference. */
N#define COMP_REFSEL_REFSEL_Int2V5 (2UL) /*!< Use internal 2V5 as reference. */
N#define COMP_REFSEL_REFSEL_Supply (4UL) /*!< Use supply as reference. */
N#define COMP_REFSEL_REFSEL_ARef (5UL) /*!< Use external analog reference as reference. */
N
N/* Register: COMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define COMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << COMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: COMP_TH */
N/* Description: Threshold configuration for hysteresis unit. */
N
N/* Bits 13..8 : VDOWN configuration. */
N#define COMP_TH_THDOWN_Pos (8UL) /*!< Position of THDOWN field. */
N#define COMP_TH_THDOWN_Msk (0x3FUL << COMP_TH_THDOWN_Pos) /*!< Bit mask of THDOWN field. */
N
N/* Bits 5..0 : VUP configuration. */
N#define COMP_TH_THUP_Pos (0UL) /*!< Position of THUP field. */
N#define COMP_TH_THUP_Msk (0x3FUL << COMP_TH_THUP_Pos) /*!< Bit mask of THUP field. */
N
N/* Register: COMP_MODE */
N/* Description: Mode configuration. */
N
N/* Bit 8 : Main operation mode. */
N#define COMP_MODE_MAIN_Pos (8UL) /*!< Position of MAIN field. */
N#define COMP_MODE_MAIN_Msk (0x1UL << COMP_MODE_MAIN_Pos) /*!< Bit mask of MAIN field. */
N#define COMP_MODE_MAIN_Single (0UL) /*!< Single ended mode. */
N#define COMP_MODE_MAIN_Diff (1UL) /*!< Differential mode. */
N
N/* Bits 1..0 : Speed and power mode. */
N#define COMP_MODE_SP_Pos (0UL) /*!< Position of SP field. */
N#define COMP_MODE_SP_Msk (0x3UL << COMP_MODE_SP_Pos) /*!< Bit mask of SP field. */
N#define COMP_MODE_SP_Low (0UL) /*!< Low power mode. */
N#define COMP_MODE_SP_Normal (1UL) /*!< Normal mode. */
N#define COMP_MODE_SP_High (2UL) /*!< High speed mode. */
N
N/* Register: COMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define COMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define COMP_POWER_POWER_Msk (0x1UL << COMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define COMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define COMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ECB */
N/* Description: AES ECB Mode Encryption. */
N
N/* Register: ECB_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 1 : Enable interrupt on ERRORECB event. */
N#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDECB event. */
N#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ECB_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 1 : Disable interrupt on ERRORECB event. */
N#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDECB event. */
N#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ECB_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ECB_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ECB_POWER_POWER_Msk (0x1UL << ECB_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ECB_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ECB_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: FICR */
N/* Description: Factory Information Configuration. */
N
N/* Register: FICR_PPFC */
N/* Description: Pre-programmed factory code present. */
N
N/* Bits 7..0 : Pre-programmed factory code present. */
N#define FICR_PPFC_PPFC_Pos (0UL) /*!< Position of PPFC field. */
N#define FICR_PPFC_PPFC_Msk (0xFFUL << FICR_PPFC_PPFC_Pos) /*!< Bit mask of PPFC field. */
N#define FICR_PPFC_PPFC_NotPresent (0xFFUL) /*!< Not present. */
N#define FICR_PPFC_PPFC_Present (0x00UL) /*!< Present. */
N
N/* Register: FICR_CONFIGID */
N/* Description: Configuration identifier. */
N
N/* Bits 31..16 : Firmware Identification Number pre-loaded into the flash. */
N#define FICR_CONFIGID_FWID_Pos (16UL) /*!< Position of FWID field. */
N#define FICR_CONFIGID_FWID_Msk (0xFFFFUL << FICR_CONFIGID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N/* Bits 15..0 : Hardware Identification Number. */
N#define FICR_CONFIGID_HWID_Pos (0UL) /*!< Position of HWID field. */
N#define FICR_CONFIGID_HWID_Msk (0xFFFFUL << FICR_CONFIGID_HWID_Pos) /*!< Bit mask of HWID field. */
N
N/* Register: FICR_DEVICEADDRTYPE */
N/* Description: Device address type. */
N
N/* Bit 0 : Device address type. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address. */
N
N/* Register: FICR_OVERRIDEEN */
N/* Description: Radio calibration override enable. */
N
N/* Bit 3 : Override default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Pos (3UL) /*!< Position of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_BLE_1MBIT_Pos) /*!< Bit mask of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Override (0UL) /*!< Override the default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_NotOverride (1UL) /*!< Do not override the default values for BLE_1Mbit mode. */
N
N
N/* Peripheral: GPIO */
N/* Description: General purpose input and output. */
N
N/* Register: GPIO_OUT */
N/* Description: Write GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high. */
N
N/* Register: GPIO_OUTSET */
N/* Description: Set individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Set pin driver high. */
N
N/* Register: GPIO_OUTCLR */
N/* Description: Clear individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Set pin driver low. */
N
N/* Register: GPIO_IN */
N/* Description: Read GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high. */
N
N/* Register: GPIO_DIR */
N/* Description: Direction of GPIO pins. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output. */
N
N/* Register: GPIO_DIRSET */
N/* Description: DIR set register. */
N
N/* Bit 31 : Set as output pin 31. */
N#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 30 : Set as output pin 30. */
N#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 29 : Set as output pin 29. */
N#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 28 : Set as output pin 28. */
N#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 27 : Set as output pin 27. */
N#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 26 : Set as output pin 26. */
N#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 25 : Set as output pin 25. */
N#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 24 : Set as output pin 24. */
N#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 23 : Set as output pin 23. */
N#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 22 : Set as output pin 22. */
N#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 21 : Set as output pin 21. */
N#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 20 : Set as output pin 20. */
N#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 19 : Set as output pin 19. */
N#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 18 : Set as output pin 18. */
N#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 17 : Set as output pin 17. */
N#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 16 : Set as output pin 16. */
N#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 15 : Set as output pin 15. */
N#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 14 : Set as output pin 14. */
N#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 13 : Set as output pin 13. */
N#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 12 : Set as output pin 12. */
N#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 11 : Set as output pin 11. */
N#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 10 : Set as output pin 10. */
N#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 9 : Set as output pin 9. */
N#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 8 : Set as output pin 8. */
N#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 7 : Set as output pin 7. */
N#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 6 : Set as output pin 6. */
N#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 5 : Set as output pin 5. */
N#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 4 : Set as output pin 4. */
N#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 3 : Set as output pin 3. */
N#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 2 : Set as output pin 2. */
N#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 1 : Set as output pin 1. */
N#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 0 : Set as output pin 0. */
N#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Set pin as output. */
N
N/* Register: GPIO_DIRCLR */
N/* Description: DIR clear register. */
N
N/* Bit 31 : Set as input pin 31. */
N#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 30 : Set as input pin 30. */
N#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 29 : Set as input pin 29. */
N#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 28 : Set as input pin 28. */
N#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 27 : Set as input pin 27. */
N#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 26 : Set as input pin 26. */
N#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 25 : Set as input pin 25. */
N#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 24 : Set as input pin 24. */
N#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 23 : Set as input pin 23. */
N#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 22 : Set as input pin 22. */
N#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 21 : Set as input pin 21. */
N#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 20 : Set as input pin 20. */
N#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 19 : Set as input pin 19. */
N#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 18 : Set as input pin 18. */
N#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 17 : Set as input pin 17. */
N#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 16 : Set as input pin 16. */
N#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 15 : Set as input pin 15. */
N#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 14 : Set as input pin 14. */
N#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 13 : Set as input pin 13. */
N#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 12 : Set as input pin 12. */
N#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 11 : Set as input pin 11. */
N#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 10 : Set as input pin 10. */
N#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 9 : Set as input pin 9. */
N#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 8 : Set as input pin 8. */
N#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 7 : Set as input pin 7. */
N#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 6 : Set as input pin 6. */
N#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 5 : Set as input pin 5. */
N#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 4 : Set as input pin 4. */
N#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 3 : Set as input pin 3. */
N#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 2 : Set as input pin 2. */
N#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 1 : Set as input pin 1. */
N#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 0 : Set as input pin 0. */
N#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Set pin as input. */
N
N/* Register: GPIO_PIN_CNF */
N/* Description: Configuration of GPIO pins. */
N
N/* Bits 17..16 : Pin sensing mechanism. */
N#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIO_PIN_CNF_SENSE_High (0x02UL) /*!< Wakeup on high level. */
N#define GPIO_PIN_CNF_SENSE_Low (0x03UL) /*!< Wakeup on low level. */
N
N/* Bits 10..8 : Drive configuration. */
N#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_S0S1 (0x00UL) /*!< Standard '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0S1 (0x01UL) /*!< High '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0H1 (0x02UL) /*!< Standard '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0H1 (0x03UL) /*!< High '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0S1 (0x04UL) /*!< Disconnected '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0H1 (0x05UL) /*!< Disconnected '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0D1 (0x06UL) /*!< Standard '0', Disconnected '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0D1 (0x07UL) /*!< High '0', Disconnected '1'. */
N
N/* Bits 3..2 : Pull-up or -down configuration. */
N#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
N#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
N#define GPIO_PIN_CNF_PULL_Disabled (0x00UL) /*!< No pull. */
N#define GPIO_PIN_CNF_PULL_Pulldown (0x01UL) /*!< Pulldown on pin. */
N#define GPIO_PIN_CNF_PULL_Pullup (0x03UL) /*!< Pullup on pin. */
N
N/* Bit 1 : Connect or disconnect input path. */
N#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input pin. */
N#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input pin. */
N
N/* Bit 0 : Pin direction. */
N#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
N#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
N#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin. */
N#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin. */
N
N
N/* Peripheral: GPIOTE */
N/* Description: GPIO tasks and events. */
N
N/* Register: GPIOTE_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 31 : Enable interrupt on PORT event. */
N#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on IN[3] event. */
N#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on IN[2] event. */
N#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on IN[1] event. */
N#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on IN[0] event. */
N#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: GPIOTE_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 31 : Disable interrupt on PORT event. */
N#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on IN[3] event. */
N#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on IN[2] event. */
N#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on IN[1] event. */
N#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on IN[0] event. */
N#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: GPIOTE_CONFIG */
N/* Description: Channel configuration registers. */
N
N/* Bit 20 : Initial value of the output when the GPIOTE channel is configured as a Task. */
N#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Initial low output when in task mode. */
N#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Initial high output when in task mode. */
N
N/* Bits 17..16 : Effects on output when in Task mode, or events on input that generates an event. */
N#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_LoToHi (0x01UL) /*!< Low to high. */
N#define GPIOTE_CONFIG_POLARITY_HiToLo (0x02UL) /*!< High to low. */
N#define GPIOTE_CONFIG_POLARITY_Toggle (0x03UL) /*!< Toggle. */
N
N/* Bits 12..8 : Pin select. */
N#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N
N/* Bits 1..0 : Mode */
N#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define GPIOTE_CONFIG_MODE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIOTE_CONFIG_MODE_Event (0x01UL) /*!< Channel configure in event mode. */
N#define GPIOTE_CONFIG_MODE_Task (0x03UL) /*!< Channel configure in task mode. */
N
N/* Register: GPIOTE_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define GPIOTE_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define GPIOTE_POWER_POWER_Msk (0x1UL << GPIOTE_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define GPIOTE_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define GPIOTE_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: LPCOMP */
N/* Description: Wakeup Comparator. */
N
N/* Register: LPCOMP_SHORTS */
N/* Description: Shortcut for the LPCOMP. */
N
N/* Bit 4 : Short-cut between CROSS event and STOP task. */
N#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Short-cut between UP event and STOP task. */
N#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Short-cut between DOWN event and STOP task. */
N#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Short-cut between RADY event and STOP task. */
N#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between READY event and SAMPLE task. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: LPCOMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: LPCOMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: LPCOMP_RESULT */
N/* Description: Result of last compare. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Bellow (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: LPCOMP_ENABLE */
N/* Description: Enable the LPCOMP. */
N
N/* Bits 1..0 : Enable or disable LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable LPCOMP. */
N
N/* Register: LPCOMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: LPCOMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Msk (0x7UL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling (0UL) /*!< Use analog supply with a 1/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling (1UL) /*!< Use analog supply with a 2/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling (2UL) /*!< Use analog supply with a 3/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling (3UL) /*!< Use analog supply with a 4/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling (4UL) /*!< Use analog supply with a 5/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling (5UL) /*!< Use analog supply with a 6/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling (6UL) /*!< Use analog supply with a 7/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< Use external analog reference as reference. */
N
N/* Register: LPCOMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: LPCOMP_ANADETECT */
N/* Description: Analog detect configuration. */
N
N/* Bits 1..0 : Analog detect configuration. */
N#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETEC on crossing, both upwards and downwards crossing. */
N#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETEC on upwards crossing only. */
N#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETEC on downwards crossing only. */
N
N/* Register: LPCOMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define LPCOMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define LPCOMP_POWER_POWER_Msk (0x1UL << LPCOMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define LPCOMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define LPCOMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: MPU */
N/* Description: Memory Protection Unit. */
N
N/* Register: MPU_PERR0 */
N/* Description: Configuration of peripherals in mpu regions. */
N
N/* Bit 31 : PPI region configuration. */
N#define MPU_PERR0_PPI_Pos (31UL) /*!< Position of PPI field. */
N#define MPU_PERR0_PPI_Msk (0x1UL << MPU_PERR0_PPI_Pos) /*!< Bit mask of PPI field. */
N#define MPU_PERR0_PPI_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_PPI_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 30 : NVMC region configuration. */
N#define MPU_PERR0_NVMC_Pos (30UL) /*!< Position of NVMC field. */
N#define MPU_PERR0_NVMC_Msk (0x1UL << MPU_PERR0_NVMC_Pos) /*!< Bit mask of NVMC field. */
N#define MPU_PERR0_NVMC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_NVMC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 19 : LPCOMP_COMP region configuration. */
N#define MPU_PERR0_LPCOMP_COMP_Pos (19UL) /*!< Position of LPCOMP_COMP field. */
N#define MPU_PERR0_LPCOMP_COMP_Msk (0x1UL << MPU_PERR0_LPCOMP_COMP_Pos) /*!< Bit mask of LPCOMP_COMP field. */
N#define MPU_PERR0_LPCOMP_COMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_LPCOMP_COMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 18 : QDEC region configuration. */
N#define MPU_PERR0_QDEC_Pos (18UL) /*!< Position of QDEC field. */
N#define MPU_PERR0_QDEC_Msk (0x1UL << MPU_PERR0_QDEC_Pos) /*!< Bit mask of QDEC field. */
N#define MPU_PERR0_QDEC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_QDEC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 17 : RTC1 region configuration. */
N#define MPU_PERR0_RTC1_Pos (17UL) /*!< Position of RTC1 field. */
N#define MPU_PERR0_RTC1_Msk (0x1UL << MPU_PERR0_RTC1_Pos) /*!< Bit mask of RTC1 field. */
N#define MPU_PERR0_RTC1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 16 : WDT region configuration. */
N#define MPU_PERR0_WDT_Pos (16UL) /*!< Position of WDT field. */
N#define MPU_PERR0_WDT_Msk (0x1UL << MPU_PERR0_WDT_Pos) /*!< Bit mask of WDT field. */
N#define MPU_PERR0_WDT_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_WDT_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 15 : CCM and AAR region configuration. */
N#define MPU_PERR0_CCM_AAR_Pos (15UL) /*!< Position of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_Msk (0x1UL << MPU_PERR0_CCM_AAR_Pos) /*!< Bit mask of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_CCM_AAR_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 14 : ECB region configuration. */
N#define MPU_PERR0_ECB_Pos (14UL) /*!< Position of ECB field. */
N#define MPU_PERR0_ECB_Msk (0x1UL << MPU_PERR0_ECB_Pos) /*!< Bit mask of ECB field. */
N#define MPU_PERR0_ECB_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ECB_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 13 : RNG region configuration. */
N#define MPU_PERR0_RNG_Pos (13UL) /*!< Position of RNG field. */
N#define MPU_PERR0_RNG_Msk (0x1UL << MPU_PERR0_RNG_Pos) /*!< Bit mask of RNG field. */
N#define MPU_PERR0_RNG_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RNG_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 12 : TEMP region configuration. */
N#define MPU_PERR0_TEMP_Pos (12UL) /*!< Position of TEMP field. */
N#define MPU_PERR0_TEMP_Msk (0x1UL << MPU_PERR0_TEMP_Pos) /*!< Bit mask of TEMP field. */
N#define MPU_PERR0_TEMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TEMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 11 : RTC0 region configuration. */
N#define MPU_PERR0_RTC0_Pos (11UL) /*!< Position of RTC0 field. */
N#define MPU_PERR0_RTC0_Msk (0x1UL << MPU_PERR0_RTC0_Pos) /*!< Bit mask of RTC0 field. */
N#define MPU_PERR0_RTC0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 10 : TIMER2 region configuration. */
N#define MPU_PERR0_TIMER2_Pos (10UL) /*!< Position of TIMER2 field. */
N#define MPU_PERR0_TIMER2_Msk (0x1UL << MPU_PERR0_TIMER2_Pos) /*!< Bit mask of TIMER2 field. */
N#define MPU_PERR0_TIMER2_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER2_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 9 : TIMER1 region configuration. */
N#define MPU_PERR0_TIMER1_Pos (9UL) /*!< Position of TIMER1 field. */
N#define MPU_PERR0_TIMER1_Msk (0x1UL << MPU_PERR0_TIMER1_Pos) /*!< Bit mask of TIMER1 field. */
N#define MPU_PERR0_TIMER1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 8 : TIMER0 region configuration. */
N#define MPU_PERR0_TIMER0_Pos (8UL) /*!< Position of TIMER0 field. */
N#define MPU_PERR0_TIMER0_Msk (0x1UL << MPU_PERR0_TIMER0_Pos) /*!< Bit mask of TIMER0 field. */
N#define MPU_PERR0_TIMER0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 7 : ADC region configuration. */
N#define MPU_PERR0_ADC_Pos (7UL) /*!< Position of ADC field. */
N#define MPU_PERR0_ADC_Msk (0x1UL << MPU_PERR0_ADC_Pos) /*!< Bit mask of ADC field. */
N#define MPU_PERR0_ADC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ADC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 6 : GPIOTE region configuration. */
N#define MPU_PERR0_GPIOTE_Pos (6UL) /*!< Position of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_Msk (0x1UL << MPU_PERR0_GPIOTE_Pos) /*!< Bit mask of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_GPIOTE_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 4 : SPI1 and TWI1 region configuration. */
N#define MPU_PERR0_SPI1_TWI1_Pos (4UL) /*!< Position of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_Msk (0x1UL << MPU_PERR0_SPI1_TWI1_Pos) /*!< Bit mask of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI1_TWI1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 3 : SPI0 and TWI0 region configuration. */
N#define MPU_PERR0_SPI0_TWI0_Pos (3UL) /*!< Position of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_Msk (0x1UL << MPU_PERR0_SPI0_TWI0_Pos) /*!< Bit mask of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI0_TWI0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 2 : UART0 region configuration. */
N#define MPU_PERR0_UART0_Pos (2UL) /*!< Position of UART0 field. */
N#define MPU_PERR0_UART0_Msk (0x1UL << MPU_PERR0_UART0_Pos) /*!< Bit mask of UART0 field. */
N#define MPU_PERR0_UART0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_UART0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 1 : RADIO region configuration. */
N#define MPU_PERR0_RADIO_Pos (1UL) /*!< Position of RADIO field. */
N#define MPU_PERR0_RADIO_Msk (0x1UL << MPU_PERR0_RADIO_Pos) /*!< Bit mask of RADIO field. */
N#define MPU_PERR0_RADIO_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RADIO_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 0 : POWER_CLOCK region configuration. */
N#define MPU_PERR0_POWER_CLOCK_Pos (0UL) /*!< Position of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_Msk (0x1UL << MPU_PERR0_POWER_CLOCK_Pos) /*!< Bit mask of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_POWER_CLOCK_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Register: MPU_PROTENSET0 */
N/* Description: Protection bit enable set register for low addresses. */
N
N/* Bit 31 : Protection enable for region 31. */
N#define MPU_PROTENSET0_PROTREG31_Pos (31UL) /*!< Position of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Msk (0x1UL << MPU_PROTENSET0_PROTREG31_Pos) /*!< Bit mask of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG31_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG31_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 30. */
N#define MPU_PROTENSET0_PROTREG30_Pos (30UL) /*!< Position of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Msk (0x1UL << MPU_PROTENSET0_PROTREG30_Pos) /*!< Bit mask of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG30_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG30_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 29. */
N#define MPU_PROTENSET0_PROTREG29_Pos (29UL) /*!< Position of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Msk (0x1UL << MPU_PROTENSET0_PROTREG29_Pos) /*!< Bit mask of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG29_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG29_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 28. */
N#define MPU_PROTENSET0_PROTREG28_Pos (28UL) /*!< Position of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Msk (0x1UL << MPU_PROTENSET0_PROTREG28_Pos) /*!< Bit mask of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG28_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG28_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 27. */
N#define MPU_PROTENSET0_PROTREG27_Pos (27UL) /*!< Position of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Msk (0x1UL << MPU_PROTENSET0_PROTREG27_Pos) /*!< Bit mask of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG27_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG27_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 26. */
N#define MPU_PROTENSET0_PROTREG26_Pos (26UL) /*!< Position of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Msk (0x1UL << MPU_PROTENSET0_PROTREG26_Pos) /*!< Bit mask of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG26_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG26_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 25. */
N#define MPU_PROTENSET0_PROTREG25_Pos (25UL) /*!< Position of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Msk (0x1UL << MPU_PROTENSET0_PROTREG25_Pos) /*!< Bit mask of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG25_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG25_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 24. */
N#define MPU_PROTENSET0_PROTREG24_Pos (24UL) /*!< Position of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Msk (0x1UL << MPU_PROTENSET0_PROTREG24_Pos) /*!< Bit mask of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG24_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG24_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 23. */
N#define MPU_PROTENSET0_PROTREG23_Pos (23UL) /*!< Position of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Msk (0x1UL << MPU_PROTENSET0_PROTREG23_Pos) /*!< Bit mask of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG23_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG23_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 22. */
N#define MPU_PROTENSET0_PROTREG22_Pos (22UL) /*!< Position of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Msk (0x1UL << MPU_PROTENSET0_PROTREG22_Pos) /*!< Bit mask of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG22_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG22_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 21. */
N#define MPU_PROTENSET0_PROTREG21_Pos (21UL) /*!< Position of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Msk (0x1UL << MPU_PROTENSET0_PROTREG21_Pos) /*!< Bit mask of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG21_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG21_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 20. */
N#define MPU_PROTENSET0_PROTREG20_Pos (20UL) /*!< Position of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Msk (0x1UL << MPU_PROTENSET0_PROTREG20_Pos) /*!< Bit mask of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG20_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG20_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 19. */
N#define MPU_PROTENSET0_PROTREG19_Pos (19UL) /*!< Position of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Msk (0x1UL << MPU_PROTENSET0_PROTREG19_Pos) /*!< Bit mask of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG19_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG19_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 18. */
N#define MPU_PROTENSET0_PROTREG18_Pos (18UL) /*!< Position of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Msk (0x1UL << MPU_PROTENSET0_PROTREG18_Pos) /*!< Bit mask of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG18_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG18_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 17. */
N#define MPU_PROTENSET0_PROTREG17_Pos (17UL) /*!< Position of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Msk (0x1UL << MPU_PROTENSET0_PROTREG17_Pos) /*!< Bit mask of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG17_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG17_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 16. */
N#define MPU_PROTENSET0_PROTREG16_Pos (16UL) /*!< Position of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Msk (0x1UL << MPU_PROTENSET0_PROTREG16_Pos) /*!< Bit mask of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG16_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG16_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 15. */
N#define MPU_PROTENSET0_PROTREG15_Pos (15UL) /*!< Position of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Msk (0x1UL << MPU_PROTENSET0_PROTREG15_Pos) /*!< Bit mask of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG15_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG15_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 14. */
N#define MPU_PROTENSET0_PROTREG14_Pos (14UL) /*!< Position of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Msk (0x1UL << MPU_PROTENSET0_PROTREG14_Pos) /*!< Bit mask of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG14_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG14_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 13. */
N#define MPU_PROTENSET0_PROTREG13_Pos (13UL) /*!< Position of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Msk (0x1UL << MPU_PROTENSET0_PROTREG13_Pos) /*!< Bit mask of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG13_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG13_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 12. */
N#define MPU_PROTENSET0_PROTREG12_Pos (12UL) /*!< Position of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Msk (0x1UL << MPU_PROTENSET0_PROTREG12_Pos) /*!< Bit mask of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG12_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG12_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 11. */
N#define MPU_PROTENSET0_PROTREG11_Pos (11UL) /*!< Position of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Msk (0x1UL << MPU_PROTENSET0_PROTREG11_Pos) /*!< Bit mask of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG11_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG11_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 10. */
N#define MPU_PROTENSET0_PROTREG10_Pos (10UL) /*!< Position of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Msk (0x1UL << MPU_PROTENSET0_PROTREG10_Pos) /*!< Bit mask of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG10_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG10_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 9. */
N#define MPU_PROTENSET0_PROTREG9_Pos (9UL) /*!< Position of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Msk (0x1UL << MPU_PROTENSET0_PROTREG9_Pos) /*!< Bit mask of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG9_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG9_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 8. */
N#define MPU_PROTENSET0_PROTREG8_Pos (8UL) /*!< Position of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Msk (0x1UL << MPU_PROTENSET0_PROTREG8_Pos) /*!< Bit mask of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG8_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG8_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 7. */
N#define MPU_PROTENSET0_PROTREG7_Pos (7UL) /*!< Position of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Msk (0x1UL << MPU_PROTENSET0_PROTREG7_Pos) /*!< Bit mask of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG7_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG7_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 6. */
N#define MPU_PROTENSET0_PROTREG6_Pos (6UL) /*!< Position of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Msk (0x1UL << MPU_PROTENSET0_PROTREG6_Pos) /*!< Bit mask of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG6_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG6_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 5. */
N#define MPU_PROTENSET0_PROTREG5_Pos (5UL) /*!< Position of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Msk (0x1UL << MPU_PROTENSET0_PROTREG5_Pos) /*!< Bit mask of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG5_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG5_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 4. */
N#define MPU_PROTENSET0_PROTREG4_Pos (4UL) /*!< Position of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Msk (0x1UL << MPU_PROTENSET0_PROTREG4_Pos) /*!< Bit mask of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG4_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG4_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 3. */
N#define MPU_PROTENSET0_PROTREG3_Pos (3UL) /*!< Position of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Msk (0x1UL << MPU_PROTENSET0_PROTREG3_Pos) /*!< Bit mask of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG3_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG3_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 2. */
N#define MPU_PROTENSET0_PROTREG2_Pos (2UL) /*!< Position of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Msk (0x1UL << MPU_PROTENSET0_PROTREG2_Pos) /*!< Bit mask of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG2_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG2_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 1. */
N#define MPU_PROTENSET0_PROTREG1_Pos (1UL) /*!< Position of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Msk (0x1UL << MPU_PROTENSET0_PROTREG1_Pos) /*!< Bit mask of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG1_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG1_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 0. */
N#define MPU_PROTENSET0_PROTREG0_Pos (0UL) /*!< Position of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Msk (0x1UL << MPU_PROTENSET0_PROTREG0_Pos) /*!< Bit mask of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG0_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG0_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_PROTENSET1 */
N/* Description: Protection bit enable set register for high addresses. */
N
N/* Bit 31 : Protection enable for region 63. */
N#define MPU_PROTENSET1_PROTREG63_Pos (31UL) /*!< Position of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Msk (0x1UL << MPU_PROTENSET1_PROTREG63_Pos) /*!< Bit mask of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG63_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG63_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 62. */
N#define MPU_PROTENSET1_PROTREG62_Pos (30UL) /*!< Position of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Msk (0x1UL << MPU_PROTENSET1_PROTREG62_Pos) /*!< Bit mask of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG62_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG62_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 61. */
N#define MPU_PROTENSET1_PROTREG61_Pos (29UL) /*!< Position of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Msk (0x1UL << MPU_PROTENSET1_PROTREG61_Pos) /*!< Bit mask of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG61_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG61_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 60. */
N#define MPU_PROTENSET1_PROTREG60_Pos (28UL) /*!< Position of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Msk (0x1UL << MPU_PROTENSET1_PROTREG60_Pos) /*!< Bit mask of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG60_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG60_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 59. */
N#define MPU_PROTENSET1_PROTREG59_Pos (27UL) /*!< Position of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Msk (0x1UL << MPU_PROTENSET1_PROTREG59_Pos) /*!< Bit mask of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG59_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG59_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 58. */
N#define MPU_PROTENSET1_PROTREG58_Pos (26UL) /*!< Position of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Msk (0x1UL << MPU_PROTENSET1_PROTREG58_Pos) /*!< Bit mask of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG58_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG58_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 57. */
N#define MPU_PROTENSET1_PROTREG57_Pos (25UL) /*!< Position of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Msk (0x1UL << MPU_PROTENSET1_PROTREG57_Pos) /*!< Bit mask of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG57_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG57_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 56. */
N#define MPU_PROTENSET1_PROTREG56_Pos (24UL) /*!< Position of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Msk (0x1UL << MPU_PROTENSET1_PROTREG56_Pos) /*!< Bit mask of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG56_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG56_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 55. */
N#define MPU_PROTENSET1_PROTREG55_Pos (23UL) /*!< Position of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Msk (0x1UL << MPU_PROTENSET1_PROTREG55_Pos) /*!< Bit mask of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG55_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG55_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 54. */
N#define MPU_PROTENSET1_PROTREG54_Pos (22UL) /*!< Position of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Msk (0x1UL << MPU_PROTENSET1_PROTREG54_Pos) /*!< Bit mask of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG54_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG54_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 53. */
N#define MPU_PROTENSET1_PROTREG53_Pos (21UL) /*!< Position of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Msk (0x1UL << MPU_PROTENSET1_PROTREG53_Pos) /*!< Bit mask of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG53_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG53_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 52. */
N#define MPU_PROTENSET1_PROTREG52_Pos (20UL) /*!< Position of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Msk (0x1UL << MPU_PROTENSET1_PROTREG52_Pos) /*!< Bit mask of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG52_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG52_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 51. */
N#define MPU_PROTENSET1_PROTREG51_Pos (19UL) /*!< Position of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Msk (0x1UL << MPU_PROTENSET1_PROTREG51_Pos) /*!< Bit mask of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG51_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG51_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 50. */
N#define MPU_PROTENSET1_PROTREG50_Pos (18UL) /*!< Position of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Msk (0x1UL << MPU_PROTENSET1_PROTREG50_Pos) /*!< Bit mask of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG50_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG50_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 49. */
N#define MPU_PROTENSET1_PROTREG49_Pos (17UL) /*!< Position of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Msk (0x1UL << MPU_PROTENSET1_PROTREG49_Pos) /*!< Bit mask of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG49_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG49_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 48. */
N#define MPU_PROTENSET1_PROTREG48_Pos (16UL) /*!< Position of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Msk (0x1UL << MPU_PROTENSET1_PROTREG48_Pos) /*!< Bit mask of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG48_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG48_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 47. */
N#define MPU_PROTENSET1_PROTREG47_Pos (15UL) /*!< Position of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Msk (0x1UL << MPU_PROTENSET1_PROTREG47_Pos) /*!< Bit mask of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG47_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG47_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 46. */
N#define MPU_PROTENSET1_PROTREG46_Pos (14UL) /*!< Position of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Msk (0x1UL << MPU_PROTENSET1_PROTREG46_Pos) /*!< Bit mask of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG46_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG46_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 45. */
N#define MPU_PROTENSET1_PROTREG45_Pos (13UL) /*!< Position of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Msk (0x1UL << MPU_PROTENSET1_PROTREG45_Pos) /*!< Bit mask of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG45_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG45_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 44. */
N#define MPU_PROTENSET1_PROTREG44_Pos (12UL) /*!< Position of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Msk (0x1UL << MPU_PROTENSET1_PROTREG44_Pos) /*!< Bit mask of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG44_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG44_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 43. */
N#define MPU_PROTENSET1_PROTREG43_Pos (11UL) /*!< Position of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Msk (0x1UL << MPU_PROTENSET1_PROTREG43_Pos) /*!< Bit mask of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG43_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG43_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 42. */
N#define MPU_PROTENSET1_PROTREG42_Pos (10UL) /*!< Position of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Msk (0x1UL << MPU_PROTENSET1_PROTREG42_Pos) /*!< Bit mask of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG42_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG42_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 41. */
N#define MPU_PROTENSET1_PROTREG41_Pos (9UL) /*!< Position of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Msk (0x1UL << MPU_PROTENSET1_PROTREG41_Pos) /*!< Bit mask of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG41_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG41_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 40. */
N#define MPU_PROTENSET1_PROTREG40_Pos (8UL) /*!< Position of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Msk (0x1UL << MPU_PROTENSET1_PROTREG40_Pos) /*!< Bit mask of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG40_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG40_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 39. */
N#define MPU_PROTENSET1_PROTREG39_Pos (7UL) /*!< Position of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Msk (0x1UL << MPU_PROTENSET1_PROTREG39_Pos) /*!< Bit mask of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG39_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG39_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 38. */
N#define MPU_PROTENSET1_PROTREG38_Pos (6UL) /*!< Position of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Msk (0x1UL << MPU_PROTENSET1_PROTREG38_Pos) /*!< Bit mask of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG38_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG38_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 37. */
N#define MPU_PROTENSET1_PROTREG37_Pos (5UL) /*!< Position of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Msk (0x1UL << MPU_PROTENSET1_PROTREG37_Pos) /*!< Bit mask of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG37_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG37_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 36. */
N#define MPU_PROTENSET1_PROTREG36_Pos (4UL) /*!< Position of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Msk (0x1UL << MPU_PROTENSET1_PROTREG36_Pos) /*!< Bit mask of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG36_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG36_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 35. */
N#define MPU_PROTENSET1_PROTREG35_Pos (3UL) /*!< Position of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Msk (0x1UL << MPU_PROTENSET1_PROTREG35_Pos) /*!< Bit mask of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG35_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG35_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 34. */
N#define MPU_PROTENSET1_PROTREG34_Pos (2UL) /*!< Position of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Msk (0x1UL << MPU_PROTENSET1_PROTREG34_Pos) /*!< Bit mask of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG34_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG34_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 33. */
N#define MPU_PROTENSET1_PROTREG33_Pos (1UL) /*!< Position of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Msk (0x1UL << MPU_PROTENSET1_PROTREG33_Pos) /*!< Bit mask of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG33_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG33_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 32. */
N#define MPU_PROTENSET1_PROTREG32_Pos (0UL) /*!< Position of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Msk (0x1UL << MPU_PROTENSET1_PROTREG32_Pos) /*!< Bit mask of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG32_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG32_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_DISABLEINDEBUG */
N/* Description: Disable protection mechanism in debug mode. */
N
N/* Bit 0 : Disable protection mechanism in debug mode. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Protection enabled. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Protection disabled. */
N
N
N/* Peripheral: NVMC */
N/* Description: Non Volatile Memory Controller. */
N
N/* Register: NVMC_READY */
N/* Description: Ready flag. */
N
N/* Bit 0 : NVMC ready. */
N#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
N#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
N#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation). */
N#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready. */
N
N/* Register: NVMC_CONFIG */
N/* Description: Configuration register. */
N
N/* Bits 1..0 : Program write enable. */
N#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
N#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
N#define NVMC_CONFIG_WEN_Ren (0x00UL) /*!< Read only access. */
N#define NVMC_CONFIG_WEN_Wen (0x01UL) /*!< Write enabled. */
N#define NVMC_CONFIG_WEN_Een (0x02UL) /*!< Erase enabled. */
N
N/* Register: NVMC_ERASEALL */
N/* Description: Register for erasing all non-volatile user memory. */
N
N/* Bit 0 : Starts the erasing of all user NVM (code region 0/1 and UICR registers). */
N#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase. */
N
N/* Register: NVMC_ERASEUICR */
N/* Description: Register for start erasing User Information Congfiguration Registers. */
N
N/* Bit 0 : It can only be used when all contents of code region 1 are erased. */
N#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start UICR erase. */
N
N
N/* Peripheral: POWER */
N/* Description: Power Control. */
N
N/* Register: POWER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on POFWARN event. */
N#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: POWER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on POFWARN event. */
N#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: POWER_RESETREAS */
N/* Description: Reset reason. */
N
N/* Bit 18 : Reset from wake-up from OFF mode detected by entering into debug interface mode. */
N#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
N#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
N
N/* Bit 17 : Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP. */
N#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N
N/* Bit 16 : Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO. */
N#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
N#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
N
N/* Bit 3 : Reset from CPU lock-up detected. */
N#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
N
N/* Bit 2 : Reset from AIRCR.SYSRESETREQ detected. */
N#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
N#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
N
N/* Bit 1 : Reset from watchdog detected. */
N#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
N#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
N
N/* Bit 0 : Reset from pin-reset detected. */
N#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
N
N/* Register: POWER_SYSTEMOFF */
N/* Description: System off register. */
N
N/* Bit 0 : Enter system off mode. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enter system off mode. */
N
N/* Register: POWER_POFCON */
N/* Description: Power failure configuration. */
N
N/* Bits 2..1 : Set threshold level. */
N#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_Msk (0x3UL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_V21 (0x00UL) /*!< Set threshold to 2.1Volts. */
N#define POWER_POFCON_THRESHOLD_V23 (0x01UL) /*!< Set threshold to 2.3Volts. */
N#define POWER_POFCON_THRESHOLD_V25 (0x02UL) /*!< Set threshold to 2.5Volts. */
N#define POWER_POFCON_THRESHOLD_V27 (0x03UL) /*!< Set threshold to 2.7Volts. */
N
N/* Bit 0 : Power failure comparator enable. */
N#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
N#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
N#define POWER_POFCON_POF_Disabled (0UL) /*!< Disabled. */
N#define POWER_POFCON_POF_Enabled (1UL) /*!< Enabled. */
N
N/* Register: POWER_GPREGRET */
N/* Description: General purpose retention register. This register is a retained register. */
N
N/* Bits 7..0 : General purpose retention register. */
N#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_RAMON */
N/* Description: Ram on/off. */
N
N/* Bit 19 : RAM block 3 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM3_Pos (19UL) /*!< Position of OFFRAM3 field. */
N#define POWER_RAMON_OFFRAM3_Msk (0x1UL << POWER_RAMON_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
N#define POWER_RAMON_OFFRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM3_RAM3On (1UL) /*!< RAM block 3 ON in OFF mode. */
N
N/* Bit 18 : RAM block 2 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM2_Pos (18UL) /*!< Position of OFFRAM2 field. */
N#define POWER_RAMON_OFFRAM2_Msk (0x1UL << POWER_RAMON_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
N#define POWER_RAMON_OFFRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM2_RAM2On (1UL) /*!< RAM block 2 ON in OFF mode. */
N
N/* Bit 17 : RAM block 1 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< RAM block 1 ON in OFF mode. */
N
N/* Bit 16 : RAM block 0 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< RAM block 0 ON in OFF mode. */
N
N/* Bit 3 : RAM block 3 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM3_Pos (3UL) /*!< Position of ONRAM3 field. */
N#define POWER_RAMON_ONRAM3_Msk (0x1UL << POWER_RAMON_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
N#define POWER_RAMON_ONRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in ON mode. */
N#define POWER_RAMON_ONRAM3_RAM3On (1UL) /*!< RAM block 3 ON in ON mode. */
N
N/* Bit 2 : RAM block 2 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM2_Pos (2UL) /*!< Position of ONRAM2 field. */
N#define POWER_RAMON_ONRAM2_Msk (0x1UL << POWER_RAMON_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
N#define POWER_RAMON_ONRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in ON mode. */
N#define POWER_RAMON_ONRAM2_RAM2On (1UL) /*!< RAM block 2 ON in ON mode. */
N
N/* Bit 1 : RAM block 1 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in ON mode. */
N#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< RAM block 1 ON in ON mode. */
N
N/* Bit 0 : RAM block 0 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in ON mode. */
N#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< RAM block 0 ON in ON mode. */
N
N/* Register: POWER_RESET */
N/* Description: Pin reset functionality configuration register. This register is a retained register. */
N
N/* Bit 0 : Enable pin reset in debug interface mode. */
N#define POWER_RESET_RESET_Pos (0UL) /*!< Position of RESET field. */
N#define POWER_RESET_RESET_Msk (0x1UL << POWER_RESET_RESET_Pos) /*!< Bit mask of RESET field. */
N#define POWER_RESET_RESET_Disabled (0UL) /*!< Pin reset in debug interface mode disabled. */
N#define POWER_RESET_RESET_Enabled (1UL) /*!< Pin reset in debug interface mode enabled. */
N
N/* Register: POWER_DCDCEN */
N/* Description: DCDC converter enable configuration register. */
N
N/* Bit 0 : Enable DCDC converter. */
N#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< DCDC converter disabled. */
N#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< DCDC converter enabled. */
N
N
N/* Peripheral: PPI */
N/* Description: PPI controller. */
N
N/* Register: PPI_CHEN */
N/* Description: Channel enable. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHEN_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH31_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHEN_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH30_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHEN_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH29_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHEN_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH28_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHEN_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH27_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHEN_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH26_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHEN_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH25_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHEN_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH24_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHEN_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH23_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHEN_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH22_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHEN_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH21_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHEN_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH20_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHEN_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH15_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHEN_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH14_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHEN_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH13_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHEN_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH12_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHEN_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH11_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHEN_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH10_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHEN_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH9_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHEN_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH8_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHEN_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH7_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHEN_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH6_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHEN_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH5_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHEN_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH4_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHEN_CH3_Disabled (0UL) /*!< Channel disabled */
N#define PPI_CHEN_CH3_Enabled (1UL) /*!< Channel enabled */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHEN_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH2_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHEN_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH1_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHEN_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH0_Enabled (1UL) /*!< Channel enabled. */
N
N/* Register: PPI_CHENSET */
N/* Description: Channel enable set. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH31_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH30_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH29_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH28_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH27_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH26_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH25_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH24_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH23_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH22_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH21_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH20_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH15_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH14_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH13_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH12_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH11_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH10_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH9_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH8_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH7_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH6_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH5_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH4_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH3_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH2_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH1_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH0_Set (1UL) /*!< Enable channel on write. */
N
N/* Register: PPI_CHENCLR */
N/* Description: Channel enable clear. */
N
N/* Bit 31 : Disable PPI channel 31. */
N#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 30 : Disable PPI channel 30. */
N#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 29 : Disable PPI channel 29. */
N#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 28 : Disable PPI channel 28. */
N#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 27 : Disable PPI channel 27. */
N#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 26 : Disable PPI channel 26. */
N#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 25 : Disable PPI channel 25. */
N#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 24 : Disable PPI channel 24. */
N#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 23 : Disable PPI channel 23. */
N#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 22 : Disable PPI channel 22. */
N#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 21 : Disable PPI channel 21. */
N#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 20 : Disable PPI channel 20. */
N#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 15 : Disable PPI channel 15. */
N#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 14 : Disable PPI channel 14. */
N#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 13 : Disable PPI channel 13. */
N#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 12 : Disable PPI channel 12. */
N#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 11 : Disable PPI channel 11. */
N#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 10 : Disable PPI channel 10. */
N#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 9 : Disable PPI channel 9. */
N#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 8 : Disable PPI channel 8. */
N#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 7 : Disable PPI channel 7. */
N#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 6 : Disable PPI channel 6. */
N#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 5 : Disable PPI channel 5. */
N#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 4 : Disable PPI channel 4. */
N#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 3 : Disable PPI channel 3. */
N#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 2 : Disable PPI channel 2. */
N#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 1 : Disable PPI channel 1. */
N#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 0 : Disable PPI channel 0. */
N#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Disable channel on write. */
N
N/* Register: PPI_CHG */
N/* Description: Channel group configuration. */
N
N/* Bit 31 : Include CH31 in channel group. */
N#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHG_CH31_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH31_Included (1UL) /*!< Channel included. */
N
N/* Bit 30 : Include CH30 in channel group. */
N#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHG_CH30_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH30_Included (1UL) /*!< Channel included. */
N
N/* Bit 29 : Include CH29 in channel group. */
N#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHG_CH29_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH29_Included (1UL) /*!< Channel included. */
N
N/* Bit 28 : Include CH28 in channel group. */
N#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHG_CH28_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH28_Included (1UL) /*!< Channel included. */
N
N/* Bit 27 : Include CH27 in channel group. */
N#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHG_CH27_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH27_Included (1UL) /*!< Channel included. */
N
N/* Bit 26 : Include CH26 in channel group. */
N#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHG_CH26_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH26_Included (1UL) /*!< Channel included. */
N
N/* Bit 25 : Include CH25 in channel group. */
N#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHG_CH25_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH25_Included (1UL) /*!< Channel included. */
N
N/* Bit 24 : Include CH24 in channel group. */
N#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHG_CH24_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH24_Included (1UL) /*!< Channel included. */
N
N/* Bit 23 : Include CH23 in channel group. */
N#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHG_CH23_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH23_Included (1UL) /*!< Channel included. */
N
N/* Bit 22 : Include CH22 in channel group. */
N#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHG_CH22_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH22_Included (1UL) /*!< Channel included. */
N
N/* Bit 21 : Include CH21 in channel group. */
N#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHG_CH21_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH21_Included (1UL) /*!< Channel included. */
N
N/* Bit 20 : Include CH20 in channel group. */
N#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHG_CH20_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH20_Included (1UL) /*!< Channel included. */
N
N/* Bit 15 : Include CH15 in channel group. */
N#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHG_CH15_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH15_Included (1UL) /*!< Channel included. */
N
N/* Bit 14 : Include CH14 in channel group. */
N#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHG_CH14_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH14_Included (1UL) /*!< Channel included. */
N
N/* Bit 13 : Include CH13 in channel group. */
N#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHG_CH13_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH13_Included (1UL) /*!< Channel included. */
N
N/* Bit 12 : Include CH12 in channel group. */
N#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHG_CH12_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH12_Included (1UL) /*!< Channel included. */
N
N/* Bit 11 : Include CH11 in channel group. */
N#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHG_CH11_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH11_Included (1UL) /*!< Channel included. */
N
N/* Bit 10 : Include CH10 in channel group. */
N#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHG_CH10_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH10_Included (1UL) /*!< Channel included. */
N
N/* Bit 9 : Include CH9 in channel group. */
N#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHG_CH9_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH9_Included (1UL) /*!< Channel included. */
N
N/* Bit 8 : Include CH8 in channel group. */
N#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHG_CH8_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH8_Included (1UL) /*!< Channel included. */
N
N/* Bit 7 : Include CH7 in channel group. */
N#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHG_CH7_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH7_Included (1UL) /*!< Channel included. */
N
N/* Bit 6 : Include CH6 in channel group. */
N#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHG_CH6_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH6_Included (1UL) /*!< Channel included. */
N
N/* Bit 5 : Include CH5 in channel group. */
N#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHG_CH5_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH5_Included (1UL) /*!< Channel included. */
N
N/* Bit 4 : Include CH4 in channel group. */
N#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHG_CH4_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH4_Included (1UL) /*!< Channel included. */
N
N/* Bit 3 : Include CH3 in channel group. */
N#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHG_CH3_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH3_Included (1UL) /*!< Channel included. */
N
N/* Bit 2 : Include CH2 in channel group. */
N#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHG_CH2_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH2_Included (1UL) /*!< Channel included. */
N
N/* Bit 1 : Include CH1 in channel group. */
N#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHG_CH1_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH1_Included (1UL) /*!< Channel included. */
N
N/* Bit 0 : Include CH0 in channel group. */
N#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHG_CH0_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH0_Included (1UL) /*!< Channel included. */
N
N
N/* Peripheral: PU */
N/* Description: Patch unit. */
N
N/* Register: PU_PATCHADDR */
N/* Description: Relative address of patch instructions. */
N
N/* Bits 24..0 : Relative address of patch instructions. */
N#define PU_PATCHADDR_PATCHADDR_Pos (0UL) /*!< Position of PATCHADDR field. */
N#define PU_PATCHADDR_PATCHADDR_Msk (0x1FFFFFFUL << PU_PATCHADDR_PATCHADDR_Pos) /*!< Bit mask of PATCHADDR field. */
N
N/* Register: PU_PATCHEN */
N/* Description: Patch enable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHEN_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHEN_PATCH7_Msk (0x1UL << PU_PATCHEN_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHEN_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHEN_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHEN_PATCH6_Msk (0x1UL << PU_PATCHEN_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHEN_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHEN_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHEN_PATCH5_Msk (0x1UL << PU_PATCHEN_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHEN_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHEN_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHEN_PATCH4_Msk (0x1UL << PU_PATCHEN_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHEN_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHEN_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHEN_PATCH3_Msk (0x1UL << PU_PATCHEN_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHEN_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHEN_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHEN_PATCH2_Msk (0x1UL << PU_PATCHEN_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHEN_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHEN_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHEN_PATCH1_Msk (0x1UL << PU_PATCHEN_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHEN_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHEN_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHEN_PATCH0_Msk (0x1UL << PU_PATCHEN_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHEN_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N
N/* Register: PU_PATCHENSET */
N/* Description: Patch enable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHENSET_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHENSET_PATCH7_Msk (0x1UL << PU_PATCHENSET_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHENSET_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH7_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHENSET_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHENSET_PATCH6_Msk (0x1UL << PU_PATCHENSET_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHENSET_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH6_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHENSET_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHENSET_PATCH5_Msk (0x1UL << PU_PATCHENSET_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHENSET_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH5_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHENSET_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHENSET_PATCH4_Msk (0x1UL << PU_PATCHENSET_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHENSET_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH4_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHENSET_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHENSET_PATCH3_Msk (0x1UL << PU_PATCHENSET_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHENSET_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH3_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHENSET_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHENSET_PATCH2_Msk (0x1UL << PU_PATCHENSET_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHENSET_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH2_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHENSET_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHENSET_PATCH1_Msk (0x1UL << PU_PATCHENSET_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHENSET_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH1_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHENSET_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHENSET_PATCH0_Msk (0x1UL << PU_PATCHENSET_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHENSET_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH0_Set (1UL) /*!< Enable patch on write. */
N
N/* Register: PU_PATCHENCLR */
N/* Description: Patch disable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHENCLR_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHENCLR_PATCH7_Msk (0x1UL << PU_PATCHENCLR_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHENCLR_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH7_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHENCLR_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHENCLR_PATCH6_Msk (0x1UL << PU_PATCHENCLR_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHENCLR_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH6_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHENCLR_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHENCLR_PATCH5_Msk (0x1UL << PU_PATCHENCLR_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHENCLR_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH5_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHENCLR_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHENCLR_PATCH4_Msk (0x1UL << PU_PATCHENCLR_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHENCLR_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH4_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHENCLR_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHENCLR_PATCH3_Msk (0x1UL << PU_PATCHENCLR_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHENCLR_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH3_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHENCLR_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHENCLR_PATCH2_Msk (0x1UL << PU_PATCHENCLR_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHENCLR_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH2_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHENCLR_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHENCLR_PATCH1_Msk (0x1UL << PU_PATCHENCLR_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHENCLR_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH1_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHENCLR_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHENCLR_PATCH0_Msk (0x1UL << PU_PATCHENCLR_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHENCLR_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH0_Clear (1UL) /*!< Disable patch on write. */
N
N
N/* Peripheral: QDEC */
N/* Description: Rotary decoder. */
N
N/* Register: QDEC_SHORTS */
N/* Description: Shortcut for the QDEC. */
N
N/* Bit 1 : Short-cut between SAMPLERDY event and STOP task. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between REPORTRDY event and READCLRACC task. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: QDEC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ACCOF event. */
N#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on REPORTRDY event. */
N#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on SAMPLERDY event. */
N#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: QDEC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ACCOF event. */
N#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on REPORTRDY event. */
N#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on SAMPLERDY event. */
N#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: QDEC_ENABLE */
N/* Description: Enable the QDEC. */
N
N/* Bit 0 : Enable or disable QDEC. */
N#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled QDEC. */
N#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable QDEC. */
N
N/* Register: QDEC_LEDPOL */
N/* Description: LED output pin polarity. */
N
N/* Bit 0 : LED output pin polarity. */
N#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< LED output is active low. */
N#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< LED output is active high. */
N
N/* Register: QDEC_SAMPLEPER */
N/* Description: Sample period. */
N
N/* Bits 2..0 : Sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0x7UL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_128us (0x00UL) /*!< 128us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_256us (0x01UL) /*!< 256us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_512us (0x02UL) /*!< 512us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_1024us (0x03UL) /*!< 1024us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_2048us (0x04UL) /*!< 2048us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_4096us (0x05UL) /*!< 4096us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_8192us (0x06UL) /*!< 8192us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_16384us (0x07UL) /*!< 16384us sample period. */
N
N/* Register: QDEC_SAMPLE */
N/* Description: Motion sample value. */
N
N/* Bits 31..0 : Last sample taken in compliment to 2. */
N#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
N#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
N
N/* Register: QDEC_REPORTPER */
N/* Description: Number of samples to generate an EVENT_REPORTRDY. */
N
N/* Bits 2..0 : Number of samples to generate an EVENT_REPORTRDY. */
N#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_Msk (0x7UL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_10Smpl (0x00UL) /*!< 10 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_40Smpl (0x01UL) /*!< 40 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_80Smpl (0x02UL) /*!< 80 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_120Smpl (0x03UL) /*!< 120 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_160Smpl (0x04UL) /*!< 160 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_200Smpl (0x05UL) /*!< 200 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_240Smpl (0x06UL) /*!< 240 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_280Smpl (0x07UL) /*!< 280 samples per report. */
N
N/* Register: QDEC_DBFEN */
N/* Description: Enable debouncer input filters. */
N
N/* Bit 0 : Enable debounce input filters. */
N#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled. */
N#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled. */
N
N/* Register: QDEC_LEDPRE */
N/* Description: Time LED is switched ON before the sample. */
N
N/* Bits 7..0 : Period in us the LED in switched on prior to sampling. */
N#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
N#define QDEC_LEDPRE_LEDPRE_Msk (0xFFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
N
N/* Register: QDEC_ACCDBL */
N/* Description: Accumulated double (error) transitions register. */
N
N/* Bits 3..0 : Accumulated double (error) transitions. */
N#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
N#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
N
N/* Register: QDEC_ACCDBLREAD */
N/* Description: Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task. */
N
N/* Bits 3..0 : Snapshot of accumulated double (error) transitions. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
N
N/* Register: QDEC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define QDEC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define QDEC_POWER_POWER_Msk (0x1UL << QDEC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define QDEC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define QDEC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RADIO */
N/* Description: The radio. */
N
N/* Register: RADIO_SHORTS */
N/* Description: Shortcut for the radio. */
N
N/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 6 : Shortcut between ADDRESS event and BCSTART task. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 5 : Shortcut between END event and START task. */
N#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
N#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between DISABLED event and RXEN task. */
N#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DISABLED event and TXEN task.  */
N#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between END event and DISABLE task. */
N#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and START task. */
N#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
N#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
N#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RADIO_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on BCMATCH event. */
N#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on RSSIEND event. */
N#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 6 : Enable interrupt on DEVMISS event. */
N#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 5 : Enable interrupt on DEVMATCH event. */
N#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : Enable interrupt on DISABLED event. */
N#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on END event. */
N#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on PAYLOAD event. */
N#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ADDRESS event. */
N#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RADIO_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on BCMATCH event. */
N#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on RSSIEND event. */
N#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 6 : Disable interrupt on DEVMISS event. */
N#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 5 : Disable interrupt on DEVMATCH event. */
N#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on DISABLED event. */
N#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on END event. */
N#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on PAYLOAD event. */
N#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ADDRESS event. */
N#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RADIO_CRCSTATUS */
N/* Description: CRC status of received packet. */
N
N/* Bit 0 : CRC status of received packet. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok. */
N
N/* Register: RADIO_RXMATCH */
N/* Description: Received address. */
N
N/* Bits 2..0 : Logical address in which previous packet was received. */
N#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
N#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
N
N/* Register: RADIO_RXCRC */
N/* Description: Received CRC. */
N
N/* Bits 23..0 : CRC field of previously received packet. */
N#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
N#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
N
N/* Register: RADIO_DAI */
N/* Description: Device address match index. */
N
N/* Bits 2..0 : Index (n) of device address (see DAB[n] and DAP[n]) that got an address match. */
N#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
N#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
N
N/* Register: RADIO_FREQUENCY */
N/* Description: Frequency. */
N
N/* Bits 6..0 : Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.  */
N#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N
N/* Register: RADIO_TXPOWER */
N/* Description: Output power. */
N
N/* Bits 7..0 : Radio output power. Decision point: TXEN task. */
N#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4dBm. */
N#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< -30dBm. */
N
N/* Register: RADIO_MODE */
N/* Description: Data rate and modulation. */
N
N/* Bits 1..0 : Radio data rate and modulation setting. Decision point: TXEN or RXEN task. */
N#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define RADIO_MODE_MODE_Msk (0x3UL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define RADIO_MODE_MODE_Nrf_1Mbit (0x00UL) /*!< 1Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_2Mbit (0x01UL) /*!< 2Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_250Kbit (0x02UL) /*!< 250kbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Ble_1Mbit (0x03UL) /*!< 1Mbit/s Bluetooth Low Energy */
N
N/* Register: RADIO_PCNF0 */
N/* Description: Packet configuration 0. */
N
N/* Bits 19..16 : Length of S1 field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
N#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
N
N/* Bit 8 : Length of S0 field in number of bytes. Decision point: START task. */
N#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
N#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
N
N/* Bits 3..0 : Length of length field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
N#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
N
N/* Register: RADIO_PCNF1 */
N/* Description: Packet configuration 1. */
N
N/* Bit 25 : Packet whitening enable. */
N#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Whitening disabled. */
N#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Whitening enabled. */
N
N/* Bit 24 : On air endianness of packet length field. Decision point: START task. */
N#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
N#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
N
N/* Bits 18..16 : Base address length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
N#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
N
N/* Bits 15..8 : Static length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
N#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
N
N/* Bits 7..0 : Maximum length of packet payload in number of bytes. */
N#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: RADIO_PREFIX0 */
N/* Description: Prefixes bytes for logical addresses 0 to 3. */
N
N/* Bits 31..24 : Address prefix 3. Decision point: START task. */
N#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
N#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
N
N/* Bits 23..16 : Address prefix 2. Decision point: START task. */
N#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
N#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
N
N/* Bits 15..8 : Address prefix 1. Decision point: START task. */
N#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
N#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
N
N/* Bits 7..0 : Address prefix 0. Decision point: START task. */
N#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
N#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
N
N/* Register: RADIO_PREFIX1 */
N/* Description: Prefixes bytes for logical addresses 4 to 7. */
N
N/* Bits 31..24 : Address prefix 7. Decision point: START task. */
N#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
N#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
N
N/* Bits 23..16 : Address prefix 6. Decision point: START task. */
N#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
N#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
N
N/* Bits 15..8 : Address prefix 5. Decision point: START task. */
N#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
N#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
N
N/* Bits 7..0 : Address prefix 4. Decision point: START task. */
N#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
N#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
N
N/* Register: RADIO_TXADDRESS */
N/* Description: Transmit address select. */
N
N/* Bits 2..0 : Logical address to be used when transmitting a packet. Decision point: START task. */
N#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
N#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
N
N/* Register: RADIO_RXADDRESSES */
N/* Description: Receive address select. */
N
N/* Bit 7 : Enable reception on logical address 7. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 6 : Enable reception on logical address 6. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 5 : Enable reception on logical address 5. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 4 : Enable reception on logical address 4. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 3 : Enable reception on logical address 3. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 2 : Enable reception on logical address 2. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 1 : Enable reception on logical address 1. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 0 : Enable reception on logical address 0. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Reception enabled. */
N
N/* Register: RADIO_CRCCNF */
N/* Description: CRC configuration. */
N
N/* Bit 8 : Leave packet address field out of the CRC calculation. Decision point: START task. */
N#define RADIO_CRCCNF_SKIP_ADDR_Pos (8UL) /*!< Position of SKIP_ADDR field. */
N#define RADIO_CRCCNF_SKIP_ADDR_Msk (0x1UL << RADIO_CRCCNF_SKIP_ADDR_Pos) /*!< Bit mask of SKIP_ADDR field. */
N#define RADIO_CRCCNF_SKIP_ADDR_Include (0UL) /*!< Include packet address in CRC calculation. */
N#define RADIO_CRCCNF_SKIP_ADDR_Skip (1UL) /*!< Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address. */
N
N/* Bits 1..0 : CRC length. Decision point: START task. */
N#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
N#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
N#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC calculation disabled. */
N#define RADIO_CRCCNF_LEN_One (1UL) /*!< One byte long CRC. */
N#define RADIO_CRCCNF_LEN_Two (2UL) /*!< Two bytes long CRC. */
N#define RADIO_CRCCNF_LEN_Three (3UL) /*!< Three bytes long CRC. */
N
N/* Register: RADIO_CRCPOLY */
N/* Description: CRC polynomial. */
N
N/* Bits 23..1 : CRC polynomial. Decision point: START task. */
N#define RADIO_CRCPOLY_CRCPOLY_Pos (1UL) /*!< Position of CRCPOLY field. */
N#define RADIO_CRCPOLY_CRCPOLY_Msk (0x7FFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
N
N/* Register: RADIO_CRCINIT */
N/* Description: CRC initial value. */
N
N/* Bits 23..0 : Initial value for CRC calculation. Decision point: START task. */
N#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
N#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
N
N/* Register: RADIO_TEST */
N/* Description: Test features enable register. */
N
N/* Bit 1 : PLL lock. Decision point: TXEN or RXEN task. */
N#define RADIO_TEST_PLL_LOCK_Pos (1UL) /*!< Position of PLL_LOCK field. */
N#define RADIO_TEST_PLL_LOCK_Msk (0x1UL << RADIO_TEST_PLL_LOCK_Pos) /*!< Bit mask of PLL_LOCK field. */
N#define RADIO_TEST_PLL_LOCK_Disabled (0UL) /*!< PLL lock disabled. */
N#define RADIO_TEST_PLL_LOCK_Enabled (1UL) /*!< PLL lock enabled. */
N
N/* Bit 0 : Constant carrier. Decision point: TXEN task. */
N#define RADIO_TEST_CONST_CARRIER_Pos (0UL) /*!< Position of CONST_CARRIER field. */
N#define RADIO_TEST_CONST_CARRIER_Msk (0x1UL << RADIO_TEST_CONST_CARRIER_Pos) /*!< Bit mask of CONST_CARRIER field. */
N#define RADIO_TEST_CONST_CARRIER_Disabled (0UL) /*!< Constant carrier disabled. */
N#define RADIO_TEST_CONST_CARRIER_Enabled (1UL) /*!< Constant carrier enabled. */
N
N/* Register: RADIO_TIFS */
N/* Description: Inter Frame Spacing in microseconds. */
N
N/* Bits 7..0 : Inter frame spacing in microseconds. Decision point: START rask */
N#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
N#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
N
N/* Register: RADIO_RSSISAMPLE */
N/* Description: RSSI sample. */
N
N/* Bits 6..0 : RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
N
N/* Register: RADIO_STATE */
N/* Description: Current radio state. */
N
N/* Bits 3..0 : Current radio state. */
N#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
N#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
N#define RADIO_STATE_STATE_Disabled (0x00UL) /*!< Radio is in the Disabled state. */
N#define RADIO_STATE_STATE_RxRu (0x01UL) /*!< Radio is in the Rx Ramp Up state. */
N#define RADIO_STATE_STATE_RxIdle (0x02UL) /*!< Radio is in the Rx Idle state. */
N#define RADIO_STATE_STATE_Rx (0x03UL) /*!< Radio is in the Rx state. */
N#define RADIO_STATE_STATE_RxDisable (0x04UL) /*!< Radio is in the Rx Disable state. */
N#define RADIO_STATE_STATE_TxRu (0x09UL) /*!< Radio is in the Tx Ramp Up state. */
N#define RADIO_STATE_STATE_TxIdle (0x0AUL) /*!< Radio is in the Tx Idle state. */
N#define RADIO_STATE_STATE_Tx (0x0BUL) /*!< Radio is in the Tx state. */
N#define RADIO_STATE_STATE_TxDisable (0x0CUL) /*!< Radio is in the Tx Disable state. */
N
N/* Register: RADIO_DATAWHITEIV */
N/* Description: Data whitening initial value. */
N
N/* Bits 5..0 : Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x3FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
N
N/* Register: RADIO_DAP */
N/* Description: Device address prefix. */
N
N/* Bits 15..0 : Device address prefix. */
N#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
N#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
N
N/* Register: RADIO_DACNF */
N/* Description: Device address match configuration. */
N
N/* Bit 15 : TxAdd for device address 7. */
N#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
N#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
N
N/* Bit 14 : TxAdd for device address 6. */
N#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
N#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
N
N/* Bit 13 : TxAdd for device address 5. */
N#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
N#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
N
N/* Bit 12 : TxAdd for device address 4. */
N#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
N#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
N
N/* Bit 11 : TxAdd for device address 3. */
N#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
N#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
N
N/* Bit 10 : TxAdd for device address 2. */
N#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
N#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
N
N/* Bit 9 : TxAdd for device address 1. */
N#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
N#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
N
N/* Bit 8 : TxAdd for device address 0. */
N#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
N#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
N
N/* Bit 7 : Enable or disable device address matching using device address 7. */
N#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
N#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
N#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 6 : Enable or disable device address matching using device address 6. */
N#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
N#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
N#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 5 : Enable or disable device address matching using device address 5. */
N#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
N#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
N#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 4 : Enable or disable device address matching using device address 4. */
N#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
N#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
N#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 3 : Enable or disable device address matching using device address 3. */
N#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
N#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
N#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 2 : Enable or disable device address matching using device address 2. */
N#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
N#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
N#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 1 : Enable or disable device address matching using device address 1. */
N#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
N#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
N#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 0 : Enable or disable device address matching using device address 0. */
N#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
N#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
N#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled. */
N
N/* Register: RADIO_OVERRIDE0 */
N/* Description: Trim value override register 0. */
N
N/* Bits 31..0 : Trim value override register 0. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Pos (0UL) /*!< Position of OVERRIDE0 field. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE0_OVERRIDE0_Pos) /*!< Bit mask of OVERRIDE0 field. */
N
N/* Register: RADIO_OVERRIDE1 */
N/* Description: Trim value override register 1. */
N
N/* Bits 31..0 : Trim value override register 1. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Pos (0UL) /*!< Position of OVERRIDE1 field. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE1_OVERRIDE1_Pos) /*!< Bit mask of OVERRIDE1 field. */
N
N/* Register: RADIO_OVERRIDE2 */
N/* Description: Trim value override register 2. */
N
N/* Bits 31..0 : Trim value override register 2. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Pos (0UL) /*!< Position of OVERRIDE2 field. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE2_OVERRIDE2_Pos) /*!< Bit mask of OVERRIDE2 field. */
N
N/* Register: RADIO_OVERRIDE3 */
N/* Description: Trim value override register 3. */
N
N/* Bits 31..0 : Trim value override register 3. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Pos (0UL) /*!< Position of OVERRIDE3 field. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE3_OVERRIDE3_Pos) /*!< Bit mask of OVERRIDE3 field. */
N
N/* Register: RADIO_OVERRIDE4 */
N/* Description: Trim value override register 4. */
N
N/* Bit 31 : Enable or disable override of default trim values. */
N#define RADIO_OVERRIDE4_ENABLE_Pos (31UL) /*!< Position of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Msk (0x1UL << RADIO_OVERRIDE4_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Disabled (0UL) /*!< Override trim values disabled. */
N#define RADIO_OVERRIDE4_ENABLE_Enabled (1UL) /*!< Override trim values enabled. */
N
N/* Bits 27..0 : Trim value override register 4. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Pos (0UL) /*!< Position of OVERRIDE4 field. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Msk (0xFFFFFFFUL << RADIO_OVERRIDE4_OVERRIDE4_Pos) /*!< Bit mask of OVERRIDE4 field. */
N
N/* Register: RADIO_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RADIO_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RADIO_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RNG */
N/* Description: Random Number Generator. */
N
N/* Register: RNG_SHORTS */
N/* Description: Shortcut for the RNG. */
N
N/* Bit 0 : Short-cut between VALRDY event and STOP task. */
N#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RNG_INTENSET */
N/* Description: Interrupt enable set register */
N
N/* Bit 0 : Enable interrupt on VALRDY event. */
N#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RNG_INTENCLR */
N/* Description: Interrupt enable clear register */
N
N/* Bit 0 : Disable interrupt on VALRDY event. */
N#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RNG_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 0 : Digital error correction enable. */
N#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Digital error correction disabled. */
N#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Digital error correction enabled. */
N
N/* Register: RNG_VALUE */
N/* Description: RNG random number. */
N
N/* Bits 7..0 : Generated random number. */
N#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
N#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
N
N/* Register: RNG_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RNG_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RNG_POWER_POWER_Msk (0x1UL << RNG_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RNG_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RNG_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RTC */
N/* Description: Real time counter 0. */
N
N/* Register: RTC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] event. */
N#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] event. */
N#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] event. */
N#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] event. */
N#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on OVRFLW event. */
N#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on TICK event. */
N#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RTC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] event. */
N#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] event. */
N#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] event. */
N#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] event. */
N#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on OVRFLW event. */
N#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on TICK event. */
N#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RTC_EVTEN */
N/* Description: Configures event enable routing to PPI for each RTC event. */
N
N/* Bit 19 : COMPARE[3] event enable. */
N#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 18 : COMPARE[2] event enable. */
N#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 17 : COMPARE[1] event enable. */
N#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 16 : COMPARE[0] event enable. */
N#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 1 : OVRFLW event enable. */
N#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 0 : TICK event enable. */
N#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Event enabled. */
N
N/* Register: RTC_EVTENSET */
N/* Description: Enable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Enable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 18 : Enable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 17 : Enable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 16 : Enable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 1 : Enable routing to PPI of OVRFLW event. */
N#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 0 : Enable routing to PPI of TICK event. */
N#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable event on write. */
N
N/* Register: RTC_EVTENCLR */
N/* Description: Disable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Disable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 18 : Disable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 17 : Disable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 16 : Disable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 1 : Disable routing to PPI of OVRFLW event. */
N#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 0 : Disable routing to PPI of TICK event. */
N#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable event on write. */
N
N/* Register: RTC_COUNTER */
N/* Description: Current COUNTER value. */
N
N/* Bits 23..0 : Counter value. */
N#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
N#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
N
N/* Register: RTC_PRESCALER */
N/* Description: 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed. */
N
N/* Bits 11..0 : RTC PRESCALER value. */
N#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: RTC_CC */
N/* Description: Capture/compare registers. */
N
N/* Bits 23..0 : Compare value. */
N#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
N#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
N
N/* Register: RTC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RTC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RTC_POWER_POWER_Msk (0x1UL << RTC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RTC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RTC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPI */
N/* Description: SPI master 0. */
N
N/* Register: SPI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on READY event. */
N#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPI_ENABLE */
N/* Description: Enable SPI. */
N
N/* Bits 2..0 : Enable or disable SPI. */
N#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Msk (0x7UL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPI. */
N#define SPI_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable SPI. */
N
N/* Register: SPI_RXD */
N/* Description: RX data. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: SPI_TXD */
N/* Description: TX data. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: SPI_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI data rate. */
N#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500kbps. */
N#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8Mbps. */
N
N/* Register: SPI_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPI_POWER_POWER_Msk (0x1UL << SPI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPIS */
N/* Description: SPI slave 1. */
N
N/* Register: SPIS_SHORTS */
N/* Description: Shortcuts for SPIS. */
N
N/* Bit 2 : Shortcut between END event and the ACQUIRE task. */
N#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Shortcut disabled. */
N#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: SPIS_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on ACQUIRED event. */
N#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on END event. */
N#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPIS_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on ACQUIRED event. */
N#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on END event. */
N#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPIS_SEMSTAT */
N/* Description: Semaphore status. */
N
N/* Bits 1..0 : Semaphore status. */
N#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Free (0x00UL) /*!< Semaphore is free. */
N#define SPIS_SEMSTAT_SEMSTAT_CPU (0x01UL) /*!< Semaphore is assigned to the CPU. */
N#define SPIS_SEMSTAT_SEMSTAT_SPIS (0x02UL) /*!< Semaphore is assigned to the SPIS. */
N#define SPIS_SEMSTAT_SEMSTAT_CPUPending (0x03UL) /*!< Semaphore is assigned to the SPIS, but a handover to the CPU is pending. */
N
N/* Register: SPIS_STATUS */
N/* Description: Status from last transaction. */
N
N/* Bit 1 : RX buffer overflow detected, and prevented. */
N#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Clear on write. */
N
N/* Bit 0 : TX buffer overread detected, and prevented. */
N#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Clear on write. */
N
N/* Register: SPIS_ENABLE */
N/* Description: Enable SPIS. */
N
N/* Bits 2..0 : Enable or disable SPIS. */
N#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Msk (0x7UL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPIS. */
N#define SPIS_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable SPIS. */
N
N/* Register: SPIS_MAXRX */
N/* Description: Maximum number of bytes in the receive buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the receive buffer. */
N#define SPIS_MAXRX_MAXRX_Pos (0UL) /*!< Position of MAXRX field. */
N#define SPIS_MAXRX_MAXRX_Msk (0xFFUL << SPIS_MAXRX_MAXRX_Pos) /*!< Bit mask of MAXRX field. */
N
N/* Register: SPIS_AMOUNTRX */
N/* Description: Number of bytes received in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes received in last granted transaction. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Pos (0UL) /*!< Position of AMOUNTRX field. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Msk (0xFFUL << SPIS_AMOUNTRX_AMOUNTRX_Pos) /*!< Bit mask of AMOUNTRX field. */
N
N/* Register: SPIS_MAXTX */
N/* Description: Maximum number of bytes in the transmit buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the transmit buffer. */
N#define SPIS_MAXTX_MAXTX_Pos (0UL) /*!< Position of MAXTX field. */
N#define SPIS_MAXTX_MAXTX_Msk (0xFFUL << SPIS_MAXTX_MAXTX_Pos) /*!< Bit mask of MAXTX field. */
N
N/* Register: SPIS_AMOUNTTX */
N/* Description: Number of bytes transmitted in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes transmitted in last granted transaction. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Pos (0UL) /*!< Position of AMOUNTTX field. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Msk (0xFFUL << SPIS_AMOUNTTX_AMOUNTTX_Pos) /*!< Bit mask of AMOUNTTX field. */
N
N/* Register: SPIS_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPIS_DEF */
N/* Description: Default character. */
N
N/* Bits 7..0 : Default character. */
N#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
N#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
N
N/* Register: SPIS_ORC */
N/* Description: Over-read character. */
N
N/* Bits 7..0 : Over-read character. */
N#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N/* Register: SPIS_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPIS_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPIS_POWER_POWER_Msk (0x1UL << SPIS_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPIS_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPIS_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TEMP */
N/* Description: Temperature Sensor. */
N
N/* Register: TEMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on DATARDY event. */
N#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TEMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on DATARDY event. */
N#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TEMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TEMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TEMP_POWER_POWER_Msk (0x1UL << TEMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TEMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TEMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TIMER */
N/* Description: Timer 0. */
N
N/* Register: TIMER_SHORTS */
N/* Description: Shortcuts for Timer. */
N
N/* Bit 11 : Shortcut between CC[3] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 10 : Shortcut between CC[2] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 9 : Shortcut between CC[1] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 8 : Shortcut between CC[0] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CC[3] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between CC[2] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between CC[1] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between CC[0] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TIMER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] */
N#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] */
N#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] */
N#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] */
N#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TIMER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] */
N#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] */
N#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] */
N#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] */
N#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TIMER_MODE */
N/* Description: Timer Mode selection. */
N
N/* Bit 0 : Select Normal or Counter mode. */
N#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define TIMER_MODE_MODE_Msk (0x1UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define TIMER_MODE_MODE_Timer (0UL) /*!< Timer in Normal mode. */
N#define TIMER_MODE_MODE_Counter (1UL) /*!< Timer in Counter mode. */
N
N/* Register: TIMER_BITMODE */
N/* Description: Sets timer behaviour. */
N
N/* Bits 1..0 : Sets timer behaviour ro be like the implementation of a timer with width as indicated. */
N#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_16Bit (0x00UL) /*!< 16-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_08Bit (0x01UL) /*!< 8-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_24Bit (0x02UL) /*!< 24-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_32Bit (0x03UL) /*!< 32-bit timer behaviour. */
N
N/* Register: TIMER_PRESCALER */
N/* Description: 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE. */
N
N/* Bits 3..0 : Timer PRESCALER value. Max value is 9. */
N#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: TIMER_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TIMER_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TIMER_POWER_POWER_Msk (0x1UL << TIMER_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TIMER_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TIMER_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TWI */
N/* Description: Two-wire interface master 0. */
N
N/* Register: TWI_SHORTS */
N/* Description: Shortcuts for TWI. */
N
N/* Bit 1 : Shortcut between BB event and the STOP task. */
N#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between BB event and the SUSPEND task. */
N#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TWI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 14 : Enable interrupt on BB event. */
N#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENSET_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_BB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXDSENT event. */
N#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on STOPPED event. */
N#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TWI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 14 : Disable interrupt on BB event. */
N#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXDSENT event. */
N#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXDREADY event. */
N#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on STOPPED event. */
N#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TWI_ERRORSRC */
N/* Description: Two-wire error source. Write error field to 1 to clear error. */
N
N/* Bit 2 : NACK received after sending a data byte. */
N#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_DNACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : NACK received after sending the address. */
N#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_ANACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: TWI_ENABLE */
N/* Description: Enable two-wire master. */
N
N/* Bits 2..0 : Enable or disable W2M */
N#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Msk (0x7UL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled. */
N#define TWI_ENABLE_ENABLE_Enabled (0x05UL) /*!< Enabled. */
N
N/* Register: TWI_RXD */
N/* Description: RX data register. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: TWI_TXD */
N/* Description: TX data register. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: TWI_FREQUENCY */
N/* Description: Two-wire frequency. */
N
N/* Bits 31..0 : Two-wire master clock frequency. */
N#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps. */
N
N/* Register: TWI_ADDRESS */
N/* Description: Address used in the two-wire transfer. */
N
N/* Bits 6..0 : Two-wire address. */
N#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N/* Register: TWI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TWI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TWI_POWER_POWER_Msk (0x1UL << TWI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TWI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TWI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UART */
N/* Description: Universal Asynchronous Receiver/Transmitter, version 1.0. */
N
N/* Register: UART_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 17 : Enable interrupt on RXTO event. */
N#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXRDY event. */
N#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on RXRDY event. */
N#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: UART_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 17 : Disable interrupt on RXTO event. */
N#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXRDY event. */
N#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXRDY event. */
N#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: UART_ERRORSRC */
N/* Description: Error source. Write error field to 1 to clear error. */
N
N/* Bit 3 : The serial data input is '0' for longer than the length of a data frame. */
N#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_BREAK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 2 : A valid stop bit is not detected on the serial data input after all bits in a character have been received. */
N#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_FRAMING_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : A character with bad parity is received. Only checked if HW parity control is enabled. */
N#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_PARITY_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : A start bit is received while the previous data still lies in RXD. (Data loss). */
N#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: UART_ENABLE */
N/* Description: Enable UART and acquire IOs. */
N
N/* Bits 2..0 : Enable or disable UART and acquire IOs. */
N#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UART_ENABLE_ENABLE_Msk (0x7UL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UART_ENABLE_ENABLE_Disabled (0x00UL) /*!< UART disabled. */
N#define UART_ENABLE_ENABLE_Enabled (0x04UL) /*!< UART enabled. */
N
N/* Register: UART_RXD */
N/* Description: RXD register. On read action the buffer pointer is displaced. Once read the character is consummed. If read when no character available, the UART will stop working. */
N
N/* Bits 7..0 : RX data from previous transfer. Double buffered. */
N#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: UART_TXD */
N/* Description: TXD register. */
N
N/* Bits 7..0 : TX data for transfer. */
N#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: UART_BAUDRATE */
N/* Description: UART Baudrate. */
N
N/* Bits 31..0 : UART baudrate. */
N#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBEDFA4UL) /*!< 921600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1M baud. */
N
N/* Register: UART_CONFIG */
N/* Description: Configuration of parity and hardware flow control register. */
N
N/* Bits 3..1 : Include parity bit. */
N#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_CONFIG_PARITY_Excluded (0UL) /*!< Parity bit excluded. */
N#define UART_CONFIG_PARITY_Included (7UL) /*!< Parity bit included. */
N
N/* Bit 0 : Hardware flow control. */
N#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Hardware flow control disabled. */
N#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Hardware flow control enabled. */
N
N/* Register: UART_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define UART_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define UART_POWER_POWER_Msk (0x1UL << UART_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define UART_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define UART_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UICR */
N/* Description: User Information Configuration. */
N
N/* Register: UICR_RBPCONF */
N/* Description: Readback protection configuration. */
N
N/* Bits 15..8 : Readback protect all code in the device. */
N#define UICR_RBPCONF_PALL_Pos (8UL) /*!< Position of PALL field. */
N#define UICR_RBPCONF_PALL_Msk (0xFFUL << UICR_RBPCONF_PALL_Pos) /*!< Bit mask of PALL field. */
N#define UICR_RBPCONF_PALL_Disabled (0xFFUL) /*!< Disabled. */
N#define UICR_RBPCONF_PALL_Enabled (0x00UL) /*!< Enabled. */
N
N/* Bits 7..0 : Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip. */
N#define UICR_RBPCONF_PR0_Pos (0UL) /*!< Position of PR0 field. */
N#define UICR_RBPCONF_PR0_Msk (0xFFUL << UICR_RBPCONF_PR0_Pos) /*!< Bit mask of PR0 field. */
N#define UICR_RBPCONF_PR0_Disabled (0xFFUL) /*!< Disabled. */
N#define UICR_RBPCONF_PR0_Enabled (0x00UL) /*!< Enabled. */
N
N/* Register: UICR_XTALFREQ */
N/* Description: Reset value for CLOCK XTALFREQ register. */
N
N/* Bits 7..0 : Reset value for CLOCK XTALFREQ register. */
N#define UICR_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_Msk (0xFFUL << UICR_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz Xtal is used. */
N#define UICR_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz Xtal is used. */
N
N/* Register: UICR_FWID */
N/* Description: Firmware ID. */
N
N/* Bits 15..0 : Identification number for the firmware loaded into the chip. */
N#define UICR_FWID_FWID_Pos (0UL) /*!< Position of FWID field. */
N#define UICR_FWID_FWID_Msk (0xFFFFUL << UICR_FWID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N
N/* Peripheral: WDT */
N/* Description: Watchdog Timer. */
N
N/* Register: WDT_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on TIMEOUT event. */
N#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: WDT_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on TIMEOUT event. */
N#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: WDT_RUNSTATUS */
N/* Description: Watchdog running status. */
N
N/* Bit 0 : Watchdog running status. */
N#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog timer is not running. */
N#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog timer is running. */
N
N/* Register: WDT_REQSTATUS */
N/* Description: Request status. */
N
N/* Bit 7 : Request status for RR[7]. */
N#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled and has not jet requested. */
N
N/* Bit 6 : Request status for RR[6]. */
N#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled and has not jet requested. */
N
N/* Bit 5 : Request status for RR[5]. */
N#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled and has not jet requested. */
N
N/* Bit 4 : Request status for RR[4]. */
N#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled and has not jet requested. */
N
N/* Bit 3 : Request status for RR[3]. */
N#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled and has not jet requested. */
N
N/* Bit 2 : Request status for RR[2]. */
N#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled and has not jet requested. */
N
N/* Bit 1 : Request status for RR[1]. */
N#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled and has not jet requested. */
N
N/* Bit 0 : Request status for RR[0]. */
N#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled and has not jet requested. */
N
N/* Register: WDT_RREN */
N/* Description: Reload request enable. */
N
N/* Bit 7 : Enable or disable RR[7] register. */
N#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_RREN_RR7_Disabled (0UL) /*!< RR[7] register is disabled. */
N#define WDT_RREN_RR7_Enabled (1UL) /*!< RR[7] register is enabled. */
N
N/* Bit 6 : Enable or disable RR[6] register. */
N#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_RREN_RR6_Disabled (0UL) /*!< RR[6] register is disabled. */
N#define WDT_RREN_RR6_Enabled (1UL) /*!< RR[6] register is enabled. */
N
N/* Bit 5 : Enable or disable RR[5] register. */
N#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_RREN_RR5_Disabled (0UL) /*!< RR[5] register is disabled. */
N#define WDT_RREN_RR5_Enabled (1UL) /*!< RR[5] register is enabled. */
N
N/* Bit 4 : Enable or disable RR[4] register. */
N#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_RREN_RR4_Disabled (0UL) /*!< RR[4] register is disabled. */
N#define WDT_RREN_RR4_Enabled (1UL) /*!< RR[4] register is enabled. */
N
N/* Bit 3 : Enable or disable RR[3] register. */
N#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_RREN_RR3_Disabled (0UL) /*!< RR[3] register is disabled. */
N#define WDT_RREN_RR3_Enabled (1UL) /*!< RR[3] register is enabled. */
N
N/* Bit 2 : Enable or disable RR[2] register. */
N#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_RREN_RR2_Disabled (0UL) /*!< RR[2] register is disabled. */
N#define WDT_RREN_RR2_Enabled (1UL) /*!< RR[2] register is enabled. */
N
N/* Bit 1 : Enable or disable RR[1] register. */
N#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_RREN_RR1_Disabled (0UL) /*!< RR[1] register is disabled. */
N#define WDT_RREN_RR1_Enabled (1UL) /*!< RR[1] register is enabled. */
N
N/* Bit 0 : Enable or disable RR[0] register. */
N#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_RREN_RR0_Disabled (0UL) /*!< RR[0] register is disabled. */
N#define WDT_RREN_RR0_Enabled (1UL) /*!< RR[0] register is enabled. */
N
N/* Register: WDT_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 3 : Configure the watchdog to pause or not while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
N#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
N#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Run (1UL) /*!< Do not pause watchdog while the CPU is halted by the debugger. */
N
N/* Bit 0 : Configure the watchdog to pause or not while the CPU is sleeping. */
N#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is asleep. */
N#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Do not pause watchdog while the CPU is asleep. */
N
N/* Register: WDT_RR */
N/* Description: Reload requests registers. */
N
N/* Bits 31..0 : Reload register. */
N#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
N#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
N#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer. */
N
N/* Register: WDT_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define WDT_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define WDT_POWER_POWER_Msk (0x1UL << WDT_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define WDT_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define WDT_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/*lint --flb "Leave library region" */
N#endif
L 6 "..\..\..\Software\Include\nrf_gpio.h" 2
N
N/**
N * @defgroup nrf_gpio GPIO abstraction
N * @{
N * @ingroup nrf_drivers
N * @brief GPIO pin abstraction and port abstraction for reading and writing byte-wise to GPIO ports.
N *
N * Here, the GPIO ports are defined as follows:
N * - Port 0 -> pin 0-7
N * - Port 1 -> pin 8-15
N * - Port 2 -> pin 16-23
N * - Port 3 -> pin 24-31
N */
N
N/**
N * @enum nrf_gpio_port_dir_t
N * @brief Enumerator used for setting the direction of a GPIO port.
N */
Ntypedef enum
N{
N    NRF_GPIO_PORT_DIR_OUTPUT,       ///<  Output
N    NRF_GPIO_PORT_DIR_INPUT         ///<  Input
N} nrf_gpio_port_dir_t;
N
N/**
N * @enum nrf_gpio_pin_dir_t
N * Pin direction definitions.
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_DIR_INPUT,   ///< Input
N    NRF_GPIO_PIN_DIR_OUTPUT   ///< Output
N} nrf_gpio_pin_dir_t;
N
N/**
N * @enum nrf_gpio_port_select_t
N * @brief Enumerator used for selecting between port 0 - 3.
N */
Ntypedef enum
N{
N    NRF_GPIO_PORT_SELECT_PORT0 = 0,           ///<  Port 0 (GPIO pin 0-7)
N    NRF_GPIO_PORT_SELECT_PORT1,               ///<  Port 1 (GPIO pin 8-15)
N    NRF_GPIO_PORT_SELECT_PORT2,               ///<  Port 2 (GPIO pin 16-23)
N    NRF_GPIO_PORT_SELECT_PORT3,               ///<  Port 3 (GPIO pin 24-31)
N} nrf_gpio_port_select_t;
N
N/**
N * @enum nrf_gpio_pin_pull_t
N * @brief Enumerator used for selecting the pin to be pulled down or up at the time of pin configuration
N */
Ntypedef enum
N{
N    NRF_GPIO_PIN_NOPULL   = GPIO_PIN_CNF_PULL_Disabled,                 ///<  Pin pullup resistor disabled
X    NRF_GPIO_PIN_NOPULL   = (0x00UL),                 
N    NRF_GPIO_PIN_PULLDOWN = GPIO_PIN_CNF_PULL_Pulldown,                 ///<  Pin pulldown resistor enabled
X    NRF_GPIO_PIN_PULLDOWN = (0x01UL),                 
N    NRF_GPIO_PIN_PULLUP   = GPIO_PIN_CNF_PULL_Pullup,                   ///<  Pin pullup resistor enabled
X    NRF_GPIO_PIN_PULLUP   = (0x03UL),                   
N} nrf_gpio_pin_pull_t;
N
N/**
N * @brief Function for configuring the GPIO pin range as outputs with normal drive strength.
N *        This function can be used to configure pin range as simple output with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_range_start specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pin_range_end specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @note For configuring only one pin as output use @ref nrf_gpio_cfg_output
N *       Sense capability on the pin is disabled, and input is disconnected from the buffer as the pins are configured as output.
N */
Nstatic __INLINE void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
Xstatic __inline void nrf_gpio_range_cfg_output(uint32_t pin_range_start, uint32_t pin_range_end)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        NRF_GPIO->PIN_CNF[pin_range_start] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
X        ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_range_start] = ((0x00UL) << (16UL))
N                                        | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
X                                        | ((0x00UL) << (8UL))
N                                        | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
X                                        | ((0x00UL) << (2UL))
N                                        | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
X                                        | ((0UL) << (1UL))
N                                        | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
X                                        | ((1UL) << (0UL));
N    }
N}
N
N/**
N * @brief Function for configuring the GPIO pin range as inputs with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input.
N *
N * @param pin_range_start specifies the start number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pin_range_end specifies the end number (inclusive) in the range of pin numbers to be configured (allowed values 0-30)
N *
N * @param pull_config State of the pin range pull resistor (no pull, pulled down or pulled high)
N *
N * @note  For configuring only one pin as input use @ref nrf_gpio_cfg_input
N *        Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
N */
Nstatic __INLINE void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
Xstatic __inline void nrf_gpio_range_cfg_input(uint32_t pin_range_start, uint32_t pin_range_end, nrf_gpio_pin_pull_t pull_config)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    for (; pin_range_start <= pin_range_end; pin_range_start++)
N    {
N        NRF_GPIO->PIN_CNF[pin_range_start] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
X        ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_range_start] = ((0x00UL) << (16UL))
N                                        | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
X                                        | ((0x00UL) << (8UL))
N                                        | (pull_config << GPIO_PIN_CNF_PULL_Pos)
X                                        | (pull_config << (2UL))
N                                        | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
X                                        | ((0UL) << (1UL))
N                                        | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);
X                                        | ((0UL) << (0UL));
N    }
N}
N
N/**
N * @brief Function for configuring the given GPIO pin number as output with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_number specifies the pin number of gpio pin numbers to be configured (allowed values 0-30)
N *
N * @note  Sense capability on the pin is disabled, and input is disconnected from the buffer as the pins are configured as output.
N */
Nstatic __INLINE void nrf_gpio_cfg_output(uint32_t pin_number)
Xstatic __inline void nrf_gpio_cfg_output(uint32_t pin_number)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    NRF_GPIO->PIN_CNF[pin_number] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] = ((0x00UL) << (16UL))
N                                            | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
X                                            | ((0x00UL) << (8UL))
N                                            | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
X                                            | ((0x00UL) << (2UL))
N                                            | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
X                                            | ((0UL) << (1UL))
N                                            | (GPIO_PIN_CNF_DIR_Output << GPIO_PIN_CNF_DIR_Pos);
X                                            | ((1UL) << (0UL));
N}
N
N/**
N * @brief Function for configuring the given GPIO pin number as input with given initial value set, hiding inner details.
N *        This function can be used to configure pin range as simple input with gate driving GPIO_PIN_CNF_DRIVE_S0S1 (normal cases).
N *
N * @param pin_number specifies the pin number of gpio pin numbers to be configured (allowed values 0-30)
N *
N * @param pull_config State of the pin range pull resistor (no pull, pulled down or pulled high)
N *
N * @note  Sense capability on the pin is disabled, and input is connected to buffer so that the GPIO->IN register is readable
N */
Nstatic __INLINE void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
Xstatic __inline void nrf_gpio_cfg_input(uint32_t pin_number, nrf_gpio_pin_pull_t pull_config)
N{
N    /*lint -e{845} // A zero has been given as right argument to operator '|'" */
N    NRF_GPIO->PIN_CNF[pin_number] = (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
X    ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] = ((0x00UL) << (16UL))
N                                        | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
X                                        | ((0x00UL) << (8UL))
N                                        | (pull_config << GPIO_PIN_CNF_PULL_Pos)
X                                        | (pull_config << (2UL))
N                                        | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
X                                        | ((0UL) << (1UL))
N                                        | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);
X                                        | ((0UL) << (0UL));
N}
N
N/**
N * @brief Function for setting the direction for a GPIO pin.
N *
N * @param pin_number specifies the pin number [0:31] for which to
N * set the direction.
N *
N * @param direction specifies the direction
N */
Nstatic __INLINE void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
Xstatic __inline void nrf_gpio_pin_dir_set(uint32_t pin_number, nrf_gpio_pin_dir_t direction)
N{
N    if(direction == NRF_GPIO_PIN_DIR_INPUT)
N    {
N        NRF_GPIO->PIN_CNF[pin_number] =
X        ((NRF_GPIO_Type *) 0x50000000UL)->PIN_CNF[pin_number] =
N          (GPIO_PIN_CNF_SENSE_Disabled << GPIO_PIN_CNF_SENSE_Pos)
X          ((0x00UL) << (16UL))
N        | (GPIO_PIN_CNF_DRIVE_S0S1 << GPIO_PIN_CNF_DRIVE_Pos)
X        | ((0x00UL) << (8UL))
N        | (GPIO_PIN_CNF_PULL_Disabled << GPIO_PIN_CNF_PULL_Pos)
X        | ((0x00UL) << (2UL))
N        | (GPIO_PIN_CNF_INPUT_Connect << GPIO_PIN_CNF_INPUT_Pos)
X        | ((0UL) << (1UL))
N        | (GPIO_PIN_CNF_DIR_Input << GPIO_PIN_CNF_DIR_Pos);
X        | ((0UL) << (0UL));
N    }
N    else
N    {
N        NRF_GPIO -> DIRSET = (1UL << pin_number);
X        ((NRF_GPIO_Type *) 0x50000000UL) -> DIRSET = (1UL << pin_number);
N    }
N}
N
N/**
N * @brief Function for setting a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number specifies the pin number [0:31] to
N * set.
N */
Nstatic __INLINE void nrf_gpio_pin_set(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_set(uint32_t pin_number)
N{
N    NRF_GPIO->OUTSET = (1UL << pin_number);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTSET = (1UL << pin_number);
N}
N
N/**
N * @brief Function for clearing a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number specifies the pin number [0:31] to
N * clear.
N */
Nstatic __INLINE void nrf_gpio_pin_clear(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_clear(uint32_t pin_number)
N{
N    NRF_GPIO->OUTCLR = (1UL << pin_number);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR = (1UL << pin_number);
N}
N
N/**
N * @brief Function for toggling a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number specifies the pin number [0:31] to
N * toggle.
N */
Nstatic __INLINE void nrf_gpio_pin_toggle(uint32_t pin_number)
Xstatic __inline void nrf_gpio_pin_toggle(uint32_t pin_number)
N{
N    NRF_GPIO->OUT ^= (1UL << pin_number);
X    ((NRF_GPIO_Type *) 0x50000000UL)->OUT ^= (1UL << pin_number);
N}
N
N/**
N * @brief Function for writing a value to a GPIO pin.
N *
N * Note that the pin must be configured as an output for this
N * function to have any effect.
N *
N * @param pin_number specifies the pin number [0:31] to
N * write.
N *
N * @param value specifies the value to be written to the pin.
N * @arg 0 clears the pin
N * @arg >=1 sets the pin.
N */
Nstatic __INLINE void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
Xstatic __inline void nrf_gpio_pin_write(uint32_t pin_number, uint32_t value)
N{
N    if (value == 0)
N    {
N        nrf_gpio_pin_clear(pin_number);
N    }
N    else
N    {
N        nrf_gpio_pin_set(pin_number);
N    }
N}
N
N/**
N * @brief Function for reading the input level of a GPIO pin.
N *
N * Note that the pin must have input connected for the value
N * returned from this function to be valid.
N *
N * @param pin_number specifies the pin number [0:31] to
N * read.
N *
N * @return
N * @retval 0 if the pin input level is low.
N * @retval 1 if the pin input level is high.
N * @retval > 1 should never occur.
N */
Nstatic __INLINE uint32_t nrf_gpio_pin_read(uint32_t pin_number)
Xstatic __inline uint32_t nrf_gpio_pin_read(uint32_t pin_number)
N{
N    return  ((NRF_GPIO->IN >> pin_number) & 1UL);
X    return  ((((NRF_GPIO_Type *) 0x50000000UL)->IN >> pin_number) & 1UL);
N}
N
N/**
N * @brief Generic function for writing a single byte of a 32 bit word at a given
N * address.
N *
N * This function should not be called from outside the nrf_gpio
N * abstraction layer.
N *
N * @param word_address is the address of the word to be written.
N *
N * @param byte_no is the the word byte number (0-3) to be written.
N *
N * @param value is the value to be written to byte "byte_no" of word
N * at address "word_address"
N */
Nstatic __INLINE void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value)
Xstatic __inline void nrf_gpio_word_byte_write(volatile uint32_t * word_address, uint8_t byte_no, uint8_t value)
N{
N    *((volatile uint8_t*)(word_address) + byte_no) = value;
N}
N
N/**
N * @brief Generic function for reading a single byte of a 32 bit word at a given
N * address.
N *
N * This function should not be called from outside the nrf_gpio
N * abstraction layer.
N *
N * @param word_address is the address of the word to be read.
N *
N * @param byte_no is the the byte number (0-3) of the word to be read.
N *
N * @return byte "byte_no" of word at address "word_address".
N */
Nstatic __INLINE uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no)
Xstatic __inline uint8_t nrf_gpio_word_byte_read(const volatile uint32_t* word_address, uint8_t byte_no)
N{
N    return (*((const volatile uint8_t*)(word_address) + byte_no));
N}
N
N/**
N * @brief Function for setting the direction of a port.
N *
N * @param port is the port for which to set the direction.
N *
N * @param dir direction to be set for this port.
N */
Nstatic __INLINE void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir)
Xstatic __inline void nrf_gpio_port_dir_set(nrf_gpio_port_select_t port, nrf_gpio_port_dir_t dir)
N{
N    if (dir == NRF_GPIO_PORT_DIR_OUTPUT)
N    {
N        nrf_gpio_word_byte_write(&NRF_GPIO->DIRSET, port, 0xFF);
X        nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->DIRSET, port, 0xFF);
N    }
N    else
N    {
N        nrf_gpio_range_cfg_input(port*8, (port+1)*8-1, NRF_GPIO_PIN_NOPULL);
N    }
N}
N
N/**
N * @brief Function for reading a GPIO port.
N *
N * @param port is the port to read.
N *
N * @return the input value on this port.
N */
Nstatic __INLINE uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port)
Xstatic __inline uint8_t nrf_gpio_port_read(nrf_gpio_port_select_t port)
N{
N    return nrf_gpio_word_byte_read(&NRF_GPIO->IN, port);
X    return nrf_gpio_word_byte_read(&((NRF_GPIO_Type *) 0x50000000UL)->IN, port);
N}
N
N/**
N * @brief Function for writing to a GPIO port.
N *
N * @param port is the port to write.
N *
N * @param value is the value to write to this port.
N *
N * @sa nrf_gpio_port_dir_set()
N */
Nstatic __INLINE void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value)
Xstatic __inline void nrf_gpio_port_write(nrf_gpio_port_select_t port, uint8_t value)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUT, port, value);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUT, port, value);
N}
N
N/**
N * @brief Function for setting individual pins on GPIO port.
N *
N * @param port is the port for which to set the pins.
N *
N * @param set_mask is a mask specifying which pins to set. A bit
N * set to 1 indicates that the corresponding port pin shall be
N * set.
N *
N * @sa nrf_gpio_port_dir_set()
N */
Nstatic __INLINE void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask)
Xstatic __inline void nrf_gpio_port_set(nrf_gpio_port_select_t port, uint8_t set_mask)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUTSET, port, set_mask);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUTSET, port, set_mask);
N}
N
N/**
N * @brief Function for clearing individual pins on GPIO port.
N *
N * @param port is the port for which to clear the pins.
N *
N * @param clr_mask is a mask specifying which pins to clear. A bit
N * set to 1 indicates that the corresponding port pin shall be
N * cleared.
N *
N * @sa nrf_gpio_port_dir_set()
N */
Nstatic __INLINE void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask)
Xstatic __inline void nrf_gpio_port_clear(nrf_gpio_port_select_t port, uint8_t clr_mask)
N{
N    nrf_gpio_word_byte_write(&NRF_GPIO->OUTCLR, port, clr_mask);
X    nrf_gpio_word_byte_write(&((NRF_GPIO_Type *) 0x50000000UL)->OUTCLR, port, clr_mask);
N}
N
N/** @} */
N
N#endif
L 21 "..\..\..\Software\Source\ble_lib\ble_error_log.c" 2
N#include "ble_flash.h"
N
N
N// Made static to avoid the error_log to go on the stack.
Nstatic ble_error_log_data_t   m_ble_error_log;            /**< . */
Nstatic volatile uint8_t       m_ble_log_clear_flag = 0;   /**< Volatile flag to be used for clearing the flash in debug mode. */
N//lint -esym(526,__Vectors)
Nextern uint32_t             * __Vectors;                  /**< The initialization vector holds the address to __initial_sp that will be used when fetching the stack. */ 
N
N
Nstatic void fetch_stack(ble_error_log_data_t * error_log)
N{
N    uint32_t * p_stack;
N    uint32_t * initial_sp;
N    uint32_t   length;
N  
N    initial_sp = (uint32_t *) __Vectors;
N    p_stack    = (uint32_t *) __current_sp();
N  
N    length = ((uint32_t) initial_sp) - ((uint32_t) p_stack);
N    memcpy(error_log->stack_info, 
N           p_stack, 
N           (length > STACK_DUMP_LENGTH) ? STACK_DUMP_LENGTH : length);
X           (length > 256) ? 256 : length);
N}
N
N
Nuint32_t ble_error_log_write(uint32_t err_code, const uint8_t * p_message, uint16_t line_number)
N{
N    uint8_t  error_log_size;
N
N    error_log_size              = CEIL_DIV(sizeof(ble_error_log_data_t), sizeof(uint32_t));
X    error_log_size              = ((((sizeof(ble_error_log_data_t)) - 1) / (sizeof(uint32_t))) + 1);
N    m_ble_error_log.failure     = true;
X    m_ble_error_log.failure     = 1;
N    m_ble_error_log.err_code    = err_code;
N    m_ble_error_log.line_number = line_number;
N
N    strncpy((char *)m_ble_error_log.message, (const char *)p_message, ERROR_MESSAGE_LENGTH - 1);
X    strncpy((char *)m_ble_error_log.message, (const char *)p_message, 128 - 1);
N    m_ble_error_log.message[ERROR_MESSAGE_LENGTH - 1] = '\0';
X    m_ble_error_log.message[128 - 1] = '\0';
N
N    fetch_stack(&m_ble_error_log);
N
N    return ble_flash_page_write(FLASH_PAGE_ERROR_LOG,
X    return ble_flash_page_write((((((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR != 0xFFFFFFFF) ? (((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR / ((uint16_t)((NRF_FICR_Type *) 0x10000000UL)->CODEPAGESIZE)) : ((NRF_FICR_Type *) 0x10000000UL)->CODESIZE) - 2),
N                                (uint32_t *) &m_ble_error_log,
N                                error_log_size);
N}
N
N
Nuint32_t ble_error_log_read(ble_error_log_data_t * error_log)
N{
N    uint8_t  error_log_size = CEIL_DIV(sizeof(ble_error_log_data_t), sizeof(uint32_t));
X    uint8_t  error_log_size = ((((sizeof(ble_error_log_data_t)) - 1) / (sizeof(uint32_t))) + 1);
N    uint32_t err_code       = NRF_SUCCESS;
X    uint32_t err_code       = ((0x0) + 0);
N    
N    err_code = ble_flash_page_read(FLASH_PAGE_ERROR_LOG, (uint32_t *) error_log, &error_log_size);
X    err_code = ble_flash_page_read((((((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR != 0xFFFFFFFF) ? (((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR / ((uint16_t)((NRF_FICR_Type *) 0x10000000UL)->CODEPAGESIZE)) : ((NRF_FICR_Type *) 0x10000000UL)->CODESIZE) - 2), (uint32_t *) error_log, &error_log_size);
N    
N    // If nothing is in flash; then return NRF_SUCCESS.
N    if (err_code == NRF_ERROR_NOT_FOUND)
X    if (err_code == ((0x0) + 5))
N    {
N        return NRF_SUCCESS;
X        return ((0x0) + 0);
N    }
N
N    if (err_code != NRF_SUCCESS)
X    if (err_code != ((0x0) + 0))
N    {
N        return err_code;
N    }
N
N    if (!error_log->failure)
N    {
N        return NRF_SUCCESS;
X        return ((0x0) + 0);
N    }
N
N    nrf_gpio_pin_set(LOG_LED_PIN_NO); // Notify that a message exists in the log.
X    nrf_gpio_pin_set(14); 
N
N    while (error_log->failure && !m_ble_log_clear_flag)
N    {
N        // Put breakpoint, and read data, then log->failure=false; to continue in debug mode.
N        // In application, define how to clear the error log, 
N        // e.g. read button 6, if pressed, then clear log and continue.
N    }
N    
N    nrf_gpio_pin_clear(LOG_LED_PIN_NO);
X    nrf_gpio_pin_clear(14);
N    err_code = ble_flash_page_erase(FLASH_PAGE_ERROR_LOG);
X    err_code = ble_flash_page_erase((((((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR != 0xFFFFFFFF) ? (((NRF_UICR_Type *) 0x10001000UL)->BOOTLOADERADDR / ((uint16_t)((NRF_FICR_Type *) 0x10000000UL)->CODEPAGESIZE)) : ((NRF_FICR_Type *) 0x10000000UL)->CODESIZE) - 2));
N
N    return err_code;
N}
N
N
Nvoid ble_error_log_clear(void)
N{
N    m_ble_log_clear_flag = 1;
N}
N
N
Nvoid ble_error_log_init(void)
N{
N    // Variable made volatile in order to avoid optimization.
N    // If an assert has been seen, and the old stack must be fetched, 
N    // then find the assembly entry of this function in the map file 
N    // and set 'read_error_log = true' in the debugger to break execution.
N    volatile bool read_error_log = false;
X    volatile _Bool read_error_log = 0;
N    uint32_t      err_code;
N
N    if (read_error_log)
N    {
N        err_code = ble_error_log_read(&m_ble_error_log);
N        APP_ERROR_CHECK_BOOL(err_code == NRF_SUCCESS || err_code == NRF_ERROR_NOT_FOUND);
X        do { const _Bool LOCAL_BOOLEAN_VALUE = (err_code == ((0x0) + 0) || err_code == ((0x0) + 5)); if (!LOCAL_BOOLEAN_VALUE) { do { app_error_handler((0), 124, (uint8_t*) "..\\..\\..\\Software\\Source\\ble_lib\\ble_error_log.c"); } while (0); } } while (0);
N    }
N}
