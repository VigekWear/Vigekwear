; generated by ARM C/C++ Compiler, 5.02 [Build 28]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o.\output\flash_ctrl.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\output\flash_ctrl.d --cpu=Cortex-M0 --apcs=interwork -O0 -I..\..\..\Software\Include -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Device\Nordic\nRF51822\Include -DNRF51 -DBOARD_PCA10001 -DNRF51_DBG --omf_browse=.\output\flash_ctrl.crf ..\..\..\Software\Source\sys_work_handle\flash_ctrl.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  flash_page_erase PROC
;;;24      */
;;;25     void flash_page_erase(uint32_t *page_address)
000000  2102              MOVS     r1,#2
;;;26     {
;;;27       // Turn on flash erase enable and wait until the NVMC is ready:
;;;28         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Een << NVMC_CONFIG_WEN_Pos);
000002  4a2a              LDR      r2,|L1.172|
000004  6051              STR      r1,[r2,#4]
;;;29         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000006  bf00              NOP      
                  |L1.8|
000008  4929              LDR      r1,|L1.176|
00000a  6809              LDR      r1,[r1,#0]
00000c  2900              CMP      r1,#0
00000e  d0fb              BEQ      |L1.8|
;;;30         {
;;;31             // Do nothing.
;;;32         }
;;;33         
;;;34         // Erase page:
;;;35         NRF_NVMC->ERASEPAGE = (uint32_t)page_address;
000010  4926              LDR      r1,|L1.172|
000012  6088              STR      r0,[r1,#8]
;;;36         
;;;37         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000014  bf00              NOP      
                  |L1.22|
000016  4926              LDR      r1,|L1.176|
000018  6809              LDR      r1,[r1,#0]
00001a  2900              CMP      r1,#0
00001c  d0fb              BEQ      |L1.22|
;;;38         {
;;;39             // Do nothing.
;;;40         }
;;;41         
;;;42         // Turn off flash erase enable and wait until the NVMC is ready:
;;;43         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos);
00001e  2100              MOVS     r1,#0
000020  4a22              LDR      r2,|L1.172|
000022  6051              STR      r1,[r2,#4]
;;;44         
;;;45         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000024  bf00              NOP      
                  |L1.38|
000026  4922              LDR      r1,|L1.176|
000028  6809              LDR      r1,[r1,#0]
00002a  2900              CMP      r1,#0
00002c  d0fb              BEQ      |L1.38|
;;;46         {
;;;47             // Do nothing.
;;;48         }
;;;49     }
00002e  4770              BX       lr
;;;50     
                          ENDP

                  flash_word_write PROC
;;;57      */
;;;58     void flash_word_write(uint32_t *address, uint32_t value)
000030  2201              MOVS     r2,#1
;;;59     {
;;;60         // Turn on flash write enable and wait until the NVMC is ready:
;;;61         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Wen << NVMC_CONFIG_WEN_Pos);
000032  4b1e              LDR      r3,|L1.172|
000034  605a              STR      r2,[r3,#4]
;;;62         
;;;63         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000036  bf00              NOP      
                  |L1.56|
000038  4a1d              LDR      r2,|L1.176|
00003a  6812              LDR      r2,[r2,#0]
00003c  2a00              CMP      r2,#0
00003e  d0fb              BEQ      |L1.56|
;;;64         {
;;;65             // Do nothing.
;;;66         }
;;;67       
;;;68         *address = value;
000040  6001              STR      r1,[r0,#0]
;;;69       
;;;70         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000042  bf00              NOP      
                  |L1.68|
000044  4a1a              LDR      r2,|L1.176|
000046  6812              LDR      r2,[r2,#0]
000048  2a00              CMP      r2,#0
00004a  d0fb              BEQ      |L1.68|
;;;71         {
;;;72             // Do nothing.
;;;73         }
;;;74       
;;;75         // Turn off flash write enable and wait until the NVMC is ready:
;;;76         NRF_NVMC->CONFIG = (NVMC_CONFIG_WEN_Ren << NVMC_CONFIG_WEN_Pos);
00004c  2200              MOVS     r2,#0
00004e  4b17              LDR      r3,|L1.172|
000050  605a              STR      r2,[r3,#4]
;;;77       
;;;78         while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
000052  bf00              NOP      
                  |L1.84|
000054  4a16              LDR      r2,|L1.176|
000056  6812              LDR      r2,[r2,#0]
000058  2a00              CMP      r2,#0
00005a  d0fb              BEQ      |L1.84|
;;;79         {
;;;80             // Do nothing.
;;;81         }
;;;82     }
00005c  4770              BX       lr
;;;83     
                          ENDP

                  flash_specword_write PROC
;;;84     void flash_specword_write(uint32_t *address, uint8_t offset, uint32_t data)
00005e  b5f0              PUSH     {r4-r7,lr}
;;;85     {
000060  b0ff              SUB      sp,sp,#0x1fc
000062  b0ff              SUB      sp,sp,#0x1fc
000064  b082              SUB      sp,sp,#8
000066  4605              MOV      r5,r0
000068  460e              MOV      r6,r1
00006a  4617              MOV      r7,r2
;;;86         uint32_t backup[256];
;;;87         uint32_t i;
;;;88         
;;;89         for(i = 0; i < 256; i++ )
00006c  2400              MOVS     r4,#0
00006e  e005              B        |L1.124|
                  |L1.112|
;;;90         {
;;;91             backup[i] = *(address + i);
000070  00a0              LSLS     r0,r4,#2
000072  5828              LDR      r0,[r5,r0]
000074  00a1              LSLS     r1,r4,#2
000076  466a              MOV      r2,sp
000078  5050              STR      r0,[r2,r1]
00007a  1c64              ADDS     r4,r4,#1              ;89
                  |L1.124|
00007c  2cff              CMP      r4,#0xff              ;89
00007e  d9f7              BLS      |L1.112|
;;;92         }
;;;93         
;;;94         flash_page_erase(address);
000080  4628              MOV      r0,r5
000082  f7fffffe          BL       flash_page_erase
;;;95         
;;;96         backup[offset] = data;
000086  00b0              LSLS     r0,r6,#2
000088  4669              MOV      r1,sp
00008a  500f              STR      r7,[r1,r0]
;;;97         
;;;98         for(i = 0; i < 256; i++ )
00008c  2400              MOVS     r4,#0
00008e  e007              B        |L1.160|
                  |L1.144|
;;;99         {
;;;100            flash_word_write((address + i), backup[i]);
000090  00a2              LSLS     r2,r4,#2
000092  466b              MOV      r3,sp
000094  5899              LDR      r1,[r3,r2]
000096  00a2              LSLS     r2,r4,#2
000098  1950              ADDS     r0,r2,r5
00009a  f7fffffe          BL       flash_word_write
00009e  1c64              ADDS     r4,r4,#1              ;98
                  |L1.160|
0000a0  2cff              CMP      r4,#0xff              ;98
0000a2  d9f5              BLS      |L1.144|
;;;101        }
;;;102           
;;;103    }
0000a4  b07f              ADD      sp,sp,#0x1fc
0000a6  b07f              ADD      sp,sp,#0x1fc
0000a8  b002              ADD      sp,sp,#8
0000aa  bdf0              POP      {r4-r7,pc}
;;;104    
                          ENDP

                  |L1.172|
                          DCD      0x4001e500
                  |L1.176|
                          DCD      0x4001e400

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Software\\Source\\sys_work_handle\\flash_ctrl.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_flash_ctrl_c_f146e052____REV16|
#line 115 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_flash_ctrl_c_f146e052____REV16| PROC
#line 116

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_flash_ctrl_c_f146e052____REVSH|
#line 130
|__asm___12_flash_ctrl_c_f146e052____REVSH| PROC
#line 131

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
