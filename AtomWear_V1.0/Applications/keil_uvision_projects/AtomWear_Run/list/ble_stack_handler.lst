L 1 "..\..\..\Software\Source\ble_lib\ble_stack_handler.c"
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#include "ble_stack_handler.h"
L 1 "..\..\..\Software\Include\ble_stack_handler.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup ble_stack_handler BLE Stack Event Handler
N * @{
N * @ingroup ble_sdk_lib
N * @brief Module for initializing the BLE stack, and propagating BLE stack events to the
N *        application.
N *
N * @details Use the USE_SCHEDULER parameter of the BLE_STACK_HANDLER_INIT() macro to select if the
N *          @ref app_scheduler is to be used or not.
N *
N * @note Even if the scheduler is not used, ble_stack_handler.h will include app_scheduler.h,
N *       so when compiling, app_scheduler.h must be available in one of the compiler include paths.
N */
N
N#ifndef BLE_STACK_HANDLER_H__
N#define BLE_STACK_HANDLER_H__
N
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 410000
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199901L)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 32 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "ble.h"
L 1 "..\..\..\Software\Include\ble.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_COMMON BLE SoftDevice Common
N  @{
N  @defgroup ble_api Events, type definitions and API calls
N  @{
N
N  @brief Module independent events, type definitions and API calls for the S110 SoftDevice.
N
N */
N
N#ifndef BLE_H__
N#define BLE_H__
N
N#include "ble_ranges.h"
L 1 "..\..\..\Software\Include\ble_ranges.h" 1
N/*
N  Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N
N  The information contained herein is confidential property of Nordic Semiconductor. The use,
N  copying, transfer or disclosure of such information is prohibited except by express written
N  agreement with Nordic Semiconductor.
N */
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_ranges Module specific SVC and event number subranges
N  @{
N
N  @brief Definition of SVC and event number subranges for each API module.
N
N  @note
N  SVCs and event numbers are split into subranges for each API module.
N  Each module receives its entire allocated range of SVC calls, whether implemented or not,
N  but return BLE_ERROR_NOT_SUPPORTED for unimplemented or undefined calls in its range.
N
N  Note that the symbols BLE_<module>_SVC_LAST is the end of the allocated SVC range,
N  rather than the last SVC function call actually defined and implemented.
N
N  Specific SVC and event values are defined in each module's ble_<module>.h file,
N  which defines names of each individual SVC code based on the range start value.
N*/
N
N#ifndef BLE_RANGES_H__
N#define BLE_RANGES_H__
N
N#define BLE_SVC_BASE           0x50
N#define BLE_SVC_LAST           0x5B       /* Total: 12. */
N
N#define BLE_RESERVED_SVC_BASE  0x5C
N#define BLE_RESERVED_SVC_LAST  0x5F       /* Total: 4. */
N
N#define BLE_GAP_SVC_BASE       0x60
N#define BLE_GAP_SVC_LAST       0x7F       /* Total: 32. */
N
N#define BLE_GATTC_SVC_BASE     0x80
N#define BLE_GATTC_SVC_LAST     0x9F       /* Total: 32. */
N
N#define BLE_GATTS_SVC_BASE     0xA0
N#define BLE_GATTS_SVC_LAST     0xAF       /* Total: 16. */
N
N#define BLE_L2CAP_SVC_BASE     0xB0
N#define BLE_L2CAP_SVC_LAST     0xBF       /* Total: 16. */
N
N
N#define BLE_EVT_INVALID        0x00
N
N#define BLE_EVT_BASE           0x01
N#define BLE_EVT_LAST           0x0F       /* Total: 15. */
N
N#define BLE_GAP_EVT_BASE       0x10
N#define BLE_GAP_EVT_LAST       0x2F       /* Total: 32. */
N
N#define BLE_GATTC_EVT_BASE     0x30
N#define BLE_GATTC_EVT_LAST     0x4F       /* Total: 32. */
N
N#define BLE_GATTS_EVT_BASE     0x50
N#define BLE_GATTS_EVT_LAST     0x6F       /* Total: 32. */
N
N#define BLE_L2CAP_EVT_BASE     0x70
N#define BLE_L2CAP_EVT_LAST     0x8F       /* Total: 32.  */
N
N#endif /* BLE_RANGES_H__ */
N
N/**
N  @}
N  @}
N*/
L 22 "..\..\..\Software\Include\ble.h" 2
N#include "ble_types.h"
L 1 "..\..\..\Software\Include\ble_types.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_COMMON
N  @{
N  @defgroup ble_types Common types and macro definitions
N  @{
N
N  @brief Common types and macro definitions for the S110 SoftDevice.
N */
N
N#ifndef BLE_TYPES_H__
N#define BLE_TYPES_H__
N
N#include <stdint.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999 */
N/* All rights reserved */
N
N/*
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N * '__int64' is used instead of 'long long' so that this header
N * can be used in --strict mode.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed       __int64 intmax_t;
Ntypedef unsigned       __int64 uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __ESCAPE__(~0x7fffffffffffffffll) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#define INTPTR_MIN (~0x7fffffff)
N
N    /* maximum value of pointer-holding signed integer type */
N#define INTPTR_MAX   2147483647
N
N    /* maximum value of pointer-holding unsigned integer type */
N#define UINTPTR_MAX  4294967295u
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#define PTRDIFF_MIN (~0x7fffffff)
N#define PTRDIFF_MAX   2147483647
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#define SIZE_MAX 4294967295u
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32)
X#if 0L
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __ESCAPE__(x ## ll)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __ESCAPE__(x ## ull)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif 
N  #endif /* __cplusplus */
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
N
N
N
L 21 "..\..\..\Software\Include\ble_types.h" 2
N
N/** @addtogroup BLE_COMMON_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_CONN_HANDLES BLE Connection Handles
N * @{ */
N#define BLE_CONN_HANDLE_INVALID 0xFFFF  /**< Invalid Connection Handle. */
N#define BLE_CONN_HANDLE_ALL     0xFFFE  /**< Applies to all Connection Handles. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_VALUES Assigned Values for BLE UUIDs
N * @{ */
N/* Generic UUIDs, applicable to all services */
N#define BLE_UUID_UNKNOWN                              0x0000 /**< Reserved UUID. */
N#define BLE_UUID_SERVICE_PRIMARY                      0x2800 /**< Primary Service. */
N#define BLE_UUID_SERVICE_SECONDARY                    0x2801 /**< Secondary Service. */
N#define BLE_UUID_SERVICE_INCLUDE                      0x2802 /**< Include. */
N#define BLE_UUID_CHARACTERISTIC                       0x2803 /**< Characteristic. */
N#define BLE_UUID_DESCRIPTOR_CHAR_EXT_PROP             0x2900 /**< Characteristic Extended Properties Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_USER_DESC            0x2901 /**< Characteristic User Description Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CLIENT_CHAR_CONFIG        0x2902 /**< Client Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_SERVER_CHAR_CONFIG        0x2903 /**< Server Characteristic Configuration Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_PRESENTATION_FORMAT  0x2904 /**< Characteristic Presentation Format Descriptor. */
N#define BLE_UUID_DESCRIPTOR_CHAR_AGGREGATE_FORMAT     0x2905 /**< Characteristic Aggregate Format Descriptor. */
N/* GATT specific UUIDs */
N#define BLE_UUID_GATT                                 0x1801 /**< Generic Attribute Profile. */
N#define BLE_UUID_GATT_CHARACTERISTIC_SERVICE_CHANGED  0x2A05 /**< Service Changed Characteristic. */
N/* GAP specific UUIDs */
N#define BLE_UUID_GAP                                  0x1800 /**< Generic Access Profile. */
N#define BLE_UUID_GAP_CHARACTERISTIC_DEVICE_NAME       0x2A00 /**< Device Name Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_APPEARANCE        0x2A01 /**< Appearance Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_PPF               0x2A02 /**< Peripheral Privacy Flag Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_RECONN_ADDR       0x2A03 /**< Reconnection Address Characteristic. */
N#define BLE_UUID_GAP_CHARACTERISTIC_PPCP              0x2A04 /**< Peripheral Preferred Connection Parameters Characteristic. */
N/** @} */
N
N
N/** @defgroup BLE_UUID_TYPES Types of UUID
N * @{ */
N#define BLE_UUID_TYPE_UNKNOWN       0x00 /**< Invalid UUID type. */
N#define BLE_UUID_TYPE_BLE           0x01 /**< Bluetooth SIG UUID (16-bit). */
N#define BLE_UUID_TYPE_VENDOR_BEGIN  0x02 /**< Vendor UUID types start at this index (128-bit). */
N/** @} */
N
N
N/** @defgroup BLE_APPEARANCES Bluetooth Appearance values
N *  @note Retrieved from http://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicViewer.aspx?u=org.bluetooth.characteristic.gap.appearance.xml
N * @{ */
N#define BLE_APPEARANCE_UNKNOWN                              0   /**< Unknown. */
N#define BLE_APPEARANCE_GENERIC_PHONE                        64  /**< Generic Phone. */
N#define BLE_APPEARANCE_GENERIC_COMPUTER                     128 /**< Generic Computer. */
N#define BLE_APPEARANCE_GENERIC_WATCH                        192 /**< Generic Watch. */
N#define BLE_APPEARANCE_WATCH_SPORTS_WATCH                   193 /**< Watch: Sports Watch. */
N#define BLE_APPEARANCE_GENERIC_CLOCK                        256 /**< Generic Clock. */
N#define BLE_APPEARANCE_GENERIC_DISPLAY                      320 /**< Generic Display. */
N#define BLE_APPEARANCE_GENERIC_REMOTE_CONTROL               384 /**< Generic Remote Control. */
N#define BLE_APPEARANCE_GENERIC_EYE_GLASSES                  448 /**< Generic Eye-glasses. */
N#define BLE_APPEARANCE_GENERIC_TAG                          512 /**< Generic Tag. */
N#define BLE_APPEARANCE_GENERIC_KEYRING                      576 /**< Generic Keyring. */
N#define BLE_APPEARANCE_GENERIC_MEDIA_PLAYER                 640 /**< Generic Media Player. */
N#define BLE_APPEARANCE_GENERIC_BARCODE_SCANNER              704 /**< Generic Barcode Scanner. */
N#define BLE_APPEARANCE_GENERIC_THERMOMETER                  768 /**< Generic Thermometer. */
N#define BLE_APPEARANCE_THERMOMETER_EAR                      769 /**< Thermometer: Ear. */
N#define BLE_APPEARANCE_GENERIC_HEART_RATE_SENSOR            832 /**< Generic Heart rate Sensor. */
N#define BLE_APPEARANCE_HEART_RATE_SENSOR_HEART_RATE_BELT    833 /**< Heart Rate Sensor: Heart Rate Belt. */
N#define BLE_APPEARANCE_GENERIC_BLOOD_PRESSURE               896 /**< Generic Blood Pressure. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_ARM                   897 /**< Blood Pressure: Arm. */
N#define BLE_APPEARANCE_BLOOD_PRESSURE_WRIST                 898 /**< Blood Pressure: Wrist. */
N#define BLE_APPEARANCE_GENERIC_HID                          960 /**< Human Interface Device (HID). */
N#define BLE_APPEARANCE_HID_KEYBOARD                         961 /**< Keyboard (HID Subtype). */
N#define BLE_APPEARANCE_HID_MOUSE                            962 /**< Mouse (HID Subtype). */
N#define BLE_APPEARANCE_HID_JOYSTICK                         963 /**< Joystiq (HID Subtype). */
N#define BLE_APPEARANCE_HID_GAMEPAD                          964 /**< Gamepad (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITIZERSUBTYPE                 965 /**< Digitizer Tablet (HID Subtype). */
N#define BLE_APPEARANCE_HID_CARD_READER                      966 /**< Card Reader (HID Subtype). */
N#define BLE_APPEARANCE_HID_DIGITAL_PEN                      967 /**< Digital Pen (HID Subtype). */
N#define BLE_APPEARANCE_HID_BARCODE                          968 /**< Barcode Scanner (HID Subtype). */
N#define BLE_APPEARANCE_GENERIC_GLUCOSE_METER               1024 /**< Generic Glucose Meter. */
N#define BLE_APPEARANCE_GENERIC_RUNNING_WALKING_SENSOR      1088 /**< Generic Running Walking Sensor. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_IN_SHOE      1089 /**< Running Walking Sensor: In-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_SHOE      1090 /**< Running Walking Sensor: On-Shoe. */
N#define BLE_APPEARANCE_RUNNING_WALKING_SENSOR_ON_HIP       1091 /**< Running Walking Sensor: On-Hip. */
N#define BLE_APPEARANCE_GENERIC_CYCLING                     1152 /**< Generic Cycling. */
N#define BLE_APPEARANCE_CYCLING_CYCLING_COMPUTER            1153 /**< Cycling: Cycling Computer. */
N#define BLE_APPEARANCE_CYCLING_SPEED_SENSOR                1154 /**< Cycling: Speed Sensor. */
N#define BLE_APPEARANCE_CYCLING_CADENCE_SENSOR              1155 /**< Cycling: Cadence Sensor. */
N#define BLE_APPEARANCE_CYCLING_POWER_SENSOR                1156 /**< Cycling: Power Sensor. */
N#define BLE_APPEARANCE_CYCLING_SPEED_CADENCE_SENSOR        1157 /**< Cycling: Speed and Cadence Sensor. */
N/** @} */
N
N/** @brief Set .type and .uuid fields of ble_uuid_struct to specified uuid value. */
N#define BLE_UUID_BLE_ASSIGN(instance, value) do {\
N            instance.type = BLE_UUID_TYPE_BLE; \
N            instance.uuid = value;} while(0)
X#define BLE_UUID_BLE_ASSIGN(instance, value) do {            instance.type = BLE_UUID_TYPE_BLE;             instance.uuid = value;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t pointer. Both pointers must be valid/non-null. */
N#define BLE_UUID_COPY_PTR(dst, src) do {\
N            (dst)->type = (src)->type; \
N            (dst)->uuid = (src)->uuid;} while(0)
X#define BLE_UUID_COPY_PTR(dst, src) do {            (dst)->type = (src)->type;             (dst)->uuid = (src)->uuid;} while(0)
N
N/** @brief Copy type and uuid members from src to dst ble_uuid_t struct. */
N#define BLE_UUID_COPY_INST(dst, src) do {\
N            (dst).type = (src).type; \
N            (dst).uuid = (src).uuid;} while(0)
X#define BLE_UUID_COPY_INST(dst, src) do {            (dst).type = (src).type;             (dst).uuid = (src).uuid;} while(0)
N
N/** @brief Compare for equality both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_EQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
X#define BLE_UUID_EQ(p_uuid1, p_uuid2)             (((p_uuid1)->type == (p_uuid2)->type) && ((p_uuid1)->uuid == (p_uuid2)->uuid))
N
N/** @brief Compare for difference both type and uuid members of two (valid, non-null) ble_uuid_t pointers. */
N#define BLE_UUID_NEQ(p_uuid1, p_uuid2) \
N            (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
X#define BLE_UUID_NEQ(p_uuid1, p_uuid2)             (((p_uuid1)->type != (p_uuid2)->type) || ((p_uuid1)->uuid != (p_uuid2)->uuid))
N
N/** @} */
N
N/** @brief 128 bit UUID values. */
Ntypedef struct
N{ 
N    unsigned char uuid128[16];
N} ble_uuid128_t;
N
N/** @brief  Bluetooth Low Energy UUID type, encapsulates both 16-bit and 128-bit UUIDs. */
Ntypedef struct
N{
N    uint16_t    uuid; /**< 16-bit UUID value or octets 12-13 of 128-bit UUID. */
N    uint8_t     type; /**< UUID type, see @ref BLE_UUID_TYPES. */
N} ble_uuid_t;
N
N
N
N#endif /* BLE_TYPES_H__ */
N
N/**
N  @}
N  @}
N*/
L 23 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gap.h"
L 1 "..\..\..\Software\Include\ble_gap.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GAP Generic Access Profile (GAP)
N  @{
N  @brief Definitions and prototypes for the GAP interface.
N */
N
N#ifndef BLE_GAP_H__
N#define BLE_GAP_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
L 1 "..\..\..\Software\Include\nrf_svc.h" 1
N#ifndef NRF_SVC__
N#define NRF_SVC__
N
N#ifdef SVCALL_AS_NORMAL_FUNCTION
S#define SVCALL(number, return_type, signature) return_type signature
N#else
N
N#ifndef SVCALL
N#if defined (__CC_ARM)
X#if 1L
N#define SVCALL(number, return_type, signature) return_type __svc(number) signature
N#elif defined (__GNUC__)
S#define SVCALL(number, return_type, signature) \
S  _Pragma("GCC diagnostic ignored \"-Wreturn-type\"") \
S  _Pragma("GCC diagnostic ignored \"-Wunused-function\"") \
S  __attribute__((naked)) static return_type signature \
S  { \
S    __asm( \
S        "svc %0\n" \
S        "bx r14" : : "I" (number) : "r0" \
S    ); \
S  }
X#define SVCALL(number, return_type, signature)   _Pragma("GCC diagnostic ignored \"-Wreturn-type\"")   _Pragma("GCC diagnostic ignored \"-Wunused-function\"")   __attribute__((naked)) static return_type signature   {     __asm(         "svc %0\n"         "bx r14" : : "I" (number) : "r0"     );   }
S#elif defined (__ICCARM__)
S#define PRAGMA(x) _Pragma(#x)
S#define SVCALL(number, return_type, signature) \
SPRAGMA(swi_number = number) \
S __swi return_type signature;
X#define SVCALL(number, return_type, signature) PRAGMA(swi_number = number)  __swi return_type signature;
S#else
S#define SVCALL(number, return_type, signature) return_type signature  
N#endif
N#endif	// SVCALL
N	
N#endif	// SVCALL_AS_NORMAL_FUNCTION
N#endif	// NRF_SVC__
L 20 "..\..\..\Software\Include\ble_gap.h" 2
N
N/**
N * @brief GAP API SVC numbers.
N */
Nenum BLE_GAP_SVCS
N{
N  SD_BLE_GAP_ADDRESS_SET  = BLE_GAP_SVC_BASE,  /**< Set own Bluetooth Address. */
X  SD_BLE_GAP_ADDRESS_SET  = 0x60,   
N  SD_BLE_GAP_ADDRESS_GET,                      /**< Get own Bluetooth Address. */
N  SD_BLE_GAP_ADV_DATA_SET,                     /**< Set Advertisement Data. */
N  SD_BLE_GAP_ADV_START,                        /**< Start Advertising. */
N  SD_BLE_GAP_ADV_STOP,                         /**< Stop Advertising. */
N  SD_BLE_GAP_CONN_PARAM_UPDATE,                /**< Connection Parameter Update. */
N  SD_BLE_GAP_DISCONNECT,                       /**< Disconnect. */
N  SD_BLE_GAP_TX_POWER_SET,                     /**< Set TX Power. */
N  SD_BLE_GAP_APPEARANCE_SET,                   /**< Set Appearance. */
N  SD_BLE_GAP_APPEARANCE_GET,                   /**< Get Appearance. */
N  SD_BLE_GAP_PPCP_SET,                         /**< Set PPCP. */
N  SD_BLE_GAP_PPCP_GET,                         /**< Get PPCP. */
N  SD_BLE_GAP_DEVICE_NAME_SET,                  /**< Set Device Name. */
N  SD_BLE_GAP_DEVICE_NAME_GET,                  /**< Get Device Name. */
N  SD_BLE_GAP_AUTHENTICATE,                     /**< Initiate Pairing/Bonding. */
N  SD_BLE_GAP_SEC_PARAMS_REPLY,                 /**< Reply with Security Parameters. */
N  SD_BLE_GAP_AUTH_KEY_REPLY,                   /**< Reply with an authentication key. */
N  SD_BLE_GAP_SEC_INFO_REPLY,                   /**< Reply with Security Information. */
N  SD_BLE_GAP_CONN_SEC_GET,                     /**< Obtain connection security level. */
N  SD_BLE_GAP_RSSI_START,                       /**< Start reporting of changes in RSSI. */ 
N  SD_BLE_GAP_RSSI_STOP,                        /**< Stop reporting of changes in RSSI. */ 
N};
N
N
N/** @addtogroup BLE_GAP_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GAP SVC return values specific to GAP
N * @{ */
N#define BLE_ERROR_GAP_UUID_LIST_MISMATCH            (NRF_GAP_ERR_BASE + 0x000)  /**< UUID list does not contain an integral number of UUIDs. */
N#define BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST   (NRF_GAP_ERR_BASE + 0x001)  /**< Use of Whitelist not permitted with discoverable advertising. */
N#define BLE_ERROR_GAP_INVALID_BLE_ADDR              (NRF_GAP_ERR_BASE + 0x002)  /**< The upper two bits of the address do not correspond to the specified address type. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ROLES GAP Roles
N * @note Not explicitly used in peripheral API, but will be relevant for central API.
N * @{ */
N#define BLE_GAP_ROLE_INVALID     0x0            /**< Invalid Role. */
N#define BLE_GAP_ROLE_PERIPH      0x1            /**< Peripheral Role. */
N#define BLE_GAP_ROLE_CENTRAL     0x2            /**< Central Role. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_TIMEOUT_SOURCES GAP Timeout sources
N * @{ */
N#define BLE_GAP_TIMEOUT_SRC_ADVERTISEMENT              0x00 /**< Advertisement timeout. */
N#define BLE_GAP_TIMEOUT_SRC_SECURITY_REQUEST           0x01 /**< Security request timeout. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADDR_TYPES GAP Address types
N * @{ */
N#define BLE_GAP_ADDR_TYPE_PUBLIC                        0x00 /**< Public address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_STATIC                 0x01 /**< Random Static address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_RESOLVABLE     0x02 /**< Private Resolvable address. */
N#define BLE_GAP_ADDR_TYPE_RANDOM_PRIVATE_NON_RESOLVABLE 0x03 /**< Private Non-Resolvable address. */
N/** @} */
N
N
N/** @brief BLE address length. */
N#define BLE_GAP_ADDR_LEN            6
N
N
N/** @defgroup BLE_GAP_AD_TYPE_DEFINITIONS GAP Advertising and Scan Response Data format
N *  @note Found at https://www.bluetooth.org/Technical/AssignedNumbers/generic_access_profile.htm
N * @{ */
N#define BLE_GAP_AD_TYPE_FLAGS                               0x01 /**< Flags for discoverability. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 /**< Partial list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 /**< Complete list of 16 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 /**< Partial list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 /**< Complete list of 32 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 /**< Partial list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 /**< Complete list of 128 bit service UUIDs. */
N#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 /**< Short local device name. */
N#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 /**< Complete local device name. */
N#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A /**< Transmit power level. */
N#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D /**< Class of device. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E /**< Simple Pairing Hash C. */
N#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F /**< Simple Pairing Randomizer R. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 /**< Security Manager TK Value. */
N#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 /**< Security Manager Out Of Band Flags. */
N#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 /**< Slave Connection Interval Range. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 /**< List of 16-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 /**< List of 128-bit Service Solicitation UUIDs. */
N#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 /**< Service Data. */
N#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 /**< Public Target Address. */
N#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 /**< Random Target Address. */
N#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 /**< Appearance. */
N#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF /**< Manufacturer Specific Data. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_FLAGS GAP Advertisement Flags
N * @{ */
N#define BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE         (0x01)   /**< LE Limited Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE         (0x02)   /**< LE General Discoverable Mode. */
N#define BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED         (0x04)   /**< BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_CONTROLLER         (0x08)   /**< Simultaneous LE and BR/EDR, Controller. */
N#define BLE_GAP_ADV_FLAG_LE_BR_EDR_HOST               (0x10)   /**< Simultaneous LE and BR/EDR, Host. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_LIMITED_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_LIMITED_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE Limited Discoverable Mode, BR/EDR not supported. */
N#define BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE   (BLE_GAP_ADV_FLAG_LE_GENERAL_DISC_MODE | BLE_GAP_ADV_FLAG_BR_EDR_NOT_SUPPORTED)   /**< LE General Discoverable Mode, BR/EDR not supported. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_INTERVALS GAP Advertising interval max and min
N * @{ */
N#define BLE_GAP_ADV_INTERVAL_MIN        0x0020 /**< Minimum Advertising interval in 625 us units, i.e. 20 ms. */
N#define BLE_GAP_ADV_NONCON_INTERVAL_MIN 0x00A0 /**< Minimum Advertising interval in 625 us units for non connectable mode, i.e. 100 ms. */
N#define BLE_GAP_ADV_INTERVAL_MAX        0x4000 /**< Maximum Advertising interval in 625 us units, i.e. 10.24 s. */
N /** @}  */
N
N
N/** @brief Maximum size of advertising data in octets. */
N#define  BLE_GAP_ADV_MAX_SIZE       31
N
N
N/** @defgroup BLE_GAP_ADV_TYPES GAP Advertising types
N * @{ */
N#define BLE_GAP_ADV_TYPE_ADV_IND          0x00   /**< Connectable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_DIRECT_IND   0x01   /**< Connectable directed. */
N#define BLE_GAP_ADV_TYPE_ADV_SCAN_IND     0x02   /**< Scannable undirected. */
N#define BLE_GAP_ADV_TYPE_ADV_NONCONN_IND  0x03   /**< Non connectable undirected. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_FILTER_POLICIES GAP Advertising filter policies
N * @{ */
N#define BLE_GAP_ADV_FP_ANY                0x00   /**< Allow scan requests and connect requests from any device. */
N#define BLE_GAP_ADV_FP_FILTER_SCANREQ     0x01   /**< Filter scan requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_CONNREQ     0x02   /**< Filter connect requests with whitelist. */
N#define BLE_GAP_ADV_FP_FILTER_BOTH        0x03   /**< Filter both scan and connect requests with whitelist. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_ADV_TIMEOUT_VALUES GAP Advertising timeout values
N * @{ */
N#define BLE_GAP_ADV_TIMEOUT_LIMITED_MAX      180 /**< Maximum advertising time in limited discoverable mode (TGAP(lim_adv_timeout) = 180s in spec (Addendum 2)). */
N#define BLE_GAP_ADV_TIMEOUT_GENERAL_UNLIMITED  0 /**< Unlimited advertising in general discoverable mode. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_DISC_MODES GAP Discovery modes
N * @{ */
N#define BLE_GAP_DISC_MODE_NOT_DISCOVERABLE  0x00   /**< Not discoverable discovery Mode. */
N#define BLE_GAP_DISC_MODE_LIMITED           0x01   /**< Limited Discovery Mode. */
N#define BLE_GAP_DISC_MODE_GENERAL           0x02   /**< General Discovery Mode. */
N/** @} */
N
N/** @defgroup BLE_GAP_IO_CAPS GAP IO Capabilities
N * @{ */
N#define BLE_GAP_IO_CAPS_DISPLAY_ONLY      0x00   /**< Display Only. */
N#define BLE_GAP_IO_CAPS_DISPLAY_YESNO     0x01   /**< Display and Yes/No entry. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_ONLY     0x02   /**< Keyboard Only. */
N#define BLE_GAP_IO_CAPS_NONE              0x03   /**< No I/O capabilities. */
N#define BLE_GAP_IO_CAPS_KEYBOARD_DISPLAY  0x04   /**< Keyboard and Display. */
N/** @} */
N
N
N/** @defgroup BLE_GAP_AUTH_KEY_TYPES GAP Authentication Key Types
N * @{ */
N#define BLE_GAP_AUTH_KEY_TYPE_NONE        0x00   /**< No key (may be used to reject). */
N#define BLE_GAP_AUTH_KEY_TYPE_PASSKEY     0x01   /**< 6-digit Passkey. */
N#define BLE_GAP_AUTH_KEY_TYPE_OOB         0x02   /**< Out Of Band data. */
N/** @} */
N
N/** @defgroup BLE_GAP_SEC_STATUS GAP Security status
N * @{ */
N#define BLE_GAP_SEC_STATUS_SUCCESS                0x00  /**< Successful parameters. */
N#define BLE_GAP_SEC_STATUS_TIMEOUT                0x01  /**< Procedure timed out. */
N#define BLE_GAP_SEC_STATUS_PDU_INVALID            0x02  /**< Invalid PDU received. */
N#define BLE_GAP_SEC_STATUS_PASSKEY_ENTRY_FAILED   0x81  /**< Passkey entry failed (user cancelled or other). */
N#define BLE_GAP_SEC_STATUS_OOB_NOT_AVAILABLE      0x82  /**< Out of Band Key not available. */
N#define BLE_GAP_SEC_STATUS_AUTH_REQ               0x83  /**< Authentication requirements not met. */
N#define BLE_GAP_SEC_STATUS_CONFIRM_VALUE          0x84  /**< Confirm value failed. */
N#define BLE_GAP_SEC_STATUS_PAIRING_NOT_SUPP       0x85  /**< Pairing not supported.  */
N#define BLE_GAP_SEC_STATUS_ENC_KEY_SIZE           0x86  /**< Encryption key size. */
N#define BLE_GAP_SEC_STATUS_SMP_CMD_UNSUPPORTED    0x87  /**< Unsupported SMP command. */
N#define BLE_GAP_SEC_STATUS_UNSPECIFIED            0x88  /**< Unspecified reason. */
N#define BLE_GAP_SEC_STATUS_REPEATED_ATTEMPTS      0x89  /**< Too little time elapsed since last attempt. */
N#define BLE_GAP_SEC_STATUS_INVALID_PARAMS         0x8A  /**< Invalid parameters. */
N/** @} */
N
N/** @defgroup BLE_GAP_SEC_STATUS_SOURCES GAP Security status sources
N * @{ */
N#define BLE_GAP_SEC_STATUS_SOURCE_LOCAL           0x00  /**< Local failure. */
N#define BLE_GAP_SEC_STATUS_SOURCE_REMOTE          0x01  /**< Remote failure. */
N/** @} */
N
N/** @defgroup BLE_GAP_CP_LIMITS GAP Connection Parameters Limits
N * @{ */
N#define BLE_GAP_CP_MIN_CONN_INTVL_NONE           0xFFFF  /**< No new minimum connction interval specified in connect parameters. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MIN            0x0006  /**< Lowest mimimum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MIN_CONN_INTVL_MAX            0x0C80  /**< Highest minimum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_NONE           0xFFFF  /**< No new maximum connction interval specified in connect parameters. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MIN            0x0006  /**< Lowest maximum connection interval permitted, in units of 1.25 ms, i.e. 7.5 ms. */
N#define BLE_GAP_CP_MAX_CONN_INTVL_MAX            0x0C80  /**< Highest maximum connection interval permitted, in units of 1.25 ms, i.e. 4 s. */
N#define BLE_GAP_CP_SLAVE_LATENCY_MAX             0x03E8  /**< Highest slave latency permitted, in connection events. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_NONE         0xFFFF  /**< No new supervision timeout specified in connect parameters. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MIN          0x000A  /**< Lowest supervision timeout permitted, in units of 10 ms, i.e. 100 ms. */
N#define BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX          0x0C80  /**< Highest supervision timeout permitted, in units of 10 ms, i.e. 32 s. */
N/** @} */
N
N
N/**@brief GAP device name maximum writable length. */
N#define BLE_GAP_DEVNAME_MAX_WR_LEN        20
N
N/**@brief GAP device name maximum length. */
N#define BLE_GAP_DEVNAME_MAX_LEN           31
N
N
N/** @defgroup BLE_GAP_CONN_SEC_MODE_SET_MACROS GAP attribute security requirement setters
N *
N * See @ref ble_gap_conn_sec_mode_t.
N * @{ */
N/** @brief Set sec_mode pointed to by ptr to have no access rights.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_NO_ACCESS(ptr)         do {(ptr)->sm = 0; (ptr)->lv = 0;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require no protection, open link.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_OPEN(ptr)              do {(ptr)->sm = 1; (ptr)->lv = 1;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require encryption, but no MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_NO_MITM(ptr)       do {(ptr)->sm = 1; (ptr)->lv = 2;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require encryption and MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_ENC_WITH_MITM(ptr)     do {(ptr)->sm = 1; (ptr)->lv = 3;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require signing or encryption, no MITM protection needed.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_NO_MITM(ptr)    do {(ptr)->sm = 2; (ptr)->lv = 1;} while(0)
N/** @brief Set sec_mode pointed to by ptr to require signing or encryption with MITM protection.*/
N#define BLE_GAP_CONN_SEC_MODE_SET_SIGNED_WITH_MITM(ptr)  do {(ptr)->sm = 2; (ptr)->lv = 2;} while(0)
N/** @} */
N
N
N/**@brief GAP Security Key Length. */
N#define BLE_GAP_SEC_KEY_LEN 16
N
N/**@brief Maximum amount of addresses in a whitelist. */
N#define BLE_GAP_WHITELIST_ADDR_MAX_COUNT (8)
N
N/**@brief Maximum amount of IRKs in a whitelist.
N * @note  The number of IRKs is limited to 8, even if the hardware supports more.
N */
N#define BLE_GAP_WHITELIST_IRK_MAX_COUNT (8)
N
N/** @defgroup GAP_SEC_MODES GAP Security Modes
N * @{ */
N#define BLE_GAP_SEC_MODE 0x00 /**< No key (may be used to reject). */
N
N/** @} */
N
N
N/** @} */
N
N/**@brief Bluetooth Low Energy address. */
Ntypedef struct
N{
N  uint8_t addr_type;                    /**< See @ref BLE_GAP_ADDR_TYPES. */
N  uint8_t addr[BLE_GAP_ADDR_LEN];       /**< 48-bit address, LSB format. */
X  uint8_t addr[6];        
N} ble_gap_addr_t;
N
N
N/**@brief GAP connection parameters. */
Ntypedef struct
N{
N  uint16_t min_conn_interval;         /**< Minimum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t max_conn_interval;         /**< Maximum Connection Interval in 1.25 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t slave_latency;             /**< Slave Latency in number of connection events, see @ref BLE_GAP_CP_LIMITS.*/
N  uint16_t conn_sup_timeout;          /**< Connection Supervision Timeout in 10 ms units, see @ref BLE_GAP_CP_LIMITS.*/
N} ble_gap_conn_params_t;
N
N
N/**@brief GAP link requirements.
N *
N * See Bluetooth Core specification, Volume 3 Part C 10.2 for details.
N *
N * Security Mode 0 Level 0: No access permissions at all (this level is not defined by the Bluetooth Core specification).\n
N * Security Mode 1 Level 1: No security is needed (aka open link).\n
N * Security Mode 1 Level 2: Encrypted link required, MITM protection not necessary.\n
N * Security Mode 1 Level 3: MITM protected encrypted link required.\n
N * Security Mode 2 Level 1: Signing or encryption required, MITM protection not necessary.\n
N * Security Mode 2 Level 2: MITM protected signing required, unless link is MITM protected encrypted.\n
N */
Ntypedef struct
N{
N  uint8_t sm : 4;                     /**< Security Mode (1 or 2), 0 for no permissions at all. */
N  uint8_t lv : 4;                     /**< Level (1, 2 or 3), 0 for no permissions at all. */
N
N} ble_gap_conn_sec_mode_t;
N
N
N
N/**@brief GAP connection security status.*/
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t sec_mode;           /**< Currently active security mode for this connection.*/
N  uint8_t                 encr_key_size;      /**< Length of currently active encryption key, 7 to 16 octets.*/
N} ble_gap_conn_sec_t;
N
N
N
N/**@brief Identity Resolving Key. */
Ntypedef struct
N{
N  uint8_t irk[BLE_GAP_SEC_KEY_LEN];   /**< Array containing IRK. */
X  uint8_t irk[16];    
N} ble_gap_irk_t;
N
N
N/**@brief White list structure. */
Ntypedef struct
N{
N  ble_gap_addr_t   ** pp_addrs;        /**< Pointer to array of device address pointers, pointing to addresses to be used in whitelist. NULL if none are given. */
N  uint8_t             addr_count;      /**< Count of device addresses in array, up to @ref BLE_GAP_WHITELIST_ADDR_MAX_COUNT. */
N  ble_gap_irk_t    ** pp_irks;         /**< Pointer to array of Identity Resolving Key (IRK) pointers, each pointing to an IRK in the whitelist. NULL if none are given. */
N  uint8_t             irk_count;       /**< Count of IRKs in array, up to @ref BLE_GAP_WHITELIST_IRK_MAX_COUNT. */
N} ble_gap_whitelist_t;
N
N
N/**@brief GAP advertising parameters.*/
Ntypedef struct
N{
N  uint8_t               type;                 /**< See @ref BLE_GAP_ADV_TYPES. */
N  ble_gap_addr_t*       p_peer_addr;          /**< For BLE_GAP_CONN_MODE_DIRECTED mode only, known peer address. */
N  uint8_t               fp;                   /**< Filter Policy, see @ref BLE_GAP_ADV_FILTER_POLICIES. */
N  ble_gap_whitelist_t * p_whitelist;          /**< Pointer to whitelist, NULL if none is given. */
N  uint16_t              interval;             /**< Advertising interval between 0x0020 and 0x4000 in 0.625 ms units (20ms to 10.24s), see @ref BLE_GAP_ADV_INTERVALS. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
N  uint16_t              timeout;              /**< Advertising timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. See also @ref BLE_GAP_ADV_TIMEOUT_VALUES. This parameter must be set to 0 if type equals @ref BLE_GAP_ADV_TYPE_ADV_DIRECT_IND. */
N} ble_gap_adv_params_t;
N
N
N/**@brief GAP scanning parameters. */
Ntypedef struct
N{
N  uint8_t    filter;                    /**< Filter based on discovery mode, see @ref BLE_GAP_DISC_MODES. */
N  uint8_t    active    : 1;             /**< If 1, perform active scanning (scan requests). */
N  uint8_t    selective : 1;             /**< If 1, ignore unknown devices (non white listed). */
N  uint16_t   interval;                  /**< Scan interval between 0x0020 and 0x4000 in 0.625ms units (20ms to 10.24s). */
N  uint16_t   window;                    /**< Scan window between 0x0004 and 0x4000 in 0.625ms units (2.5ms to 10.24s). */
N  uint16_t   timeout;                   /**< Scan timeout between 0x0001 and 0x3FFF in seconds, 0x0000 disables timeout. */
N} ble_gap_scan_params_t;
N
N
N/**@brief GAP security parameters. */
Ntypedef struct
N{
N  uint16_t   timeout;                   /**< Timeout for SMP transactions or Security Request in seconds, see @ref sd_ble_gap_authenticate and @ref sd_ble_gap_sec_params_reply for more information. */
N  uint8_t    bond    : 1;               /**< Perform bonding. */
N  uint8_t    mitm    : 1;               /**< Man In The Middle protection required. */
N  uint8_t    io_caps : 3;               /**< IO capabilities, see @ref BLE_GAP_IO_CAPS. */
N  uint8_t    oob     : 1;               /**< Out Of Band data available. */
N  uint8_t    min_key_size;              /**< Minimum encryption key size in octets between 7 and 16. */
N  uint8_t    max_key_size;              /**< Maximum encryption key size in octets between min_key_size and 16. */
N} ble_gap_sec_params_t;
N
N
N/**@brief GAP Encryption Information. */
Ntypedef struct
N{
N  uint16_t  div;                        /**< Encryption Diversifier. */
N  uint8_t   ltk[BLE_GAP_SEC_KEY_LEN];   /**< Long Term Key. */
X  uint8_t   ltk[16];    
N  uint8_t   auth : 1;                   /**< Authenticated Key. */
N  uint8_t   ltk_len : 7;                /**< LTK length in octets. */
N} ble_gap_enc_info_t;
N
N
N/**@brief GAP Master Identification. */
Ntypedef struct
N{
N  uint16_t  ediv;                       /**< Encrypted Diversifier. */
N  uint8_t   rand[8];                    /**< Random Number. */
N} ble_gap_master_id_t;
N
N
N/**@brief GAP Identity Information. */
Ntypedef struct
N{
N  ble_gap_addr_t  addr;                       /**< Bluetooth address to which this key applies. */
N  uint8_t         irk[BLE_GAP_SEC_KEY_LEN];   /**< Identity Resolution Key. */
X  uint8_t         irk[16];    
N} ble_gap_id_info_t;
N
N
N/**@brief GAP Signing Information. */
Ntypedef struct
N{
N  uint8_t   csrk[BLE_GAP_SEC_KEY_LEN]; /* Connection Signature Resolving Key. */
X  uint8_t   csrk[16];  
N} ble_gap_sign_info_t;
N
N
N
N/**
N * @brief GAP Event IDs.
N * Those IDs uniquely identify an event coming from the stack to the application.
N */
Nenum BLE_GAP_EVTS
N{
N  BLE_GAP_EVT_CONNECTED  = BLE_GAP_EVT_BASE,    /**< Connection established. */
X  BLE_GAP_EVT_CONNECTED  = 0x10,     
N  BLE_GAP_EVT_DISCONNECTED,                     /**< Disconnected from peer. */
N  BLE_GAP_EVT_CONN_PARAM_UPDATE,                /**< Connection Parameters updated. */
N  BLE_GAP_EVT_SEC_PARAMS_REQUEST,               /**< Request to provide security parameters. */
N  BLE_GAP_EVT_SEC_INFO_REQUEST,                 /**< Request to provide security information. */
N  BLE_GAP_EVT_PASSKEY_DISPLAY,                  /**< Request to display a passkey to the user. */
N  BLE_GAP_EVT_AUTH_KEY_REQUEST,                 /**< Request to provide an authentication key. */
N  BLE_GAP_EVT_AUTH_STATUS,                      /**< Authentication procedure completed with status. */
N  BLE_GAP_EVT_CONN_SEC_UPDATE,                  /**< Connection security updated. */
N  BLE_GAP_EVT_TIMEOUT,                          /**< Timeout expired. */
N  BLE_GAP_EVT_RSSI_CHANGED,                     /**< Signal strength measurement report. */
N};
N
N
N/** @brief Event data for connected event. */
Ntypedef struct
N{
N  ble_gap_addr_t        peer_addr;              /**< Bluetooth address of the peer device. */
N  uint8_t               irk_match :1;           /**< If 1, peer device's address resolved using an IRK. */
N  uint8_t               irk_match_idx  :7;      /**< Index in IRK list where the address was matched. */
N  ble_gap_conn_params_t conn_params;            /**< GAP Connection Parameters. */
N} ble_gap_evt_connected_t;
N
N
N/** @brief Event data for disconnected event. */
Ntypedef struct
N{
N  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
N  uint8_t reason;                               /**< HCI error code. */
N} ble_gap_evt_disconnected_t;
N
N
N/** @brief Event data for connection parameter update event. */
Ntypedef struct
N{
N  ble_gap_conn_params_t conn_params;            /**<  GAP Connection Parameters. */
N} ble_gap_evt_conn_param_update_t;
N
N
N/** @brief Event data for security parameters request event. */
Ntypedef struct
N{
N  ble_gap_sec_params_t peer_params;             /**< Initiator Security Parameters. */
N} ble_gap_evt_sec_params_request_t;
N
N
N/** @brief Event data for securito info request event. */
Ntypedef struct
N{
N  ble_gap_addr_t peer_addr;                     /**< Bluetooth address of the peer device. */
N  uint16_t       div;                           /**< Encryption diversifier for LTK lookup. */
N  uint8_t        enc_info  : 1;                 /**< If 1, Encryption Information required. */
N  uint8_t        id_info   : 1;                 /**< If 1, Identity Information required. */
N  uint8_t        sign_info : 1;                 /**< If 1, Signing Information required. */
N} ble_gap_evt_sec_info_request_t;
N
N
N/** @brief Event data for passkey display event. */
Ntypedef struct
N{
N  uint8_t passkey[6];                           /**< 6-digit passkey in ASCII ('0'-'9' digits only). */
N} ble_gap_evt_passkey_display_t;
N
N
N/** @brief Event data for authentication key request event. */
Ntypedef struct
N{
N  uint8_t key_type;                             /**< See @ref BLE_GAP_AUTH_KEY_TYPES. */
N} ble_gap_evt_auth_key_request_t;
N
N
N/** @brief Security levels supported.
N *  @note See Bluetooth Specification Version 4.0 Volume 3, Chapter 10.
N*/
Ntypedef struct
N{
N  uint8_t lv1 : 1;                              /**< If 1: Level 1 is supported. */
N  uint8_t lv2 : 1;                              /**< If 1: Level 2 is supported. */
N  uint8_t lv3 : 1;                              /**< If 1: Level 3 is supported. */
N} ble_gap_sec_levels_t;
N
N
N/** @brief Keys that have been exchanged. */
Ntypedef struct
N{
N  uint8_t ltk       : 1;                        /**< Long Term Key. */
N  uint8_t ediv_rand : 1;                        /**< Encrypted Diversifier and Random value. */
N  uint8_t irk       : 1;                        /**< Identity Resolving Key. */
N  uint8_t address   : 1;                        /**< Public or static random address. */
N  uint8_t csrk      : 1;                        /**< Connection Signature Resolving Key. */
N} ble_gap_sec_keys_t;
N
N
N/** @brief Event data for authentication status event. */
Ntypedef struct
N{
N  uint8_t               auth_status;            /**< Authentication status, see @ref BLE_GAP_SEC_STATUS. */
N  uint8_t               error_src;              /**< On error, source that caused the failure, see @ref BLE_GAP_SEC_STATUS_SOURCES. */
N  ble_gap_sec_levels_t  sm1_levels;             /**< Levels supported in Security Mode 1. */
N  ble_gap_sec_levels_t  sm2_levels;             /**< Levels supported in Security Mode 2. */
N  ble_gap_sec_keys_t    periph_kex;             /**< Bitmap stating which keys were exchanged (distributed) by the peripheral. */
N  ble_gap_sec_keys_t    central_kex;            /**< Bitmap stating which keys were exchanged (distributed) by the central. */
N  struct periph_keys_t
N  {
N    ble_gap_enc_info_t    enc_info;             /**< Peripheral's Encryption information. */
N  } periph_keys;                                /**< Actual keys distributed from the Peripheral to the Central. */ 
N  struct central_keys_t
N  {
N    ble_gap_irk_t         irk;                  /**< Central's IRK. */
N    ble_gap_addr_t        id_info;              /**< Central's Identity Info. */
N  } central_keys;                               /**< Actual keys distributed from the Central to the Peripheral. */
N} ble_gap_evt_auth_status_t;
N
N
N/** @brief Event data for connection security update event. */
Ntypedef struct
N{
N  ble_gap_conn_sec_t conn_sec;                  /**< Connection security level. */
N} ble_gap_evt_conn_sec_update_t;
N
N
N/** @brief Event data for timeout event. */
Ntypedef struct
N{
N  uint8_t src;                                  /**< Source of timeout event, see @ref BLE_GAP_TIMEOUT_SOURCES. */
N} ble_gap_evt_timeout_t;
N
N
N/** @brief Event data for advertisement report event. */
Ntypedef struct
N{
N  int8_t  rssi;                               /**< Received Signal Strength Indication in dBm. */
N} ble_gap_evt_rssi_changed_t;
N
N
N
N/**@brief GAP event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                     /**< Connection Handle on which event occured. */
N  union                                                     /**< union alternative identified by evt_id in enclosing struct. */
N  {
N    ble_gap_evt_connected_t          connected;             /**< Connected Event Parameters. */
N    ble_gap_evt_disconnected_t       disconnected;          /**< Disconnected Event Parameters. */
N    ble_gap_evt_conn_param_update_t  conn_param_update;     /**< Connection Parameter Update Parameters. */
N    ble_gap_evt_sec_params_request_t sec_params_request;    /**< Security Parameters Request Event Parameters. */
N    ble_gap_evt_sec_info_request_t   sec_info_request;      /**< Security Information Request Event Parameters. */
N    ble_gap_evt_passkey_display_t    passkey_display;       /**< Passkey Display Event Parameters. */
N    ble_gap_evt_auth_key_request_t   auth_key_request;      /**< Authentication Key Request Event Parameters. */
N    ble_gap_evt_auth_status_t        auth_status;           /**< Authentication Status Event Parameters. */
N    ble_gap_evt_conn_sec_update_t    conn_sec_update;       /**< Connection Security Update Event Parameters. */
N    ble_gap_evt_timeout_t            timeout;               /**< Timeout Event Parameters. */
N    ble_gap_evt_rssi_changed_t       rssi_changed;          /**< RSSI Event parameters. */
N  } params;
N
N} ble_gap_evt_t;
N
N
N/**@brief Set local Bluetooth address.
N *
N * @param[in] p_addr Pointer to address structure.
N *
N * @return @ref NRF_SUCCESS Address successfully set.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid address.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_ADDRESS_SET, uint32_t, sd_ble_gap_address_set(ble_gap_addr_t const * const p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDRESS_SET) sd_ble_gap_address_set(ble_gap_addr_t const * const p_addr);
N
N
N/**@brief Get local Bluetooth address.
N *
N * @param[out] p_addr Pointer to address structure.
N *
N * @return @ref NRF_SUCCESS Address successfully retrieved.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_ADDRESS_GET, uint32_t, sd_ble_gap_address_get(ble_gap_addr_t * const p_addr));
Xuint32_t __svc(SD_BLE_GAP_ADDRESS_GET) sd_ble_gap_address_get(ble_gap_addr_t * const p_addr);
N
N
N/**@brief Set, clear or update advertisement and scan response data.
N *
N * @note The format of the advertisement data will be checked by this call to ensure interoperability.
N *       Limitations imposed by this API call to the data provided include having a flags data type in the scan response data and
N *       duplicating the local name in the advertisement data and scan response data. 
N *
N * @note: To clear the advertisement data and set it to a 0-length packet, simply provide a valid pointer (p_data/p_sr_data) with its corresponding 
N *        length (dlen/srdlen) set to 0.
N *
N * @note: The call will fail if p_data and p_sr_data are both NULL since this would have no effect.
N *
N * @param[in] p_data    Raw data to be placed in advertisement packet. If NULL, no changes are made to the current advertisement packet data.
N * @param[in] dlen      Data length for p_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_data is NULL, can be 0 if p_data is not NULL.
N * @param[in] p_sr_data Raw data to be placed in scan response packet. If NULL, no changes are made to the current scan response packet data.
N * @param[in] srdlen    Data length for p_sr_data. Max size: @ref BLE_GAP_ADV_MAX_SIZE octets. Should be 0 if p_sr_data is NULL, can be 0 if p_data is not NULL.
N *
N * @return @ref NRF_SUCCESS Advertisement data successfully updated or cleared.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_FLAGS Invalid combination of advertising flags supplied.
N * @return @ref NRF_ERROR_INVALID_DATA Invalid data type(s) supplied, check the advertising data format specification.
N * @return @ref NRF_ERROR_INVALID_LENGTH Invalid data length(s) supplied.
N * @return @ref BLE_ERROR_GAP_UUID_LIST_MISMATCH Invalid UUID list supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_ADV_DATA_SET, uint32_t, sd_ble_gap_adv_data_set(uint8_t const * const p_data, uint8_t dlen, uint8_t const * const p_sr_data, uint8_t srdlen));
Xuint32_t __svc(SD_BLE_GAP_ADV_DATA_SET) sd_ble_gap_adv_data_set(uint8_t const * const p_data, uint8_t dlen, uint8_t const * const p_sr_data, uint8_t srdlen);
N
N
N/**@brief Start advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @param[in] p_adv_params Pointer to advertising parameters structure.
N *
N * @return @ref NRF_SUCCESS The BLE stack has started advertising.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check the accepted ranges and limits.
N * @return @ref BLE_ERROR_GAP_INVALID_BLE_ADDR Invalid Bluetooth address supplied.
N * @return @ref BLE_ERROR_GAP_DISCOVERABLE_WITH_WHITELIST Discoverable mode and whitelist incompatible.
N */
NSVCALL(SD_BLE_GAP_ADV_START, uint32_t, sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params));
Xuint32_t __svc(SD_BLE_GAP_ADV_START) sd_ble_gap_adv_start(ble_gap_adv_params_t const * const p_adv_params);
N
N
N/**@brief Stop advertising (GAP Discoverable, Connectable modes, Broadcast Procedure).
N *
N * @return @ref NRF_SUCCESS The BLE stack has stopped advertising.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (most probably not in advertising state).
N */
NSVCALL(SD_BLE_GAP_ADV_STOP, uint32_t, sd_ble_gap_adv_stop(void));
Xuint32_t __svc(SD_BLE_GAP_ADV_STOP) sd_ble_gap_adv_stop(void);
N
N
N/**@brief Update connection parameters.
N *
N * @details In the central role this will initiate a Link Layer connection parameter update procedure,
N *          otherwise in the peripheral role, this will send the corresponding L2CAP request and wait for
N *          the central to perform the procedure. In both cases, and regardless of success or failure, the application
N *          will be informed of the result with a @ref BLE_GAP_EVT_CONN_PARAM_UPDATE event.
N *
N * @note If both a connection supervision timeout and a maximum connection interval are specified, then the following constraint
N *       applies: (conn_sup_timeout * 8) >= (max_conn_interval * (slave_latency + 1))
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_conn_params  Pointer to desired connection parameters. If NULL is provided on a peripheral role,
N *                           the parameters in the PPCP characteristic of the GAP service will be used instead.
N *
N * @return @ref NRF_SUCCESS The Connection Update procedure has been started successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, check parameter limits and constraints.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress or not allowed at this time, process pending events and retry.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GAP_CONN_PARAM_UPDATE, uint32_t, sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_CONN_PARAM_UPDATE) sd_ble_gap_conn_param_update(uint16_t conn_handle, ble_gap_conn_params_t const * const p_conn_params);
N
N
N/**@brief Disconnect (GAP Link Termination).
N *
N * @details This call initiates the disconnection procedure, and its completion will be communicated to the application
N *          with a BLE_GAP_EVT_DISCONNECTED event.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] hci_status_code HCI status code, see @ref BLE_HCI_STATUS_CODES.
N *
N * @return @ref NRF_SUCCESS The disconnection procedure has been started successfully.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation (disconnection is already in progress or not connected at all).
N */
NSVCALL(SD_BLE_GAP_DISCONNECT, uint32_t, sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code));
Xuint32_t __svc(SD_BLE_GAP_DISCONNECT) sd_ble_gap_disconnect(uint16_t conn_handle, uint8_t hci_status_code);
N
N
N/**@brief Set the radio's transmit power.
N *
N * @param[in] tx_power Radio transmit power in dBm (accepted values are -40, -30, -20, -16, -12, -8, -4, 0, and 4 dBm).
N *
N * @note -40 dBm will not actually give -40 dBm, but will instead be remapped to -30 dBm.
N *
N * @return @ref NRF_SUCCESS Successfully changed the transmit power.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_TX_POWER_SET, uint32_t, sd_ble_gap_tx_power_set(int8_t tx_power));
Xuint32_t __svc(SD_BLE_GAP_TX_POWER_SET) sd_ble_gap_tx_power_set(int8_t tx_power);
N
N
N/**@brief Set GAP Appearance value.
N *
N * @param[in] appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
N *
N * @return @ref NRF_SUCCESS  Appearance value set successfully.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_SET, uint32_t, sd_ble_gap_appearance_set(uint16_t appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_SET) sd_ble_gap_appearance_set(uint16_t appearance);
N
N
N/**@brief Get GAP Appearance value.
N *
N * @param[out] p_appearance Appearance (16-bit), see @ref BLE_APPEARANCES.
N *
N * @return @ref NRF_SUCCESS Appearance value retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_APPEARANCE_GET, uint32_t, sd_ble_gap_appearance_get(uint16_t * const p_appearance));
Xuint32_t __svc(SD_BLE_GAP_APPEARANCE_GET) sd_ble_gap_appearance_get(uint16_t * const p_appearance);
N
N
N/**@brief Set GAP Peripheral Preferred Connection Parameters.
N *
N * @param[in] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure with the desired parameters.
N *
N * @return @ref NRF_SUCCESS Peripheral Preferred Connection Parameters set successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_SET, uint32_t, sd_ble_gap_ppcp_set(ble_gap_conn_params_t const * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_SET) sd_ble_gap_ppcp_set(ble_gap_conn_params_t const * const p_conn_params);
N
N
N/**@brief Get GAP Peripheral Preferred Connection Parameters.
N *
N * @param[out] p_conn_params Pointer to a @ref ble_gap_conn_params_t structure where the parameters will be stored.
N *
N * @return @ref NRF_SUCCESS Peripheral Preferred Connection Parameters retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_GAP_PPCP_GET, uint32_t, sd_ble_gap_ppcp_get(ble_gap_conn_params_t * const p_conn_params));
Xuint32_t __svc(SD_BLE_GAP_PPCP_GET) sd_ble_gap_ppcp_get(ble_gap_conn_params_t * const p_conn_params);
N
N
N/**@brief Set GAP device name.
N *
N * @param[in] p_write_perm Write permissions for the Device Name characteristic see @ref ble_gap_conn_sec_mode_t.
N * @param[in] p_dev_name Pointer to a UTF-8 encoded, <b>non NULL-terminated</b> string.
N * @param[in] len   Length of the UTF-8, <b>non NULL-terminated</b> string pointed to by p_dev_name in octets (must be smaller or equal than @ref BLE_GAP_DEVNAME_MAX_LEN).
N *
N * @return @ref NRF_SUCCESS GAP device name and permissions set successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_SET, uint32_t, sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const * const p_write_perm, uint8_t const * const p_dev_name, uint16_t len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_SET) sd_ble_gap_device_name_set(ble_gap_conn_sec_mode_t const * const p_write_perm, uint8_t const * const p_dev_name, uint16_t len);
N
N
N/**@brief Get GAP device name.
N *
N * @param[in]     p_dev_name Pointer to an empty buffer where the UTF-8 <b>non NULL-terminated</b> string will be placed.
N * @param[in,out] p_len      Length of the buffer pointed by p_dev_name, bytes returned on output.
N *
N * @return @ref NRF_SUCCESS GAP device name retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N */
NSVCALL(SD_BLE_GAP_DEVICE_NAME_GET, uint32_t, sd_ble_gap_device_name_get(uint8_t * const p_dev_name, uint16_t * const p_len));
Xuint32_t __svc(SD_BLE_GAP_DEVICE_NAME_GET) sd_ble_gap_device_name_get(uint8_t * const p_dev_name, uint16_t * const p_len);
N
N
N/**@brief Initiate GAP Authentication procedure.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_sec_params Pointer to the @ref ble_gap_sec_params_t structure with the security parameters to be used during the pairing procedure.
N *
N * @details In the central role, this function will send an SMP Pairing Request, otherwise in the peripheral role, an SMP Security Request will be sent.
N *          In the peripheral role, only the timeout, bond and mitm fields of @ref ble_gap_sec_params_t are used.
N *
N * @note    The GAP Authentication procedure may be triggered by the central without calling this function when accessing a secure service.
N * @note    Calling this function may result in the following events depending on the outcome and parameters: @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST,
N *          @ref BLE_GAP_EVT_SEC_INFO_REQUEST, @ref BLE_GAP_EVT_AUTH_KEY_REQUEST, @ref BLE_GAP_EVT_AUTH_STATUS.
N * @note    The timeout parameter in @ref ble_gap_sec_params_t is interpreted here as the Security Request timeout
N *
N *
N * @return @ref NRF_SUCCESS Successfully initiated authentication procedure.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_AUTHENTICATE, uint32_t, sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const * const p_sec_params));
Xuint32_t __svc(SD_BLE_GAP_AUTHENTICATE) sd_ble_gap_authenticate(uint16_t conn_handle, ble_gap_sec_params_t const * const p_sec_params);
N
N
N/**@brief Reply with GAP security parameters.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] sec_status Security status, see @ref BLE_GAP_SEC_STATUS.
N * @param[in] p_sec_params Pointer to a @ref ble_gap_sec_params_t security parameters structure.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_PARAMS_REQUEST, calling it at other times will result in an NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N * @note    The timeout parameter in @ref ble_gap_sec_params_t is interpreted here as the SMP procedure timeout, and must be 30 seconds. The function will fail
N *          if the application supplies a different value.
N *
N * @return @ref NRF_SUCCESS Successfully accepted security parameter from the application.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_SEC_PARAMS_REPLY, uint32_t, sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const * const p_sec_params));
Xuint32_t __svc(SD_BLE_GAP_SEC_PARAMS_REPLY) sd_ble_gap_sec_params_reply(uint16_t conn_handle, uint8_t sec_status, ble_gap_sec_params_t const * const p_sec_params);
N
N
N/**@brief Reply with an authentication key.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] key_type See @ref BLE_GAP_AUTH_KEY_TYPES.
N * @param[in] key If key type is BLE_GAP_AUTH_KEY_TYPE_NONE, then NULL.
N *                If key type is BLE_GAP_AUTH_KEY_TYPE_PASSKEY, then a 6-byte ASCII string (digit 0..9 only, no NULL termination).
N *                If key type is BLE_GAP_AUTH_KEY_TYPE_OOB, then a 16-byte OOB key value in Little Endian format.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_AUTH_KEY_REQUEST, calling it at other times will result in an NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N *
N * @return @ref NRF_SUCCESS Authentication key successfully set.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_AUTH_KEY_REPLY, uint32_t, sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const * const key));
Xuint32_t __svc(SD_BLE_GAP_AUTH_KEY_REPLY) sd_ble_gap_auth_key_reply(uint16_t conn_handle, uint8_t key_type, uint8_t const * const key);
N
N
N/**@brief Reply with GAP security information.
N *
N * @param[in] conn_handle Connection handle.
N * @param[in] p_enc_info Pointer to a @ref ble_gap_enc_info_t encryption information structure. May be NULL to signal none is available.
N * @param[in] p_sign_info Pointer to a @ref ble_gap_sign_info_t signing information structure. May be NULL to signal none is available.
N *
N * @details This function is only used to reply to a @ref BLE_GAP_EVT_SEC_INFO_REQUEST, calling it at other times will result in NRF_ERROR_INVALID_STATE.
N * @note    If the call returns an error code, the request is still pending, and the reply call may be repeated with corrected parameters.
N * @note    Data signing is not implemented yet. p_sign_info must therefore be NULL.
N *
N * @return @ref NRF_SUCCESS Successfully accepted security information.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_SEC_INFO_REPLY, uint32_t, sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const * const p_enc_info, ble_gap_sign_info_t const * const p_sign_info));
Xuint32_t __svc(SD_BLE_GAP_SEC_INFO_REPLY) sd_ble_gap_sec_info_reply(uint16_t conn_handle, ble_gap_enc_info_t const * const p_enc_info, ble_gap_sign_info_t const * const p_sign_info);
N
N
N/**@brief Get the current connection security.
N *
N * @param[in]  conn_handle Connection handle.
N * @param[out] p_conn_sec  Pointer to a @ref ble_gap_conn_sec_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS Current connection security successfully retrieved.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N */
NSVCALL(SD_BLE_GAP_CONN_SEC_GET, uint32_t, sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t * const p_conn_sec));
Xuint32_t __svc(SD_BLE_GAP_CONN_SEC_GET) sd_ble_gap_conn_sec_get(uint16_t conn_handle, ble_gap_conn_sec_t * const p_conn_sec);
N
N
N/**@brief Start reporting the received signal strength to the application. 
N *
N * A new event is reported whenever the RSSI value changes, until @ref sd_ble_gap_rssi_stop is called.
N *
N * @param[in] conn_handle Connection handle.
N *
N * @return @ref NRF_SUCCESS Successfully activated RSSI reporting.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_RSSI_START, uint32_t, sd_ble_gap_rssi_start(uint16_t conn_handle));
Xuint32_t __svc(SD_BLE_GAP_RSSI_START) sd_ble_gap_rssi_start(uint16_t conn_handle);
N
N
N/**@brief Stop reporting the received singnal strength. 
N *
N * An RSSI change detected before the call but not yet received by the application 
N * may be reported after @ref sd_ble_gap_rssi_stop has been called.
N *
N * @param[in] conn_handle Connection handle.
N *
N * @return @ref NRF_SUCCESS Successfully deactivated RSSI reporting.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid connection handle supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy, process pending events and retry.
N */
NSVCALL(SD_BLE_GAP_RSSI_STOP, uint32_t, sd_ble_gap_rssi_stop(uint16_t conn_handle));
Xuint32_t __svc(SD_BLE_GAP_RSSI_STOP) sd_ble_gap_rssi_stop(uint16_t conn_handle);
N
N#endif // BLE_GAP_H__
N
N/**
N  @}
N*/
L 24 "..\..\..\Software\Include\ble.h" 2
N#include "ble_l2cap.h"
L 1 "..\..\..\Software\Include\ble_l2cap.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_L2CAP Logical Link Control and Adaptation Protocol (L2CAP)
N  @{
N  @brief Definitions and prototypes for the L2CAP interface.
N */
N
N#ifndef BLE_L2CAP_H__
N#define BLE_L2CAP_H__ 
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_err.h"
L 1 "..\..\..\Software\Include\ble_err.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup BLE_COMMON
N  @{
N  @addtogroup  nrf_error
N  @{
N    @ingroup BLE_COMMON
N  @}
N
N  @defgroup ble_err General error codes
N  @{
N
N  @brief General error code definitions for the BLE API.
N
N  @ingroup BLE_COMMON
N*/
N#ifndef NRF_BLE_ERR_H__
N#define NRF_BLE_ERR_H__
N
N#include "nrf_error.h"
L 1 "..\..\..\Software\Include\nrf_error.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @defgroup nrf_error SoftDevice Global Error Codes
N  @{
N   
N  @brief Global Error definitions
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_H__
N#define NRF_ERROR_H__
N
N/** @defgroup NRF_ERRORS_BASE Error Codes Base number definitions
N * @{ */
N#define NRF_ERROR_BASE_NUM      (0x0)       ///< Global error base
N#define NRF_ERROR_SDM_BASE_NUM  (0x1000)    ///< SDM error base
N#define NRF_ERROR_SOC_BASE_NUM  (0x2000)    ///< SoC error base
N#define NRF_ERROR_STK_BASE_NUM  (0x3000)    ///< STK error base
N/** @} */
N
N#define NRF_SUCCESS                           (NRF_ERROR_BASE_NUM + 0)  ///< Successful command
N#define NRF_ERROR_SVC_HANDLER_MISSING         (NRF_ERROR_BASE_NUM + 1)  ///< SVC handler is missing
N#define NRF_ERROR_SOFTDEVICE_NOT_ENABLED      (NRF_ERROR_BASE_NUM + 2)  ///< SoftDevice has not been enabled
N#define NRF_ERROR_INTERNAL                    (NRF_ERROR_BASE_NUM + 3)  ///< Internal Error
N#define NRF_ERROR_NO_MEM                      (NRF_ERROR_BASE_NUM + 4)  ///< No Memory for operation
N#define NRF_ERROR_NOT_FOUND                   (NRF_ERROR_BASE_NUM + 5)  ///< Not found
N#define NRF_ERROR_NOT_SUPPORTED               (NRF_ERROR_BASE_NUM + 6)  ///< Not supported
N#define NRF_ERROR_INVALID_PARAM               (NRF_ERROR_BASE_NUM + 7)  ///< Invalid Parameter
N#define NRF_ERROR_INVALID_STATE               (NRF_ERROR_BASE_NUM + 8)  ///< Invalid state, operation disallowed in this state
N#define NRF_ERROR_INVALID_LENGTH              (NRF_ERROR_BASE_NUM + 9)  ///< Invalid Length
N#define NRF_ERROR_INVALID_FLAGS               (NRF_ERROR_BASE_NUM + 10) ///< Invalid Flags
N#define NRF_ERROR_INVALID_DATA                (NRF_ERROR_BASE_NUM + 11) ///< Invalid Data
N#define NRF_ERROR_DATA_SIZE                   (NRF_ERROR_BASE_NUM + 12) ///< Data size exceeds limit
N#define NRF_ERROR_TIMEOUT                     (NRF_ERROR_BASE_NUM + 13) ///< Operation timed out
N#define NRF_ERROR_NULL                        (NRF_ERROR_BASE_NUM + 14) ///< Null Pointer
N#define NRF_ERROR_FORBIDDEN                   (NRF_ERROR_BASE_NUM + 15) ///< Forbidden Operation
N#define NRF_ERROR_INVALID_ADDR                (NRF_ERROR_BASE_NUM + 16) ///< Bad Memory Address
N#define NRF_ERROR_BUSY                        (NRF_ERROR_BASE_NUM + 17) ///< Busy
N
N#endif // NRF_ERROR_H__
N
N/**
N  @}
N*/
L 28 "..\..\..\Software\Include\ble_err.h" 2
N
N/* @defgroup BLE_ERRORS Error Codes
N * @{ */
N#define BLE_ERROR_INVALID_CONN_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x001) /**< Invalid connection handle. */
N#define BLE_ERROR_INVALID_ATTR_HANDLE    (NRF_ERROR_STK_BASE_NUM+0x002) /**< Invalid attribute handle. */
N#define BLE_ERROR_NO_TX_BUFFERS          (NRF_ERROR_STK_BASE_NUM+0x003) /**< Buffer capacity exceeded. */
N/** @} */
N
N
N/** @defgroup BLE_ERROR_SUBRANGES Module specific error code subranges
N *  @brief Assignment of subranges for module specific error codes.
N *  @note For specific error codes, see ble_<module>.h or ble_error_<module>.h.
N * @{ */
N#define NRF_L2CAP_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x100) /**< L2CAP specific errors. */
N#define NRF_GAP_ERR_BASE               (NRF_ERROR_STK_BASE_NUM+0x200) /**< GAP specific errors. */
N#define NRF_GATTC_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x300) /**< GATT client specific errors. */
N#define NRF_GATTS_ERR_BASE             (NRF_ERROR_STK_BASE_NUM+0x400) /**< GATT server specific errors. */
N/** @} */
N
N#endif
N
N
N/**
N  @}
N  @}
N*/
L 20 "..\..\..\Software\Include\ble_l2cap.h" 2
N#include "nrf_svc.h"
N
N/**@brief L2CAP API SVC numbers. */
Nenum BLE_L2CAP_SVCS 
N{
N  SD_BLE_L2CAP_CID_REGISTER = BLE_L2CAP_SVC_BASE,  /**< Register a CID. */
X  SD_BLE_L2CAP_CID_REGISTER = 0xB0,   
N  SD_BLE_L2CAP_CID_UNREGISTER,                     /**< Unregister a CID. */
N  SD_BLE_L2CAP_TX                                  /**< Transmit a packet. */
N};
N
N/**@addtogroup BLE_L2CAP_DEFINES Defines
N * @{ */
N
N/**@defgroup BLE_ERRORS_L2CAP SVC return values specific to L2CAP
N * @{ */
N#define BLE_ERROR_L2CAP_CID_IN_USE            (NRF_L2CAP_ERR_BASE + 0x000)  /**< CID already in use. */
N/** @} */
N
N/**@brief Default L2CAP MTU. */
N#define BLE_L2CAP_MTU_DEF           (23)    
N
N/**@brief Invalid Channel Identifier. */
N#define BLE_L2CAP_CID_INVALID       (0x0000) 
N
N/**@brief Dynamic Channel Identifier base. */
N#define BLE_L2CAP_CID_DYN_BASE      (0x0040) 
N
N/**@brief Maximum amount of dynamic CIDs. */
N#define BLE_L2CAP_CID_DYN_MAX       (8) 
N
N/** @} */
N
N/**@brief Packet header format for L2CAP transmission. */
Ntypedef struct
N{
N  uint16_t   len;                                 /**< Length of valid info in data member. */
N  uint16_t   cid;                                 /**< Channel ID on which packet is transmitted. */
N} ble_l2cap_header_t;
N
N/**@brief L2CAP Event IDs. */
Nenum BLE_L2CAP_EVTS 
N{
N  BLE_L2CAP_EVT_RX  = BLE_L2CAP_EVT_BASE          /**< L2CAP packet received. */
X  BLE_L2CAP_EVT_RX  = 0x70           
N};
N
N
N/**@brief L2CAP Received packet event report. */
Ntypedef struct
N{
N  ble_l2cap_header_t header;                      /** L2CAP packet header. */
N  uint8_t    data[1];                             /**< Packet data, variable length. */
N} ble_l2cap_evt_rx_t;
N
N
N/**@brief L2CAP event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                           /**< Connection Handle on which event occured. */
N  union
N  {
N    ble_l2cap_evt_rx_t rx;                        /**< RX Event parameters. */
N  } params;
N} ble_l2cap_evt_t;
N
N
N/**@brief Register a CID with L2CAP.
N *
N * @details This registers a higher protocol layer with the L2CAP multiplexer, and is requried prior to all operations on the CID.
N *          
N * @param[in] cid L2CAP CID.
N *
N * @return @ref NRF_SUCCESS Successfully registered a CID with the L2CAP layer.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CID must be above @ref BLE_L2CAP_CID_DYN_BASE.
N * @return @ref BLE_ERROR_L2CAP_CID_IN_USE L2CAP CID already in use.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_L2CAP_CID_REGISTER, uint32_t, sd_ble_l2cap_cid_register(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_REGISTER) sd_ble_l2cap_cid_register(uint16_t cid);
N
N/**@brief Unregister a CID with L2CAP.
N *
N * @details This unregisters a previously registerd higher protocol layer with the L2CAP multiplexer.
N *          
N * @param[in] cid L2CAP CID.
N *
N * @return @ref NRF_SUCCESS Successfully unregistered the CID.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_NOT_FOUND CID not previously registered.
N */
NSVCALL(SD_BLE_L2CAP_CID_UNREGISTER, uint32_t, sd_ble_l2cap_cid_unregister(uint16_t cid));
Xuint32_t __svc(SD_BLE_L2CAP_CID_UNREGISTER) sd_ble_l2cap_cid_unregister(uint16_t cid);
N
N/**@brief Transmit an L2CAP packet.
N *
N * @note    It is important to note that a call to this function will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. 
N *          Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle Connection Handle.
N * @param[in] p_header    Pointer to a packet header containing length and CID.
N * @param[in] p_data      Pointer to the data to be transmitted.
N *
N * @return @ref NRF_SUCCESS Successfully queued an L2CAP packet for transmission.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, CIDs must be registered beforehand with @ref sd_ble_l2cap_cid_register.
N * @return @ref NRF_ERROR_NOT_FOUND CID not found.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS Not enough application buffers available.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, see @ref BLE_L2CAP_MTU_DEF.
N */
NSVCALL(SD_BLE_L2CAP_TX, uint32_t, sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const * const p_header, uint8_t const * const p_data));
Xuint32_t __svc(SD_BLE_L2CAP_TX) sd_ble_l2cap_tx(uint16_t conn_handle, ble_l2cap_header_t const * const p_header, uint8_t const * const p_data);
N
N
N#endif // BLE_L2CAP_H__
N
N/**
N  @}
N*/
L 25 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gatt.h"
L 1 "..\..\..\Software\Include\ble_gatt.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup BLE_GATT Generic Attribute Profile (GATT) Common
N  @{
N  @brief  Common definitions and prototypes for the GATT interfaces.
N */
N
N#ifndef BLE_GATT_H__
N#define BLE_GATT_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N
N
N/** @addtogroup BLE_GATT_DEFINES Defines
N * @{ */
N
N/** @brief Default MTU size. */
N#define GATT_MTU_SIZE_DEFAULT 23
N
N/** @brief Only the default MTU size of 23 is currently supported. */
N#define GATT_RX_MTU 23
N
N
N/**@brief Invalid Attribute Handle. */
N#define BLE_GATT_HANDLE_INVALID            0x0000
N
N/** @defgroup BLE_GATT_TIMEOUT_SOURCES GATT Timeout sources
N * @{ */
N#define BLE_GATT_TIMEOUT_SRC_PROTOCOL                  0x00 /**< ATT Protocol timeout. */
N/** @} */
N
N/** @defgroup BLE_GATT_WRITE_OPS GATT Write operations
N * @{ */
N#define BLE_GATT_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATT_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATT_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATT_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N#define BLE_GATT_OP_PREPARE_WRITE_REQ      0x04  /**< Prepare Write Request. */
N#define BLE_GATT_OP_EXECUTE_WRITE_REQ      0x05  /**< Execute Write Request. */
N/** @} */
N
N/** @defgroup BLE_GATT_HVX_TYPES GATT Handle Value operations
N * @{ */
N#define BLE_GATT_HVX_INVALID               0x00  /**< Invalid Operation. */
N#define BLE_GATT_HVX_NOTIFICATION          0x01  /**< Handle Value Notification. */
N#define BLE_GATT_HVX_INDICATION            0x02  /**< Handle Value Indication. */
N/** @} */
N
N/** @defgroup BLE_GATT_STATUS_CODES GATT Status Codes
N * @{ */
N#define BLE_GATT_STATUS_SUCCESS                           0x0000  /**< Success. */
N#define BLE_GATT_STATUS_UNKNOWN                           0x0001  /**< Unknown or not applicable status. */
N#define BLE_GATT_STATUS_ATTERR_INVALID                    0x0100  /**< ATT Error: Invalid Error Code. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_HANDLE             0x0101  /**< ATT Error: Invalid Attribute Handle. */
N#define BLE_GATT_STATUS_ATTERR_READ_NOT_PERMITTED         0x0102  /**< ATT Error: Read not permitted. */
N#define BLE_GATT_STATUS_ATTERR_WRITE_NOT_PERMITTED        0x0103  /**< ATT Error: Write not permitted. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_PDU                0x0104  /**< ATT Error: Used in ATT as Invalid PDU. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHENTICATION       0x0105  /**< ATT Error: Authenticated link required. */
N#define BLE_GATT_STATUS_ATTERR_REQUEST_NOT_SUPPORTED      0x0106  /**< ATT Error: Used in ATT as Request Not Supported. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_OFFSET             0x0107  /**< ATT Error: Offset specified was past the end of the attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_AUTHORIZATION        0x0108  /**< ATT Error: Used in ATT as Insufficient Authorisation. */
N#define BLE_GATT_STATUS_ATTERR_PREPARE_QUEUE_FULL         0x0109  /**< ATT Error: Used in ATT as Prepare Queue Full. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_FOUND        0x010A  /**< ATT Error: Used in ATT as Attribute not found. */
N#define BLE_GATT_STATUS_ATTERR_ATTRIBUTE_NOT_LONG         0x010B  /**< ATT Error: Attribute cannot be read or written using read/write blob requests. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENC_KEY_SIZE         0x010C  /**< ATT Error: Encryption key size used is insufficient. */
N#define BLE_GATT_STATUS_ATTERR_INVALID_ATT_VAL_LENGTH     0x010D  /**< ATT Error: Invalid value size. */
N#define BLE_GATT_STATUS_ATTERR_UNLIKELY_ERROR             0x010E  /**< ATT Error: Very unlikely error. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_ENCRYPTION           0x010F  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_UNSUPPORTED_GROUP_TYPE     0x0110  /**< ATT Error: Attribute type is not a supported grouping attribute. */
N#define BLE_GATT_STATUS_ATTERR_INSUF_RESOURCES            0x0111  /**< ATT Error: Encrypted link required. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_BEGIN           0x0112  /**< ATT Error: Reserved for Future Use range #1 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE1_END             0x017F  /**< ATT Error: Reserved for Future Use range #1 end. */
N#define BLE_GATT_STATUS_ATTERR_APP_BEGIN                  0x0180  /**< ATT Error: Application range begin. */
N#define BLE_GATT_STATUS_ATTERR_APP_END                    0x019F  /**< ATT Error: Application range end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_BEGIN           0x01A0  /**< ATT Error: Reserved for Future Use range #2 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE2_END             0x01DF  /**< ATT Error: Reserved for Future Use range #2 end. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_BEGIN           0x01E0  /**< ATT Error: Reserved for Future Use range #3 begin. */
N#define BLE_GATT_STATUS_ATTERR_RFU_RANGE3_END             0x01FC  /**< ATT Error: Reserved for Future Use range #3 end. */
N#define BLE_GATT_STATUS_ATTERR_CPS_CCCD_CONFIG_ERROR      0x01FD  /**< ATT Common Profile and Service Error: Client Characteristic Configuration Descriptor improperly configured. */
N#define BLE_GATT_STATUS_ATTERR_CPS_PROC_ALR_IN_PROG       0x01FE  /**< ATT Common Profile and Service Error: Procedure Already in Progress. */
N#define BLE_GATT_STATUS_ATTERR_CPS_OUT_OF_RANGE           0x01FF  /**< ATT Common Profile and Service Error: Out Of Range. */
N/** @} */
N
N
N/** @defgroup BLE_GATT_CPF_FORMATS Characteristic Presentation Formats
N *  @note Found at http://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorViewer.aspx?u=org.bluetooth.descriptor.gatt.characteristic_presentation_format.xml
N * @{ */
N#define BLE_GATT_CPF_FORMAT_RFU                 0x00 /**< Reserved For Future Use. */
N#define BLE_GATT_CPF_FORMAT_BOOLEAN             0x01 /**< Boolean. */
N#define BLE_GATT_CPF_FORMAT_2BIT                0x02 /**< Unsigned 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_NIBBLE              0x03 /**< Unsigned 4-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT8               0x04 /**< Unsigned 8-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT12              0x05 /**< Unsigned 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT16              0x06 /**< Unsigned 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT24              0x07 /**< Unsigned 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT32              0x08 /**< Unsigned 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT48              0x09 /**< Unsigned 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT64              0x0A /**< Unsigned 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_UINT128             0x0B /**< Unsigned 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT8               0x0C /**< Signed 2-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT12              0x0D /**< Signed 12-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT16              0x0E /**< Signed 16-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT24              0x0F /**< Signed 24-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT32              0x10 /**< Signed 32-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT48              0x11 /**< Signed 48-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT64              0x12 /**< Signed 64-bit integer. */
N#define BLE_GATT_CPF_FORMAT_SINT128             0x13 /**< Signed 128-bit integer. */
N#define BLE_GATT_CPF_FORMAT_FLOAT32             0x14 /**< IEEE-754 32-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_FLOAT64             0x15 /**< IEEE-754 64-bit floating point. */
N#define BLE_GATT_CPF_FORMAT_SFLOAT              0x16 /**< IEEE-11073 16-bit SFLOAT. */
N#define BLE_GATT_CPF_FORMAT_FLOAT               0x17 /**< IEEE-11073 32-bit FLOAT. */
N#define BLE_GATT_CPF_FORMAT_DUINT16             0x18 /**< IEEE-20601 format. */
N#define BLE_GATT_CPF_FORMAT_UTF8S               0x19 /**< UTF-8 string. */
N#define BLE_GATT_CPF_FORMAT_UTF16S              0x1A /**< UTF-16 string. */
N#define BLE_GATT_CPF_FORMAT_STRUCT              0x1B /**< Opaque Structure. */
N/** @} */
N
N/** @defgroup BLE_GATT_CPF_NAMESPACES GATT Bluetooth Namespaces
N * @{
N */
N#define BLE_GATT_CPF_NAMESPACE_BTSIG            0x01
N#define BLE_GATT_CPF_NAMESPACE_DESCRIPTION_UNKNOWN 0x0000
N/** @} */
N
N/** @} */
N
N/**@brief GATT Characteristic Properties. */
Ntypedef struct
N{
N  /* Standard properties */
N  uint8_t broadcast       :1; /**< Broadcasting of value permitted. */
N  uint8_t read            :1; /**< Reading value permitted. */
N  uint8_t write_wo_resp   :1; /**< Writing value with Write Command permitted. */
N  uint8_t write           :1; /**< Writing value with Write Request permitted. */
N  uint8_t notify          :1; /**< Notications of value permitted. */
N  uint8_t indicate        :1; /**< Indications of value permitted. */
N  uint8_t auth_signed_wr  :1; /**< Writing value with Signed Write Command permitted. */
N} ble_gatt_char_props_t;
N
N/**@brief GATT Characteristic Extended Properties. */
Ntypedef struct
N{
N  /* Extended properties */
N  uint8_t reliable_wr     :1; /**< Writing value with Queued Write Request permitted. */
N  uint8_t wr_aux          :1; /**< Writing the Characteristic User Description permitted. */
N} ble_gatt_char_ext_props_t;
N
N#endif // BLE_GATT_H__
N
N/**
N  @}
N  @}
N*/
L 26 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gattc.h"
L 1 "..\..\..\Software\Include\ble_gattc.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GATTC Generic Attribute Profile (GATT) Client
N  @{
N  @brief  Definitions and prototypes for the GATT Client interface.
N */
N
N#ifndef BLE_GATTC_H__
N#define BLE_GATTC_H__
N
N#include "ble_gatt.h"
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "nrf_svc.h"
N
N
N/**@brief GATTC API SVC numbers. */
Nenum BLE_GATTC_SVCS
N{
N  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = BLE_GATTC_SVC_BASE, /**< Primary Service Discovery. */
X  SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER = 0x80,  
N  SD_BLE_GATTC_RELATIONSHIPS_DISCOVER,                         /**< Relationship Discovery. */
N  SD_BLE_GATTC_CHARACTERISTICS_DISCOVER,                       /**< Characteristic Discovery. */
N  SD_BLE_GATTC_DESCRIPTORS_DISCOVER,                           /**< Characteristic Descriptor Discovery. */
N  SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ,                        /**< Read Characteristic Value by UUID. */
N  SD_BLE_GATTC_READ,                                           /**< Generic read. */
N  SD_BLE_GATTC_CHAR_VALUES_READ,                               /**< Read multiple Characteristic Values. */
N  SD_BLE_GATTC_WRITE,                                          /**< Generic write. */
N  SD_BLE_GATTC_HV_CONFIRM                                      /**< Handle Value Confirmation. */
N};
N
N/** @addtogroup BLE_GATTC_DEFINES Defines
N * @{ */
N
N/** @defgroup BLE_ERRORS_GATTC SVC return values specific to GATTC
N * @{ */
N#define BLE_ERROR_GATTC_PROC_NOT_PERMITTED    (NRF_GATTC_ERR_BASE + 0x000)
N/** @} */
N
N/**@brief Last Attribute Handle. */
N#define BLE_GATTC_HANDLE_END                0xFFFF
N
N/** @} */
N
N/**@brief Operation Handle Range. */
Ntypedef struct
N{
N  uint16_t          start_handle; /**< Start Handle. */
N  uint16_t          end_handle;   /**< End Handle. */
N} ble_gattc_handle_range_t;
N
N
N/**@brief GATT service. */
Ntypedef struct
N{
N  ble_uuid_t               uuid;          /**< Service UUID. */
N  ble_gattc_handle_range_t handle_range;  /**< Service Handle Range. */
N} ble_gattc_service_t;
N
N
N/**@brief  GATT include. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Include Handle. */
N  ble_gattc_service_t included_srvc;    /**< Handle of the included service. */
N} ble_gattc_include_t;
N
N
N/**@brief GATT characteristic. */
Ntypedef struct
N{
N  ble_uuid_t              uuid;                 /**< Characteristic UUID. */
N  ble_gatt_char_props_t   char_props;           /**< Characteristic Properties. */
N  uint8_t                 char_ext_props : 1;   /**< Extended properties present. */
N  uint16_t                handle_decl;          /**< Handle of the Characteristic Declaration. */
N  uint16_t                handle_value;         /**< Handle of the Characteristic Value. */
N} ble_gattc_char_t;
N
N
N/**@brief GATT descriptor. */
Ntypedef struct
N{
N  uint16_t          handle;         /**< Descriptor Handle. */
N  ble_uuid_t        uuid;           /**< Descriptor UUID. */
N} ble_gattc_desc_t;
N
N
N/**@brief Write Parameters. */
Ntypedef struct
N{
N  uint8_t    write_op;                 /**< Write Operation to be performed, see BLE_GATT_WRITE_OPS. */
N  uint16_t   handle;                   /**< Handle to the attribute to be written. */
N  uint16_t   offset;                   /**< Offset in bytes. */
N  uint16_t   len;                      /**< Length of data in bytes. */
N  uint8_t*   p_value;                  /**< Pointer to the value data. */
N} ble_gattc_write_params_t;
N
N
N/**
N * @brief GATT Client Event IDs.
N */
Nenum BLE_GATTC_EVTS
N{
N  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = BLE_GATTC_EVT_BASE,  /**< Primary Service Discovery Response event.  */
X  BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP = 0x30,   
N  BLE_GATTC_EVT_REL_DISC_RSP,                             /**< Relationship Discovery Response event. */
N  BLE_GATTC_EVT_CHAR_DISC_RSP,                            /**< Characteristic Discovery Response event. */
N  BLE_GATTC_EVT_DESC_DISC_RSP,                            /**< Descriptor Discovery Response event. */
N  BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP,                /**< Read By UUID Response event. */
N  BLE_GATTC_EVT_READ_RSP,                                 /**< Read Response event. */
N  BLE_GATTC_EVT_CHAR_VALS_READ_RSP,                       /**< Read multiple Response event. */
N  BLE_GATTC_EVT_WRITE_RSP,                                /**< Write Response event. */
N  BLE_GATTC_EVT_HVX,                                      /**< Handle Value Notification or Indication event. */
N  BLE_GATTC_EVT_TIMEOUT                                   /**< Timeout event. */
N};
N
N/**@brief Event structure for BLE_GATTC_EVT_PRIM_SRVC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Service count. */
N  ble_gattc_service_t services[1];      /**< Service data, variable length. */
N} ble_gattc_evt_prim_srvc_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_REL_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t             count;           /**< Include count. */
N  ble_gattc_include_t includes[1];      /**< Include data, variable length. */
N} ble_gattc_evt_rel_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Characteristic count. */
N  ble_gattc_char_t    chars[1];       /**< Characteristic data, variable length. */
N} ble_gattc_evt_char_disc_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_DESC_DISC_RSP. */
Ntypedef struct
N{
N  uint16_t            count;          /**< Descriptor count. */
N  ble_gattc_desc_t    descs[1];       /**< Descriptor data, variable length. */
N} ble_gattc_evt_desc_disc_rsp_t;
N
N/**@brief GATT read by UUID handle value pair. */
Ntypedef struct 
N{
N  uint16_t            handle;          /**< Attribute Handle. */
N  uint8_t             *p_value;        /**< Pointer to value, variable length (length available as value_len in ble_gattc_evt_read_by_uuid_rsp_t). 
N                                            Please note that this pointer is absolute to the memory provided by the user when retrieving the event,
N                                            so it will effectively point to a location inside the handle_value array. */
N} ble_gattc_handle_value_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_VAL_BY_UUID_READ_RSP. */
Ntypedef struct
N{
N  uint16_t                  count;            /**< Handle-Value Pair Count. */
N  uint16_t                  value_len;        /**< Length of the value in Handle-Value(s) list. */
N  ble_gattc_handle_value_t  handle_value[1];  /**< Handle-Value(s) list, variable length. */
N} ble_gattc_evt_char_val_by_uuid_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Attribute Handle. */
N  uint16_t            offset;         /**< Offset of the attribute data. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data, variable length. */
N} ble_gattc_evt_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_CHAR_VALS_READ_RSP. */
Ntypedef struct
N{
N  uint16_t            len;            /**< Concatenated Attribute values length. */
N  uint8_t             values[1];      /**< Attribute values, variable length. */
N} ble_gattc_evt_char_vals_read_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_WRITE_RSP. */
Ntypedef struct
N{
N  uint16_t            handle;           /**< Attribute Handle. */
N  uint8_t             write_op;         /**< Type of write operation, see @ref BLE_GATT_WRITE_OPS. */
N  uint16_t            len;              /**< Prepare write data length. */
N  uint8_t             data[1];          /**< Prepare write data, variable length. */
N} ble_gattc_evt_write_rsp_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_HVX. */
Ntypedef struct
N{
N  uint16_t            handle;         /**< Handle to which the HVx operation applies. */
N  uint8_t             type;           /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t            len;            /**< Attribute data length. */
N  uint8_t             data[1];        /**< Attribute data, variable length. */
N} ble_gattc_evt_hvx_t;
N
N/**@brief Event structure for BLE_GATTC_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gattc_evt_timeout_t;
N
N/**@brief GATTC event type. */
Ntypedef struct
N{
N  uint16_t            conn_handle;                /**< Connection Handle on which event occured. */
N  uint16_t            gatt_status;                /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  union
N  {
N    ble_gattc_evt_prim_srvc_disc_rsp_t          prim_srvc_disc_rsp;         /**< Primary Service Discovery Response Event Parameters. */
N    ble_gattc_evt_rel_disc_rsp_t                rel_disc_rsp;               /**< Relationship Discovery Response Event Parameters. */
N    ble_gattc_evt_char_disc_rsp_t               char_disc_rsp;              /**< Characteristic Discovery Response Event Parameters. */
N    ble_gattc_evt_desc_disc_rsp_t               desc_disc_rsp;              /**< Descriptor Discovery Response Event Parameters. */
N    ble_gattc_evt_char_val_by_uuid_read_rsp_t   char_val_by_uuid_read_rsp;  /**< Characteristic Value Read by UUID Response Event Parameters. */
N    ble_gattc_evt_read_rsp_t                    read_rsp;                   /**< Read Response Event Parameters. */
N    ble_gattc_evt_char_vals_read_rsp_t          char_vals_read_rsp;         /**< Characteristic Values Read Response Event Parameters. */
N    ble_gattc_evt_write_rsp_t                   write_rsp;                  /**< Write Response Event Parameters. */
N    ble_gattc_evt_hvx_t                         hvx;                        /**< Handle Value Notification/Indication Event Parameters. */
N    ble_gattc_evt_timeout_t                     timeout;                    /**< Timeout Event Parameters. */
N   } params;
N} ble_gattc_evt_t;
N
N
N/**@brief Initiate or continue a GATT Primary Service Discovery procedure.
N *
N * @details This function initiates a Primary Service discovery, starting from the supplied handle. 
N *          If the last service has not been reached, this must be called again with an updated start handle value to continue the search.
N *
N * @note If any of the discovered services have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] start_handle Handle to start searching from.
N * @param[in] p_srvc_uuid Pointer to the service UUID to be found. If it is NULL, all primary services will be returned.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Primary Service Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER, uint32_t, sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const * const p_srvc_uuid));
Xuint32_t __svc(SD_BLE_GATTC_PRIMARY_SERVICES_DISCOVER) sd_ble_gattc_primary_services_discover(uint16_t conn_handle, uint16_t start_handle, ble_uuid_t const * const p_srvc_uuid);
N
N
N/**@brief Initiate or continue a GATT Relationship Discovery procedure.
N *
N * @details This function initiates the Find Included Services sub-procedure. If the last included service has not been reached,
N *          this must be called again with an updated handle range to continue the search.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Relationship Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER, uint32_t, sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_RELATIONSHIPS_DISCOVER) sd_ble_gattc_relationships_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Discovery procedure.
N *
N * @details This function initiates a Characteristic discovery procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @note If any of the discovered characteristics have 128-bit UUIDs which are not present in the table provided to ble_vs_uuids_assign, a UUID structure with
N *       type BLE_UUID_TYPE_UNKNOWN will be received in the corresponding event.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Service to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Characteristic Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER, uint32_t, sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHARACTERISTICS_DISCOVER) sd_ble_gattc_characteristics_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Characteristic Descriptor Discovery procedure.
N *
N * @details This function initiates the Characteristic Descriptor discovery procedure. If the last Descriptor has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handle_range A pointer to the range of handles of the Characteristic to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Descriptor Discovery procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_DESCRIPTORS_DISCOVER, uint32_t, sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_DESCRIPTORS_DISCOVER) sd_ble_gattc_descriptors_discover(uint16_t conn_handle, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read using Characteristic UUID procedure.
N *
N * @details This function initiates the Read using Characteristic UUID procedure. If the last Characteristic has not been reached,
N *          this must be called again with an updated handle range to continue the discovery.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_uuid Pointer to a Characteristic value UUID to read.
N * @param[in] p_handle_range A pointer to the range of handles to perform this procedure on.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Read using Characteristic UUID procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ, uint32_t, sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUE_BY_UUID_READ) sd_ble_gattc_char_value_by_uuid_read(uint16_t conn_handle, ble_uuid_t const * const p_uuid, ble_gattc_handle_range_t const * const p_handle_range);
N
N
N/**@brief Initiate or continue a GATT Read (Long) Characteristic or Descriptor procedure.
N *
N * @details This function initiates a GATT Read (Long) Characteristic or Descriptor procedure. If the Characteristic or Descriptor
N *          to be read is longer than GATT_MTU - 1, this function must be called multiple times with appropriate offset to read the 
N *          complete value.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute to be read.
N * @param[in] offset Offset into the attribute value to be read.
N *
N * @return @ref NRF_SUCCESS Successfully started or resumed the Read (Long) procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_READ, uint32_t, sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset));
Xuint32_t __svc(SD_BLE_GATTC_READ) sd_ble_gattc_read(uint16_t conn_handle, uint16_t handle, uint16_t offset);
N
N
N/**@brief Initiate a GATT Read Multiple Characteristic Values procedure.
N *
N * @details This function initiates a GATT Read Multiple Characteristic Values procedure. 
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_handles A pointer to the handle(s) of the attribute(s) to be read.
N * @param[in] handle_count The number of handles in p_handles.
N *
N * @return @ref NRF_SUCCESS Successfully started the Read Multiple Characteristic Values procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY Client procedure already in progress.
N */
NSVCALL(SD_BLE_GATTC_CHAR_VALUES_READ, uint32_t, sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const * const p_handles, uint16_t handle_count));
Xuint32_t __svc(SD_BLE_GATTC_CHAR_VALUES_READ) sd_ble_gattc_char_values_read(uint16_t conn_handle, uint16_t const * const p_handles, uint16_t handle_count);
N
N
N/**@brief Perform a Write (Characteristic Value or Descriptor, with or without response, signed or not, long or reliable) procedure.
N *
N * @details This function can perform all write procedures described in GATT. 
N *
N * @note    It is important to note that a write without response will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. A write on the other hand will use the 
N *          standard client internal buffer and thus will only generate a @ref BLE_GATTC_EVT_WRITE_RSP event as soon as the write response 
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] p_write_params A pointer to a write parameters structure.
N *
N * @return @ref NRF_SUCCESS Successfully started the Write procedure.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers left.
N */
NSVCALL(SD_BLE_GATTC_WRITE, uint32_t, sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const * const p_write_params));
Xuint32_t __svc(SD_BLE_GATTC_WRITE) sd_ble_gattc_write(uint16_t conn_handle, ble_gattc_write_params_t const * const p_write_params);
N
N
N/**@brief Send a Handle Value Confirmation to the GATT Server.
N *
N * @param[in] conn_handle The connection handle identifying the connection to perform this procedure on.
N * @param[in] handle The handle of the attribute in the indication.
N *
N * @return @ref NRF_SUCCESS Successfully queued the Handle Value Confirmation for transmission.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_STATE No Indication pending to be confirmed.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers left.
N */
NSVCALL(SD_BLE_GATTC_HV_CONFIRM, uint32_t, sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle));
Xuint32_t __svc(SD_BLE_GATTC_HV_CONFIRM) sd_ble_gattc_hv_confirm(uint16_t conn_handle, uint16_t handle);
N
N
N#endif /* BLE_GATTC_H__ */
N
N/**
N  @}
N  @}
N*/
L 27 "..\..\..\Software\Include\ble.h" 2
N#include "ble_gatts.h"
L 1 "..\..\..\Software\Include\ble_gatts.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @addtogroup BLE_GATTS Generic Attribute Profile (GATT) Server
N  @{
N  @brief  Definitions and prototypes for the GATTS interface.
N */
N
N#ifndef BLE_GATTS_H__
N#define BLE_GATTS_H__
N
N#include "ble_types.h"
N#include "ble_ranges.h"
N#include "ble_l2cap.h"
N#include "ble_gap.h"
N#include "ble_gatt.h"
N#include "nrf_svc.h"
N
N
N/**
N * @brief GATTS API SVC numbers.
N */
Nenum BLE_GATTS_SVCS
N{
N  SD_BLE_GATTS_SERVICE_ADD = BLE_GATTS_SVC_BASE, /**< Add a service. */
X  SD_BLE_GATTS_SERVICE_ADD = 0xA0,  
N  SD_BLE_GATTS_INCLUDE_ADD,                      /**< Add an included service. */
N  SD_BLE_GATTS_CHARACTERISTIC_ADD,               /**< Add a characteristic. */
N  SD_BLE_GATTS_DESCRIPTOR_ADD,                   /**< Add a generic attribute. */
N  SD_BLE_GATTS_VALUE_SET,                        /**< Set an attribute value. */
N  SD_BLE_GATTS_VALUE_GET,                        /**< Get an attribute value. */
N  SD_BLE_GATTS_HVX,                              /**< Handle Value Notification or Indication. */
N  SD_BLE_GATTS_SERVICE_CHANGED,                  /**< Perform a Service Changed Indication to one or more peers. */
N  SD_BLE_GATTS_RW_AUTHORIZE_REPLY,               /**< Reply to an authorization request for a read or write operation on one or more attributes. */ 
N  SD_BLE_GATTS_SYS_ATTR_SET,                     /**< Set the persistent system attributes for a connection. */  
N  SD_BLE_GATTS_SYS_ATTR_GET,                     /**< Get updated persistent system attributes after terminating a connection. */
N};
N
N
N/** @addtogroup BLE_GATTS_DEFINES Defines
N * @{ */
N
N/** @brief Only the default MTU size of 23 is currently supported. */
N#define GATT_RX_MTU 23
N
N/** @defgroup BLE_ERRORS_GATTS SVC return values specific to GATTS
N * @{ */
N#define BLE_ERROR_GATTS_INVALID_ATTR_TYPE   (NRF_GATTS_ERR_BASE + 0x000) /**< Invalid attribute type. */
N#define BLE_ERROR_GATTS_SYS_ATTR_MISSING    (NRF_GATTS_ERR_BASE + 0x001) /**< System Attributes missing. */
N/** @} */
N
N/** @defgroup BLE_GATTS_ATTR_LENS_MAX Maximum attribute lengths
N * @{ */
N#define BLE_GATTS_FIX_ATTR_LEN_MAX (510)  /**< Maximum length for fixed length Attribute Values. */
N#define BLE_GATTS_VAR_ATTR_LEN_MAX (512)  /**< Maximum length for variable length Attribute Values. */ 
N/** @} */
N
N/** @defgroup BLE_GATTS_SRVC_TYPES GATT Server Service Types
N * @{ */
N#define BLE_GATTS_SRVC_TYPE_INVALID          0x00  /**< Invalid Service Type. */
N#define BLE_GATTS_SRVC_TYPE_PRIMARY          0x01  /**< Primary Service. */
N#define BLE_GATTS_SRVC_TYPE_SECONDARY        0x02  /**< Secondary Type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_ATTR_TYPES GATT Server Attribute Types
N * @{ */
N#define BLE_GATTS_ATTR_TYPE_INVALID         0x00  /**< Invalid Attribute Type. */
N#define BLE_GATTS_ATTR_TYPE_PRIM_SRVC_DECL  0x01  /**< Primary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_SEC_SRVC_DECL   0x02  /**< Secondary Service Declaration. */
N#define BLE_GATTS_ATTR_TYPE_INC_DECL        0x03  /**< Include Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_DECL       0x04  /**< Characteristic Declaration. */
N#define BLE_GATTS_ATTR_TYPE_CHAR_VAL        0x05  /**< Characteristic Value. */
N#define BLE_GATTS_ATTR_TYPE_DESC            0x06  /**< Descriptor. */
N#define BLE_GATTS_ATTR_TYPE_OTHER           0x07  /**< Other, non-GATT specific type. */
N/** @} */
N
N
N/** @defgroup BLE_GATTS_OPS GATT Server Operations
N * @{ */
N#define BLE_GATTS_OP_INVALID                0x00  /**< Invalid Operation. */
N#define BLE_GATTS_OP_WRITE_REQ              0x01  /**< Write Request. */
N#define BLE_GATTS_OP_WRITE_CMD              0x02  /**< Write Command. */
N#define BLE_GATTS_OP_SIGN_WRITE_CMD         0x03  /**< Signed Write Command. */
N/** @} */
N
N/** @defgroup BLE_GATTS_VLOCS GATT Value Locations
N * @{ */
N#define BLE_GATTS_VLOC_INVALID       0x00  /**< Invalid Location. */
N#define BLE_GATTS_VLOC_STACK         0x01  /**< Attribute Value is located in stack memory, no user memory is required. */
N#define BLE_GATTS_VLOC_USER          0x02  /**< Attribute Value is located in user memory. This requires the user to maintain a valid buffer through the lifetime of the attribute, since the stack
N                                                will read and write directly to the memory using the pointer provided in the APIs. There are no alignment requirements for the buffer. */
N/** @} */
N
N/** @defgroup BLE_GATTS_AUTHORIZE_TYPES GATT Server Authorization Types
N * @{ */
N#define BLE_GATTS_AUTHORIZE_TYPE_INVALID    0x00  /**< Invalid Type. */
N#define BLE_GATTS_AUTHORIZE_TYPE_READ       0x01  /**< Authorize a Read Operation. */
N#define BLE_GATTS_AUTHORIZE_TYPE_WRITE      0x02  /**< Authorize a Write Request Operation. */
N/** @} */
N
N/** @} */
N
N/**@brief Attribute metadata. */
Ntypedef struct
N{
N  ble_gap_conn_sec_mode_t read_perm;       /**< Read permissions. */
N  ble_gap_conn_sec_mode_t write_perm;      /**< Write permissions. */
N  uint8_t                 vlen       :1;   /**< Variable length attribute. */
N  uint8_t                 vloc       :2;   /**< Value location, see @ref BLE_GATTS_VLOCS.*/
N  uint8_t                 rd_auth    :1;   /**< Read Authorization and value will be requested from the application on every read operation. */ 
N  uint8_t                 wr_auth    :1;   /**< Write Authorization will be requested from the application on every Write Request operation (but not Write Command). */
N} ble_gatts_attr_md_t;
N
N
N/**@brief GATT Attribute. */
Ntypedef struct
N{
N  ble_uuid_t*          p_uuid;          /**< Pointer to the attribute UUID. */
N  ble_gatts_attr_md_t* p_attr_md;       /**< Pointer to the attribute metadata structure. */
N  uint16_t             init_len;        /**< Initial attribute value length in bytes. */
N  uint16_t             init_offs;       /**< Initial attribute value offset in bytes. If different from zero, the first init_offs bytes of the attribute value will be left uninitialized. */
N  uint16_t             max_len;         /**< Maximum attribute value length in bytes, see @ref BLE_GATTS_ATTR_LENS_MAX for maximum values. */
N  uint8_t*             p_value;         /**< Pointer to the attribute data. Please note that if the @ref BLE_GATTS_VLOC_USER value location is selected in the attribute metadata, this will have to point to a buffer
N                                             that remains valid through the lifetime of the attribute. This excludes usage of automatic variables that may go out of scope or any other temporary location. 
N                                             The stack may access that memory directly without the application's knowledge. */
N} ble_gatts_attr_t;
N
N
N/**@brief GATT Attribute Context. */
Ntypedef struct
N{
N  ble_uuid_t           srvc_uuid;       /**< Service UUID. */
N  ble_uuid_t           char_uuid;       /**< Characteristic UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
N  ble_uuid_t           desc_uuid;       /**< Descriptor UUID if applicable (BLE_UUID_TYPE_UNKNOWN if N/A). */
N  uint16_t             srvc_handle;     /**< Service Handle. */
N  uint16_t             value_handle;    /**< Characteristic Handle if applicable (BLE_GATT_HANDLE_INVALID if N/A). */
N  uint8_t              type;            /**< Attribute Type, see @ref BLE_GATTS_ATTR_TYPES. */
N} ble_gatts_attr_context_t;
N
N
N/**@brief GATT Characteristic Presentation Format. */
Ntypedef struct
N{
N  uint8_t          format;      /**< Format of the value, see @ref BLE_GATT_CPF_FORMATS. */
N  int8_t           exponent;    /**< Exponent for integer data types. */
N  uint16_t         unit;        /**< UUID from Bluetooth Assigned Numbers. */
N  uint8_t          name_space;  /**< Namespace from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N  uint16_t         desc;        /**< Namespace description from Bluetooth Assigned Numbers, see @ref BLE_GATT_CPF_NAMESPACES. */
N} ble_gatts_char_pf_t;
N
N
N/**@brief GATT Characteristic metadata. */
Ntypedef struct
N{
N  ble_gatt_char_props_t       char_props;               /**< Characteristic Properties. */
N  ble_gatt_char_ext_props_t   char_ext_props;           /**< Characteristic Extended Properties. */
N  uint8_t*                    p_char_user_desc;         /**< Pointer to a UTF-8, NULL if the descriptor is not required. */
N  uint16_t                    char_user_desc_max_size;  /**< The maximum size in bytes of the user description descriptor. */
N  uint16_t                    char_user_desc_size;      /**< The size of the user description, must be smaller or equal to char_user_desc_max_size. */ 
N  ble_gatts_char_pf_t*        p_char_pf;                /**< Pointer to a presentation format structure or NULL if the descriptor is not required. */
N  ble_gatts_attr_md_t*        p_user_desc_md;           /**< Attribute metadata for the User Description descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_cccd_md;                /**< Attribute metadata for the Client Characteristic Configuration Descriptor, or NULL for default values. */
N  ble_gatts_attr_md_t*        p_sccd_md;                /**< Attribute metadata for the Server Characteristic Configuration Descriptor, or NULL for default values. */
N} ble_gatts_char_md_t;
N
N
N/**@brief GATT Characteristic Definition Handles. */
Ntypedef struct
N{
N  uint16_t          value_handle;       /**< Handle to the characteristic value. */
N  uint16_t          user_desc_handle;   /**< Handle to the User Description descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          cccd_handle;        /**< Handle to the Client Characteristic Configuration Descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N  uint16_t          sccd_handle;        /**< Handle to the Server Characteristic Configuration Descriptor, or BLE_GATT_HANDLE_INVALID if not present. */
N} ble_gatts_char_handles_t;
N
N
N/**@brief GATT HVx parameters. */
Ntypedef struct
N{
N  uint16_t          handle;             /**< Characteristic Value Handle. */
N  uint8_t           type;               /**< Indication or Notification, see @ref BLE_GATT_HVX_TYPES. */
N  uint16_t          offset;             /**< Offset within the attribute value. */
N  uint16_t*         p_len;              /**< Length in bytes to be written, length in bytes written after successful return. */
N  uint8_t*          p_data;             /**< Actual data content, use NULL to use the current attribute value. */
N} ble_gatts_hvx_params_t;
N
N/**@brief GATT Read Authorization parameters. */
Ntypedef struct
N{
N  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N  uint8_t           update : 1;         /**< If set, data supplied in p_data will be used in the ATT response. */
N  uint16_t          offset;             /**< Offset of the attribute value being updated. */
N  uint16_t          len;                /**< Length in bytes of the value in p_data pointer, see @ref BLE_GATTS_ATTR_LENS_MAX. */
N  uint8_t*          p_data;             /**< Pointer to new value used to update the attribute value. */
N} ble_gatts_read_authorize_params_t;
N
N/**@brief GATT Write Authorisation parameters. */
Ntypedef struct
N{
N  uint16_t          gatt_status;        /**< GATT status code for the operation, see @ref BLE_GATT_STATUS_CODES. */
N} ble_gatts_write_authorize_params_t;
N
N/**@brief GATT Read or Write Authorize Reply parameters. */
Ntypedef struct
N{
N  uint8_t                               type;   /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_read_authorize_params_t   read;   /**< Read authorization parameters. */
N    ble_gatts_write_authorize_params_t  write;  /**< Write authorization parameters. */
N  } params;
N} ble_gatts_rw_authorize_reply_params_t;
N
N/**
N * @brief GATT Server Event IDs.
N */
Nenum BLE_GATTS_EVTS
N{
N  BLE_GATTS_EVT_WRITE = BLE_GATTS_EVT_BASE,       /**< Write operation performed. */
X  BLE_GATTS_EVT_WRITE = 0x50,        
N  BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST,             /**< Read/Write Authorization request. */
N  BLE_GATTS_EVT_SYS_ATTR_MISSING,                 /**< A persistent system attribute access is pending, awaiting a sd_ble_gatts_sys_attr_set(). */
N  BLE_GATTS_EVT_HVC,                              /**< Handle Value Confirmation. */
N  BLE_GATTS_EVT_SC_CONFIRM,                       /**< Service Changed Confirmation. */
N  BLE_GATTS_EVT_TIMEOUT                           /**< Timeout. */
N};
N
N
N/**@brief Event structure for BLE_GATTS_EVT_WRITE. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  uint8_t                     op;                 /**< Type of write operation, see @ref BLE_GATTS_OPS. */
N  ble_gatts_attr_context_t    context;            /**< Attribute Context. */
N  uint16_t                    offset;             /**< Offset for the write operation. */
N  uint16_t                    len;                /**< Length of the incoming data. */
N  uint8_t                     data[1];            /**< Incoming data, variable length. */
N} ble_gatts_evt_write_t;
N
N/**@brief Event structure for authorize read request. */
Ntypedef struct
N{
N  uint16_t                    handle;             /**< Attribute Handle. */
N  ble_gatts_attr_context_t    context;            /**< Attribute Context. */
N  uint16_t                    offset;             /**< Offset for the read operation. */
N} ble_gatts_evt_read_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST. */
Ntypedef struct
N{
N  uint8_t                     type;             /**< Type of authorize operation, see @ref BLE_GATTS_AUTHORIZE_TYPES. */
N  union {
N    ble_gatts_evt_read_t      read;             /**< Attribute Read Parameters. */
N    ble_gatts_evt_write_t     write;            /**< Attribute Write Parameters. */
N  } request;
N} ble_gatts_evt_rw_authorize_request_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_SYS_ATTR_MISSING. */
Ntypedef struct
N{
N  uint8_t hint;
N} ble_gatts_evt_sys_attr_missing_t;
N
N
N/**@brief Event structure for BLE_GATTS_EVT_HVC. */
Ntypedef struct
N{
N  uint16_t          handle;                       /**< Attribute Handle. */
N} ble_gatts_evt_hvc_t;
N
N/**@brief Event structure for BLE_GATTS_EVT_TIMEOUT. */
Ntypedef struct
N{
N  uint8_t          src;                       /**< Timeout source, see @ref BLE_GATT_TIMEOUT_SOURCES. */
N} ble_gatts_evt_timeout_t;
N
N
N/**@brief GATT Server event callback event structure. */
Ntypedef struct
N{
N  uint16_t conn_handle;                                       /**< Connection Handle on which event occurred. */
N  union
N  {
N    ble_gatts_evt_write_t                 write;              /**< Write Event Parameters. */
N    ble_gatts_evt_rw_authorize_request_t  authorize_request;  /**< Read or Write Authorize Request Parameters. */
N    ble_gatts_evt_sys_attr_missing_t      sys_attr_missing;   /**< System attributes missing. */
N    ble_gatts_evt_hvc_t                   hvc;                /**< Handle Value Confirmation Event Parameters. */
N    ble_gatts_evt_timeout_t               timeout;            /**< Timeout Event. */
N  } params;
N} ble_gatts_evt_t;
N
N
N/**@brief Add a service declaration to the local server ATT table.
N *
N * @param[in] type      Toggles between primary and secondary services, see @ref BLE_GATTS_SRVC_TYPES.
N * @param[in] p_uuid    Pointer to service UUID.
N * @param[out] p_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @note Secondary Services are only relevant in the context of the entity that references them, it is therefore forbidden to
N *       add a secondary service declaration that is not referenced by another service later in the ATT table.
N *
N * @return @ref NRF_SUCCESS Successfully added a service declaration.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, Vendor Specific UUIDs need to be present in the table.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_ADD, uint32_t, sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_ADD) sd_ble_gatts_service_add(uint8_t type, ble_uuid_t const*const p_uuid, uint16_t *const p_handle);
N
N
N/**@brief Add an include declaration to the local server ATT table.
N *
N * @note It is currently only possible to add an include declaration to the last added service (i.e. only sequential addition is supported at this time). 
N *
N * @note The included service must already be present in the ATT table prior to this call.
N *
N * @param[in] service_handle    Handle of the service where the included service is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] inc_srvc_handle   Handle of the included service.
N * @param[out] p_include_handle Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added an include declaration.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, handle values need to match previously added services.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, self inclusions are not allowed.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N */
NSVCALL(SD_BLE_GATTS_INCLUDE_ADD, uint32_t, sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *const p_include_handle));
Xuint32_t __svc(SD_BLE_GATTS_INCLUDE_ADD) sd_ble_gatts_include_add(uint16_t service_handle, uint16_t inc_srvc_handle, uint16_t *const p_include_handle);
N
N
N/**@brief Add a characteristic declaration, a characteristic value declaration and optional characteristic descriptor declarations to the local server ATT table.
N *
N * @note It is currently only possible to add a characteristic to the last added service (i.e. only sequential addition is supported at this time). 
N *
N * @note Several restrictions apply to the parameters, such as matching permissions between the user description descriptor and the writeable auxiliaries bits,
N *       readable (no security) and writeable (selectable) CCCDs and SCCDs and valid presentation format values.
N *
N * @note If no metadata is provided for the optional descriptors, their permissions will be derived from the characteristic permissions.
N *
N * @param[in] service_handle    Handle of the service where the characteristic is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_char_md         Characteristic metadata.
N * @param[in] p_attr_char_value Pointer to the attribute structure corresponding to the characteristic value.
N * @param[out] p_handles        Pointer to the structure where the assigned handles will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added a characteristic.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, service handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, a service context is required.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_CHARACTERISTIC_ADD, uint32_t, sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const*const p_char_md, ble_gatts_attr_t const*const p_attr_char_value, ble_gatts_char_handles_t *const p_handles));
Xuint32_t __svc(SD_BLE_GATTS_CHARACTERISTIC_ADD) sd_ble_gatts_characteristic_add(uint16_t service_handle, ble_gatts_char_md_t const*const p_char_md, ble_gatts_attr_t const*const p_attr_char_value, ble_gatts_char_handles_t *const p_handles);
N
N
N/**@brief Add a descriptor to the local server ATT table.
N *
N * @note It is currently only possible to add a descriptor to the last added characteristic (i.e. only sequential addition is supported at this time). 
N *
N * @param[in] char_handle   Handle of the characteristic where the descriptor is to be placed, if BLE_GATT_HANDLE_INVALID is used, it will be placed sequentially.
N * @param[in] p_attr        Pointer to the attribute structure.
N * @param[out] p_handle     Pointer to a 16-bit word where the assigned handle will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added a descriptor.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied, characteristic handle, Vendor Specific UUIDs, lengths, and permissions need to adhere to the constraints.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, a characteristic context is required.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden value supplied, certain UUIDs are reserved for the stack.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_DESCRIPTOR_ADD, uint32_t, sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const * const p_attr, uint16_t* const p_handle));
Xuint32_t __svc(SD_BLE_GATTS_DESCRIPTOR_ADD) sd_ble_gatts_descriptor_add(uint16_t char_handle, ble_gatts_attr_t const * const p_attr, uint16_t* const p_handle);
N
N/**@brief Set the value of a given attribute.
N *
N * @param[in] handle    Attribute handle.
N * @param[in] offset    Offset in bytes to write from.
N * @param[in,out] p_len Length in bytes to be written, length in bytes written after successful return.
N * @param[in] p_value   Pointer to a buffer (at least len bytes long) containing the desired attribute value.
N *
N * @return @ref NRF_SUCCESS Successfully set the value of the attribute.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N * @return @ref NRF_ERROR_FORBIDDEN Forbidden handle supplied, certain attributes are not modifiable by the application.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied, attribute lengths are restricted by @ref BLE_GATTS_ATTR_LENS_MAX.
N */
NSVCALL(SD_BLE_GATTS_VALUE_SET, uint32_t, sd_ble_gatts_value_set(uint16_t handle, uint16_t offset, uint16_t* const p_len, uint8_t const * const p_value));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_SET) sd_ble_gatts_value_set(uint16_t handle, uint16_t offset, uint16_t* const p_len, uint8_t const * const p_value);
N
N/**@brief Get the value of a given attribute.
N *
N * @param[in] handle     Attribute handle.
N * @param[in] offset     Offset in bytes to read from.
N * @param[in,out] p_len  Length in bytes to be read, length in bytes read after successful return.
N * @param[in,out] p_data Pointer to a buffer (at least len bytes long) where to store the attribute value.
N * 
N * @return @ref NRF_SUCCESS Successfully retrieved the value of the attribute.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N */
NSVCALL(SD_BLE_GATTS_VALUE_GET, uint32_t, sd_ble_gatts_value_get(uint16_t handle, uint16_t offset, uint16_t *const p_len, uint8_t* const p_data));
Xuint32_t __svc(SD_BLE_GATTS_VALUE_GET) sd_ble_gatts_value_get(uint16_t handle, uint16_t offset, uint16_t *const p_len, uint8_t* const p_data);
N
N/**@brief Notify or Indicate an attribute value.
N *
N * @details This function checks for the relevant Client Characteristic Configuration descriptor value to verify that the relevant operation
N *          (notification or indication) has been enabled by the client. It is also able to update the attribute value before issuing the PDU, so that
N *          the application can atomically perform a value update and a server initiated transaction with a single API call.
N *          If the application chooses to indicate an attribute value, a @ref BLE_GATTS_EVT_HVC will be sent up as soon as the confirmation arrives from
N *          the peer.
N *
N * @note    The local attribute value may be updated even if an outgoing packet is not sent to the peer due to an error during execution. 
N *          When receiveing the error codes @ref NRF_ERROR_INVALID_STATE, @ref NRF_ERROR_BUSY, @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING and 
N *          @ref BLE_ERROR_NO_TX_BUFFERS the ATT table has been updated.
N *          The caller can check whether the value has been updated by looking at the contents of *(p_hvx_params->p_len).
N *
N * @note    It is important to note that a notification will <b>consume an application buffer</b>, and will therefore 
N *          generate a @ref BLE_EVT_TX_COMPLETE event when the packet has been transmitted. An indication on the other hand will use the 
N *          standard server internal buffer and thus will only generate a @ref BLE_GATTS_EVT_HVC event as soon as the confirmation 
N *          has been received from the peer. Please see the documentation of @ref sd_ble_tx_buffer_count_get for more details.
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] p_hvx_params Pointer to an HVx parameters structure. If the p_data member contains a non-NULL pointer the attribute value will be updated with
N *                         the contents pointed by it before sending the notification or indication.
N *
N * @return @ref NRF_SUCCESS Successfully queued a notification or indication for transmission, and optionally updated the attribute value.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied. Only attributes added directly by the application are available to notify and indicate.
N * @return @ref BLE_ERROR_GATTS_INVALID_ATTR_TYPE Invalid attribute type(s) supplied, only characteristic values may be notified and indicated.
N * @return @ref NRF_ERROR_NOT_FOUND Attribute not found.
N * @return @ref NRF_ERROR_DATA_SIZE Invalid data size(s) supplied.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, notifications or indications must be enabled in the CCCD.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N * @return @ref BLE_ERROR_NO_TX_BUFFERS There are no available buffers to send the data, applies only to notifications.
N */
NSVCALL(SD_BLE_GATTS_HVX, uint32_t, sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const*const p_hvx_params));
Xuint32_t __svc(SD_BLE_GATTS_HVX) sd_ble_gatts_hvx(uint16_t conn_handle, ble_gatts_hvx_params_t const*const p_hvx_params);
N
N/**@brief Indicate the Service Changed attribute value.
N *
N * @details This call will send a Handle Value Indication to one or more peers connected to inform them that the attribute
N *          table layout has changed. As soon as the peer has confirmed the indication, a @ref BLE_GATTS_EVT_SC_CONFIRM event will
N *          be issued.
N *
N * @note    Some of the restrictions and limitations that apply to @ref sd_ble_gatts_hvx also apply here.
N *
N * @param[in] conn_handle  Connection handle.
N * @param[in] start_handle Start of affected attribute handle range.
N * @param[in] end_handle   End of affected attribute handle range.
N *
N * @return @ref NRF_SUCCESS Successfully queued the Service Changed indication for transmission.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid parameter(s) supplied.
N * @return @ref BLE_ERROR_INVALID_ATTR_HANDLE Invalid attribute handle(s) supplied, handles must be in the range populated by the application.
N * @return @ref NRF_ERROR_INVALID_STATE Invalid state to perform operation, notifications or indications must be enabled in the CCCD.
N * @return @ref NRF_ERROR_BUSY Procedure already in progress.
N * @return @ref BLE_ERROR_GATTS_SYS_ATTR_MISSING System attributes missing, use @ref sd_ble_gatts_sys_attr_set to set them to a known value.
N */
NSVCALL(SD_BLE_GATTS_SERVICE_CHANGED, uint32_t, sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle));
Xuint32_t __svc(SD_BLE_GATTS_SERVICE_CHANGED) sd_ble_gatts_service_changed(uint16_t conn_handle, uint16_t start_handle, uint16_t end_handle);
N
N/**@brief Respond to a Read/Write authorization request.
N *
N * @note This call should only be used as a response to a @ref BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST event issued to the application.
N *
N * @param[in] conn_handle                 Connection handle.
N * @param[in] p_rw_authorize_reply_params Pointer to a structure with the attribute provided by the application.
N *
N * @return @ref NRF_SUCCESS               Successfully queued a response to the peer, and in the case of a write operation, ATT table updated.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_STATE   No authorization request pending.
N * @return @ref NRF_ERROR_INVALID_PARAM   Authorization op invalid,
N *                                         or for Read Authorization reply: requested handles not replied with,
N *                                         or for Write Authorization reply: handle supplied does not match requested handle.
N */
NSVCALL(SD_BLE_GATTS_RW_AUTHORIZE_REPLY, uint32_t, sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const*const p_rw_authorize_reply_params));
Xuint32_t __svc(SD_BLE_GATTS_RW_AUTHORIZE_REPLY) sd_ble_gatts_rw_authorize_reply(uint16_t conn_handle, ble_gatts_rw_authorize_reply_params_t const*const p_rw_authorize_reply_params);
N
N
N/**@brief Update persistent system attribute information.
N *
N * @details Supply to the stack information about persistent system attributes.
N *          This call is legal in the connected state only, and is usually 
N *          made immediately after a connection is established and the bond identified.
N *          usually as a response to a BLE_GATTS_EVT_SYS_ATTR_MISSING.
N *
N *          p_sysattrs may point directly to the application's stored copy of the struct.
N *          If the pointer is NULL, the system attribute info is initialized, assuming that
N *          the application does not have any previously saved data for this bond.
N *
N * @note The state of persistent system attributes is reset upon connection and then remembered for its duration. 
N *
N * @note If this call returns with an error code different from @ref NRF_SUCCESS, the storage of persistent system attributes may have been completed only partially.
N *       This means that the state of the attribute table is undefined, and the application should either provide a new set of attributes using this same call or
N *       reset the SoftDevice to return to a known state.
N *
N * @param[in]  conn_handle        Connection handle.
N * @param[in]  p_sys_attr_data    Pointer to a saved copy of system attributes supplied to the stack, or NULL.
N * @param[in]  len                Size of data pointed by p_sys_attr_data, in octets. 
N *
N * @return @ref NRF_SUCCESS Successfully set the system attribute information.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_DATA Invalid data supplied, the data should be exactly the same as retrieved with @ref sd_ble_gatts_sys_attr_get.
N * @return @ref NRF_ERROR_NO_MEM Not enough memory to complete operation.
N */ 
NSVCALL(SD_BLE_GATTS_SYS_ATTR_SET, uint32_t, sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const*const p_sys_attr_data, uint16_t len)); 
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_SET) sd_ble_gatts_sys_attr_set(uint16_t conn_handle, uint8_t const*const p_sys_attr_data, uint16_t len); 
N
N 
N/**@brief Retrieve persistent system attribute information from the stack.
N *
N * @details This call is used to retrieve information about values to be stored perisistently by the application
N *          after a connection has been terminated. When a new connection is made to the same bond, the values
N *          should be restored using @ref sd_ble_gatts_sys_attr_set.
N *          The data should be read before any new advertising is started, or any new connection established. The connection handle for
N *          the previous now defunct connection will remain valid until a new one is created to allow this API call to refer to it.
N *
N * @param[in]     conn_handle       Connection handle of the recently terminated connection.
N * @param[in]     p_sys_attr_data   Pointer to a buffer where updated information about system attributes will be filled in. NULL can be provided to 
N *                                  obtain the length of the data
N * @param[in,out] p_len             Size of application buffer if p_sys_attr_data is not NULL. Unconditially updated to actual length of system attribute data.
N *
N * @return @ref NRF_SUCCESS Successfully retrieved the system attribute information.
N * @return @ref BLE_ERROR_INVALID_CONN_HANDLE Invalid Connection Handle.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_DATA_SIZE The system attribute information did not fit into the provided buffer.
N */ 
NSVCALL(SD_BLE_GATTS_SYS_ATTR_GET, uint32_t, sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t * const p_sys_attr_data, uint16_t* const p_len)); 
Xuint32_t __svc(SD_BLE_GATTS_SYS_ATTR_GET) sd_ble_gatts_sys_attr_get(uint16_t conn_handle, uint8_t * const p_sys_attr_data, uint16_t* const p_len); 
N
N
N#endif // BLE_GATTS_H__
N
N/**
N  @}
N*/
L 28 "..\..\..\Software\Include\ble.h" 2
N
N/**
N * @brief Common API SVC numbers.
N */
Nenum BLE_COMMON_SVCS
N{
N  SD_BLE_EVT_GET  = BLE_SVC_BASE,       /**< Get an event from the pending events queue. */
X  SD_BLE_EVT_GET  = 0x50,        
N  SD_BLE_TX_BUFFER_COUNT_GET,           /**< Get the total number of available application transmission buffers from the stack. */
N  SD_BLE_UUID_VS_ADD,                   /**< Add a Vendor Specific UUID. */
N  SD_BLE_UUID_DECODE,                   /**< Decode UUID bytes. */
N  SD_BLE_UUID_ENCODE,                   /**< Encode UUID bytes. */
N  SD_BLE_VERSION_GET                    /**< Get the local version information (company id, LMP Version, LMP Subversion). */
N};
N
N/** @brief  Required pointer alignment for BLE Events.
N*/
N#define BLE_EVTS_PTR_ALIGNMENT    4
N
N/**
N * @brief BLE Module Independent Event IDs.
N */
Nenum BLE_COMMON_EVTS
N{
N  BLE_EVT_TX_COMPLETE  = BLE_EVT_BASE,  /**< Transmission Complete. */
X  BLE_EVT_TX_COMPLETE  = 0x01,   
N};
N
N
N/**
N * @brief TX complete event.
N */
Ntypedef struct
N{
N  uint8_t count;                        /**< Number of packets transmitted. */
N} ble_evt_tx_complete_t;
N
N
N/**@brief Event structure for events not associated with a specific function module. */
Ntypedef struct
N{
N  uint16_t conn_handle;                 /**< Connection Handle on which this event occured. */
N  union
N  {
N    ble_evt_tx_complete_t tx_complete;  /**< Transmission Complete. */
N  } params;
N} ble_common_evt_t;
N
N/**@brief BLE Event header. */
Ntypedef struct
N{
N  uint16_t evt_id;                      /**< Value from a BLE_<module>_EVT series. */
N  uint16_t evt_len;                     /**< Length in octets excluding this header. */
N} ble_evt_hdr_t;
N
N/**@brief Common BLE Event type, wrapping the module specific event reports. */
Ntypedef struct
N{
N  ble_evt_hdr_t header;                 /**< Event header. */
N  union
N  {
N    ble_common_evt_t  common_evt;         /**< Common Event, evt_id in BLE_EVT_* series. */
N    ble_gap_evt_t     gap_evt;            /**< GAP originated event, evt_id in BLE_GAP_EVT_* series. */
N    ble_l2cap_evt_t   l2cap_evt;          /**< L2CAP originated event, evt_id in BLE_L2CAP_EVT* series. */
N    ble_gattc_evt_t   gattc_evt;          /**< GATT client originated event, evt_id in BLE_GATTC_EVT* series. */
N    ble_gatts_evt_t   gatts_evt;          /**< GATT server originated event, evt_id in BLE_GATTS_EVT* series. */
N  } evt;
N} ble_evt_t;
N
N
N/**
N * @brief Version Information.
N */
Ntypedef struct
N{
N  uint8_t   version_number;             /**< LMP Version number for BT 4.0 spec is 6 (https://www.bluetooth.org/technical/assignednumbers/link_layer.htm). */
N  uint16_t  company_id;                 /**< Company ID, Nordic Semiconductor's company ID is 89 (0x0059) (https://www.bluetooth.org/apps/content/Default.aspx?doc_id=49708). */
N  uint16_t  subversion_number;          /**< LMP Sub Version number corresponds to the SoftDevice Config ID. */
N} ble_version_t;
N
N
N/**@brief Get an event from the pending events queue.
N *
N * @param[in] p_dest Pointer to buffer to be filled in with an event, or NULL to retrieve the event length. This buffer <b>must be 4-byte aligned in memory</b>.
N * @param[in, out] p_len Pointer the length of the buffer, on return it is filled with the event length.
N *
N * @details This call allows the application to pull a BLE event from the BLE stack. The application is signalled that an event is 
N * available from the BLE Stack by the triggering of the SD_EVENT_IRQn interrupt (mapped to IRQ 22).
N * The application is free to choose whether to call this function from thread mode (main context) or directly from the Interrupt Service Routine
N * that maps to SD_EVENT_IRQn. In any case however, and because the BLE stack runs at a higher priority than the application, this function should be called
N * in a loop (until @ref NRF_ERROR_NOT_FOUND is returned) every time SD_EVENT_IRQn is raised to ensure that all available events are pulled from the stack. 
N * Failure to do so could potentially leave events in the internal queue without the application being aware of this fact.
N * Sizing the p_dest buffer is equally important, since the application needs to provide all the memory necessary for the event to be copied into
N * application memory. If the buffer provided is not large enough to fit the entire contents of the event, @ref NRF_ERROR_DATA_SIZE will be returned
N * and the application can then call again with a larger buffer size.
N * Please note that because of the variable length nature of some events, sizeof(ble_evt_t) will not always be large enough to fit certain events, 
N * and so it is the application's responsability to provide an amount of memory large enough so that the relevant event is copied in full.
N * The application may "peek" the event length by providing p_dest as a NULL pointer and inspecting the value of *p_len upon return.
N *
N * @note The pointer supplied must be aligned to the extend defined by @ref BLE_EVTS_PTR_ALIGNMENT
N *
N * @return @ref NRF_SUCCESS Event pulled and stored into the supplied buffer.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid or not sufficiently aligned pointer supplied.
N * @return @ref NRF_ERROR_NOT_FOUND No events ready to be pulled.
N * @return @ref NRF_ERROR_DATA_SIZE Event ready but could not fit into the supplied buffer.
N */
NSVCALL(SD_BLE_EVT_GET, uint32_t, sd_ble_evt_get(uint8_t* p_dest, uint16_t *p_len));
Xuint32_t __svc(SD_BLE_EVT_GET) sd_ble_evt_get(uint8_t* p_dest, uint16_t *p_len);
N
N
N/**@brief Get the total number of available application transmission buffers in the BLE stack.
N *
N * @details This call allows the application to obtain the total number of
N *          transmission buffers available for application data. Please note that
N *          this does not give the number of free buffers, but rather the total amount of them.
N *          The application has two options to handle its own application transmission buffers:
N *          - Use a simple arithmetic calculation: at boot time the application should use this function
N *          to find out the total amount of buffers available to it and store it in a variable.
N *          Every time a packet that consumes an application buffer is sent using any of the 
N *          exposed functions in this BLE API, the application should decrement that variable.
N *          Conversely, whenever a @ref BLE_EVT_TX_COMPLETE event is received by the application
N *          it should retrieve the count field in such event and add that number to the same
N *          variable storing the number of available packets.
N *          This mechanism allows the application to be aware at any time of the number of
N *          application packets available in the BLE stack's internal buffers, and therefore
N *          it can know with certainty whether it is possible to send more data or it has to
N *          wait for a @ref BLE_EVT_TX_COMPLETE event before it proceeds.
N *          - Choose to simply not keep track of available buffers at all, and instead handle the 
N *          @ref BLE_ERROR_NO_TX_BUFFERS error by queueing the packet to be transmitted and 
N *          try again as soon as a @ref BLE_EVT_TX_COMPLETE event arrives.
N *
N *          The API functions that <b>may</b> consume an application buffer depending on 
N *          the parameters supplied to them can be found below:
N *
N *          - @ref sd_ble_gattc_write (write witout response only)
N *          - @ref sd_ble_gatts_hvx (notifications only)
N *          - @ref sd_ble_l2cap_tx (all packets)
N *
N * @param[out] p_count Pointer to a uint8_t which will contain the number of application transmission buffers upon
N *                     successful return.
N *
N * @return @ref NRF_SUCCESS Number of application transmission buffers retrieved successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N */
NSVCALL(SD_BLE_TX_BUFFER_COUNT_GET, uint32_t, sd_ble_tx_buffer_count_get(uint8_t* p_count));
Xuint32_t __svc(SD_BLE_TX_BUFFER_COUNT_GET) sd_ble_tx_buffer_count_get(uint8_t* p_count);
N
N
N/**@brief Add a Vendor Specific UUID.
N *
N * @details This call enables the application to add a vendor specific UUID to the BLE stack's table,
N *          for later use all other modules and APIs. This then allows the application to use the shorter,
N *          24-bit @ref ble_uuid_t format when dealing with both 16-bit and 128-bit UUIDs without having to
N *          check for lengths and having split code paths. The way that this is accomplished is by extending the 
N *          grouping mechanism that the Bluetooth SIG standard base UUID uses for all other 128-bit UUIDs. The 
N *          type field in the @ref ble_uuid_t structure is an index (relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN) 
N *          to the table populated by multiple calls to this function, and the uuid field in the same structure contains the 2 bytes 
N *          (byte 12 and byte 13) corresponding to the TimeLow portion of the UUID. The number of possible 128-bit 
N *          UUIDs available to the application is therefore the number of Vendor Specific UUIDs added with the help
N *          of this function times 65536, although restricted to modifying the TimeLow bytes for each of the entries in the supplied array.
N *
N * @note Bytes 12 and 13 of the provided UUID will not be used internally, since those are always replaced by 
N * the 16-bit uuid field in @ref ble_uuid_t.
N *
N *
N * @param[in]  p_vs_uuid    Pointer to a 16-octet (128-bit) little endian Vendor Specific UUID disregarding
N *                          the TimeLow (bytes 12 and 13) portion of it.
N * @param[out] p_uuid_type  Pointer where the type field in @ref ble_uuid_t corresponding to this UUID will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully added the Vendor Specific UUID.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_NO_MEM If the size exceeds the number of free slots for VS UUIDs.
N * @return @ref NRF_ERROR_INVALID_LENGTH If vs_uuid_count is 0.
N * @return @ref NRF_ERROR_INVALID_ADDR if p_vs_uuids is NULL or invalid.
N */
NSVCALL(SD_BLE_UUID_VS_ADD, uint32_t, sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type));
Xuint32_t __svc(SD_BLE_UUID_VS_ADD) sd_ble_uuid_vs_add(ble_uuid128_t const * const p_vs_uuid, uint8_t * const p_uuid_type);
N
N
N/** @brief Decode little endian raw UUID bytes (16-bit or 128-bit) into a 24 bit @ref ble_uuid_t structure.
N * 
N * @details The raw UUID bytes excluding the TimeLow portion (i.e. bytes 0-11 and 14-15) of p_uuid_le are compared 
N * to the corresponding ones in each entry of the table of vendor specific UUIDs pouplated with @ref sd_ble_uuid_vs_add 
N * to look for a match. If there is such a match, bytes 12 and 13 are returned as p_uuid->uuid and the index 
N * relative to @ref BLE_UUID_TYPE_VENDOR_BEGIN as p_uuid->type. 
N *
N * @note If the UUID length supplied is 2, then the type set by this call will always be @ref BLE_UUID_TYPE_BLE.
N *
N * @param[in]      uuid_le_len Length in bytes of the buffer pointed to by p_uuid_le (must be 2 or 16 bytes).
N * @param[in]      p_uuid_le   Pointer pointing to little endian raw UUID bytes.
N * @param[in,out]  p_uuid      Pointer to a @ref ble_uuid_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS Successfully decoded into the @ref ble_uuid_t structure.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_LENGTH Invalid UUID length.
N * @return @ref NRF_ERROR_NOT_FOUND For a 128-bit UUID, no match in the populated table of UUIDs.
N */                                                 
NSVCALL(SD_BLE_UUID_DECODE, uint32_t, sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const * const p_uuid_le, ble_uuid_t * const p_uuid));
Xuint32_t __svc(SD_BLE_UUID_DECODE) sd_ble_uuid_decode(uint8_t uuid_le_len, uint8_t const * const p_uuid_le, ble_uuid_t * const p_uuid);
N
N
N/** @brief Encode a @ref ble_uuid_t structure into little endian raw UUID bytes (16-bit or 128-bit).
N *
N * @note The pointer to the destination buffer p_uuid_le may be NULL, in which case only the validitiy and size of p_uuid is computed.
N *
N * @param[in]      p_uuid        Pointer to a @ref ble_uuid_t structure that will be encoded into bytes.
N * @param[out]     p_uuid_le_len Pointer to a uint8_t that will be filled with the encoded length (2 or 16 bytes).
N * @param[out]     p_uuid_le     Pointer to a buffer where the little endian raw UUID bytes (2 or 16) will be stored.
N *
N * @return @ref NRF_SUCCESS Successfully encoded into the buffer.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_INVALID_PARAM Invalid UUID type.
N */
NSVCALL(SD_BLE_UUID_ENCODE, uint32_t, sd_ble_uuid_encode(ble_uuid_t const * const p_uuid, uint8_t * const  p_uuid_le_len, uint8_t * const p_uuid_le));
Xuint32_t __svc(SD_BLE_UUID_ENCODE) sd_ble_uuid_encode(ble_uuid_t const * const p_uuid, uint8_t * const p_uuid_le_len, uint8_t * const p_uuid_le);
N
N
N/**@brief Get Version Information.
N *
N * @details This call allows the application to get the BLE stack version information.
N *
N * @param[in] p_version Pointer to ble_version_t structure to be filled in.
N *
N * @return @ref NRF_SUCCESS  Version information stored successfully.
N * @return @ref NRF_ERROR_INVALID_ADDR Invalid pointer supplied.
N * @return @ref NRF_ERROR_BUSY The stack is busy (typically doing a locally-initiated disconnection procedure).
N */
NSVCALL(SD_BLE_VERSION_GET, uint32_t, sd_ble_version_get(ble_version_t * p_version));
Xuint32_t __svc(SD_BLE_VERSION_GET) sd_ble_version_get(ble_version_t * p_version);
N
N#endif /* BLE_H__ */
N
N/**
N  @}
N  @}
N*/
L 33 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "nrf51.h"
L 1 "..\..\..\Software\Include\nrf51.h" 1
N
N/****************************************************************************************************//**
N * @file     nRF51.h
N *
N * @brief    CMSIS Cortex-M0 Peripheral Access Layer Header File for
N *           nRF51 from Nordic Semiconductor.
N *
N * @version  V2.4C
N * @date     26. September 2013
N *
N * @note     Generated with SVDConv V2.77p 
N *           from CMSIS SVD File 'nRF51.xml' Version 2.4C,
N *
N * @par      Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved. 
N *           
N *           The information contained herein is property of Nordic Semiconductor ASA. 
N *           Terms and conditions of usage are described in detail in NORDIC 
N *           SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
N *           
N *           Licensees are granted free, non-transferable use of the information. NO 
N *           WARRANTY of ANY KIND is provided. This heading must NOT be removed from 
N *           the file. 
N *           
N *
N *******************************************************************************************************/
N
N
N
N/** @addtogroup Nordic Semiconductor
N  * @{
N  */
N
N/** @addtogroup nRF51
N  * @{
N  */
N
N#ifndef NRF51_H
N#define NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/* -------------------------  Interrupt Number Definition  ------------------------ */
N
Ntypedef enum {
N/* -------------------  Cortex-M0 Processor Exceptions Numbers  ------------------- */
N  Reset_IRQn                    = -15,              /*!<   1  Reset Vector, invoked on Power up and warm reset                 */
N  NonMaskableInt_IRQn           = -14,              /*!<   2  Non maskable Interrupt, cannot be stopped or preempted           */
N  HardFault_IRQn                = -13,              /*!<   3  Hard Fault, all classes of Fault                                 */
N  SVCall_IRQn                   =  -5,              /*!<  11  System Service Call via SVC instruction                          */
N  DebugMonitor_IRQn             =  -4,              /*!<  12  Debug Monitor                                                    */
N  PendSV_IRQn                   =  -2,              /*!<  14  Pendable request for system service                              */
N  SysTick_IRQn                  =  -1,              /*!<  15  System Tick Timer                                                */
N/* ----------------------  nRF51 Specific Interrupt Numbers  ---------------------- */
N  POWER_CLOCK_IRQn              =   0,              /*!<   0  POWER_CLOCK                                                      */
N  RADIO_IRQn                    =   1,              /*!<   1  RADIO                                                            */
N  UART0_IRQn                    =   2,              /*!<   2  UART0                                                            */
N  SPI0_TWI0_IRQn                =   3,              /*!<   3  SPI0_TWI0                                                        */
N  SPI1_TWI1_IRQn                =   4,              /*!<   4  SPI1_TWI1                                                        */
N  GPIOTE_IRQn                   =   6,              /*!<   6  GPIOTE                                                           */
N  ADC_IRQn                      =   7,              /*!<   7  ADC                                                              */
N  TIMER0_IRQn                   =   8,              /*!<   8  TIMER0                                                           */
N  TIMER1_IRQn                   =   9,              /*!<   9  TIMER1                                                           */
N  TIMER2_IRQn                   =  10,              /*!<  10  TIMER2                                                           */
N  RTC0_IRQn                     =  11,              /*!<  11  RTC0                                                             */
N  TEMP_IRQn                     =  12,              /*!<  12  TEMP                                                             */
N  RNG_IRQn                      =  13,              /*!<  13  RNG                                                              */
N  ECB_IRQn                      =  14,              /*!<  14  ECB                                                              */
N  CCM_AAR_IRQn                  =  15,              /*!<  15  CCM_AAR                                                          */
N  WDT_IRQn                      =  16,              /*!<  16  WDT                                                              */
N  RTC1_IRQn                     =  17,              /*!<  17  RTC1                                                             */
N  QDEC_IRQn                     =  18,              /*!<  18  QDEC                                                             */
N  LPCOMP_COMP_IRQn              =  19,              /*!<  19  LPCOMP_COMP                                                      */
N  SWI0_IRQn                     =  20,              /*!<  20  SWI0                                                             */
N  SWI1_IRQn                     =  21,              /*!<  21  SWI1                                                             */
N  SWI2_IRQn                     =  22,              /*!<  22  SWI2                                                             */
N  SWI3_IRQn                     =  23,              /*!<  23  SWI3                                                             */
N  SWI4_IRQn                     =  24,              /*!<  24  SWI4                                                             */
N  SWI5_IRQn                     =  25               /*!<  25  SWI5                                                             */
N} IRQn_Type;
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N/* ================================================================================ */
N/* ================      Processor and Core Peripheral Section     ================ */
N/* ================================================================================ */
N
N/* ----------------Configuration of the cm0 Processor and Core Peripherals---------------- */
N#define __CM0_REV                 0x0301            /*!< Cortex-M0 Core Revision                                               */
N#define __MPU_PRESENT                  0            /*!< MPU present or not                                                    */
N#define __NVIC_PRIO_BITS               2            /*!< Number of Bits used for Priority Levels                               */
N#define __Vendor_SysTickConfig         0            /*!< Set to 1 if different SysTick Config is used                          */
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include <core_cm0.h>                               /*!< Cortex-M0 processor and core peripherals                              */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.02
N * @date     16. July 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.02
N * @date     08. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 113 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "C:\Keil\ARM\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.02
N * @date     24. May 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5020028 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N#endif /* __CORE_CMFUNC_H */
L 114 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
X  if ((ticks - 1) > (0xFFFFFFUL << 0))  return (1);       
N
N  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = ticks - 1;                                   
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 102 "..\..\..\Software\Include\nrf51.h" 2
N#include "system_nrf51.h"                           /*!< nRF51 System                                                          */
L 1 "..\..\..\Software\Include\system_nrf51.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef SYSTEM_NRF51_H
N#define SYSTEM_NRF51_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock)  */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_NRF51_H */
L 103 "..\..\..\Software\Include\nrf51.h" 2
N
N
N/* ================================================================================ */
N/* ================       Device Specific Peripheral Section       ================ */
N/* ================================================================================ */
N
N
N/** @addtogroup Device_Peripheral_Registers
N  * @{
N  */
N
N
N/* -------------------  Start of section using anonymous unions  ------------------ */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined(__ICCARM__)
S  #pragma language=extended
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S/* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning 586
S#else
S  #warning Not supported compiler type
N#endif
N
N
Ntypedef struct {
N  __IO uint32_t  CPU0;                              /*!< Configurable priority configuration register for CPU0.                */
X  volatile uint32_t  CPU0;                               
N  __IO uint32_t  SPIS1;                             /*!< Configurable priority configuration register for SPIS1.               */
X  volatile uint32_t  SPIS1;                              
N  __IO uint32_t  RADIO;                             /*!< Configurable priority configuration register for RADIO.               */
X  volatile uint32_t  RADIO;                              
N  __IO uint32_t  ECB;                               /*!< Configurable priority configuration register for ECB.                 */
X  volatile uint32_t  ECB;                                
N  __IO uint32_t  CCM;                               /*!< Configurable priority configuration register for CCM.                 */
X  volatile uint32_t  CCM;                                
N  __IO uint32_t  AAR;                               /*!< Configurable priority configuration register for AAR.                 */
X  volatile uint32_t  AAR;                                
N} AMLI_RAMPRI_Type;
N
Ntypedef struct {
N  __O  uint32_t  EN;                                /*!< Enable channel group.                                                 */
X  volatile  uint32_t  EN;                                 
N  __O  uint32_t  DIS;                               /*!< Disable channel group.                                                */
X  volatile  uint32_t  DIS;                                
N} PPI_TASKS_CHG_Type;
N
Ntypedef struct {
N  __IO uint32_t  EEP;                               /*!< Channel event end-point.                                              */
X  volatile uint32_t  EEP;                                
N  __IO uint32_t  TEP;                               /*!< Channel task end-point.                                               */
X  volatile uint32_t  TEP;                                
N} PPI_CH_Type;
N
N
N/* ================================================================================ */
N/* ================                      POWER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Power Control. (POWER)
N  */
N
Ntypedef struct {                                    /*!< POWER Structure                                                       */
N  __I  uint32_t  RESERVED0[30];
X  volatile const  uint32_t  RESERVED0[30];
N  __O  uint32_t  TASKS_CONSTLAT;                    /*!< Enable constant latency mode.                                         */
X  volatile  uint32_t  TASKS_CONSTLAT;                     
N  __O  uint32_t  TASKS_LOWPWR;                      /*!< Enable low power mode (variable latency).                             */
X  volatile  uint32_t  TASKS_LOWPWR;                       
N  __I  uint32_t  RESERVED1[34];
X  volatile const  uint32_t  RESERVED1[34];
N  __IO uint32_t  EVENTS_POFWARN;                    /*!< Power failure warning.                                                */
X  volatile uint32_t  EVENTS_POFWARN;                     
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __IO uint32_t  RESETREAS;                         /*!< Reset reason.                                                         */
X  volatile uint32_t  RESETREAS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __O  uint32_t  SYSTEMOFF;                         /*!< System off register.                                                  */
X  volatile  uint32_t  SYSTEMOFF;                          
N  __I  uint32_t  RESERVED5[3];
X  volatile const  uint32_t  RESERVED5[3];
N  __IO uint32_t  POFCON;                            /*!< Power failure configuration.                                          */
X  volatile uint32_t  POFCON;                             
N  __I  uint32_t  RESERVED6[2];
X  volatile const  uint32_t  RESERVED6[2];
N  __IO uint32_t  GPREGRET;                          /*!< General purpose retention register. This register is a retained
X  volatile uint32_t  GPREGRET;                          
N                                                         register.                                                             */
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __IO uint32_t  RAMON;                             /*!< Ram on/off.                                                           */
X  volatile uint32_t  RAMON;                              
N  __I  uint32_t  RESERVED8[7];
X  volatile const  uint32_t  RESERVED8[7];
N  __IO uint32_t  RESET;                             /*!< Pin reset functionality configuration register. This register
X  volatile uint32_t  RESET;                             
N                                                         is a retained register.                                               */
N  __I  uint32_t  RESERVED9[12];
X  volatile const  uint32_t  RESERVED9[12];
N  __IO uint32_t  DCDCEN;                            /*!< DCDC converter enable configuration register.                         */
X  volatile uint32_t  DCDCEN;                             
N} NRF_POWER_Type;
N
N
N/* ================================================================================ */
N/* ================                      CLOCK                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Clock control. (CLOCK)
N  */
N
Ntypedef struct {                                    /*!< CLOCK Structure                                                       */
N  __O  uint32_t  TASKS_HFCLKSTART;                  /*!< Start HFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_HFCLKSTART;                   
N  __O  uint32_t  TASKS_HFCLKSTOP;                   /*!< Stop HFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_HFCLKSTOP;                    
N  __O  uint32_t  TASKS_LFCLKSTART;                  /*!< Start LFCLK clock source.                                             */
X  volatile  uint32_t  TASKS_LFCLKSTART;                   
N  __O  uint32_t  TASKS_LFCLKSTOP;                   /*!< Stop LFCLK clock source.                                              */
X  volatile  uint32_t  TASKS_LFCLKSTOP;                    
N  __O  uint32_t  TASKS_CAL;                         /*!< Start calibration of LFCLK RC oscillator.                             */
X  volatile  uint32_t  TASKS_CAL;                          
N  __O  uint32_t  TASKS_CTSTART;                     /*!< Start calibration timer.                                              */
X  volatile  uint32_t  TASKS_CTSTART;                      
N  __O  uint32_t  TASKS_CTSTOP;                      /*!< Stop calibration timer.                                               */
X  volatile  uint32_t  TASKS_CTSTOP;                       
N  __I  uint32_t  RESERVED0[57];
X  volatile const  uint32_t  RESERVED0[57];
N  __IO uint32_t  EVENTS_HFCLKSTARTED;               /*!< HFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_HFCLKSTARTED;                
N  __IO uint32_t  EVENTS_LFCLKSTARTED;               /*!< LFCLK oscillator started.                                             */
X  volatile uint32_t  EVENTS_LFCLKSTARTED;                
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  __IO uint32_t  EVENTS_DONE;                       /*!< Callibration of LFCLK RC oscillator completed.                        */
X  volatile uint32_t  EVENTS_DONE;                        
N  __IO uint32_t  EVENTS_CTTO;                       /*!< Callibration timer timeout.                                           */
X  volatile uint32_t  EVENTS_CTTO;                        
N  __I  uint32_t  RESERVED2[124];
X  volatile const  uint32_t  RESERVED2[124];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __I  uint32_t  HFCLKSTAT;                         /*!< High frequency clock status.                                          */
X  volatile const  uint32_t  HFCLKSTAT;                          
N  __I  uint32_t  RESERVED4[2];
X  volatile const  uint32_t  RESERVED4[2];
N  __I  uint32_t  LFCLKSTAT;                         /*!< Low frequency clock status.                                           */
X  volatile const  uint32_t  LFCLKSTAT;                          
N  __I  uint32_t  RESERVED5[63];
X  volatile const  uint32_t  RESERVED5[63];
N  __IO uint32_t  LFCLKSRC;                          /*!< Clock source for the LFCLK clock.                                     */
X  volatile uint32_t  LFCLKSRC;                           
N  __I  uint32_t  RESERVED6[7];
X  volatile const  uint32_t  RESERVED6[7];
N  __IO uint32_t  CTIV;                              /*!< Calibration timer interval.                                           */
X  volatile uint32_t  CTIV;                               
N  __I  uint32_t  RESERVED7[5];
X  volatile const  uint32_t  RESERVED7[5];
N  __IO uint32_t  XTALFREQ;                          /*!< Crystal frequency.                                                    */
X  volatile uint32_t  XTALFREQ;                           
N} NRF_CLOCK_Type;
N
N
N/* ================================================================================ */
N/* ================                       MPU                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Memory Protection Unit. (MPU)
N  */
N
Ntypedef struct {                                    /*!< MPU Structure                                                         */
N  __I  uint32_t  RESERVED0[330];
X  volatile const  uint32_t  RESERVED0[330];
N  __IO uint32_t  PERR0;                             /*!< Configuration of peripherals in mpu regions.                          */
X  volatile uint32_t  PERR0;                              
N  __IO uint32_t  RLENR0;                            /*!< Length of RAM region 0.                                               */
X  volatile uint32_t  RLENR0;                             
N  __I  uint32_t  RESERVED1[52];
X  volatile const  uint32_t  RESERVED1[52];
N  __IO uint32_t  PROTENSET0;                        /*!< Protection bit enable set register for low addresses.                 */
X  volatile uint32_t  PROTENSET0;                         
N  __IO uint32_t  PROTENSET1;                        /*!< Protection bit enable set register for high addresses.                */
X  volatile uint32_t  PROTENSET1;                         
N  __IO uint32_t  DISABLEINDEBUG;                    /*!< Disable protection mechanism in debug mode.                           */
X  volatile uint32_t  DISABLEINDEBUG;                     
N} NRF_MPU_Type;
N
N
N/* ================================================================================ */
N/* ================                       PU                       ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Patch unit. (PU)
N  */
N
Ntypedef struct {                                    /*!< PU Structure                                                          */
N  __I  uint32_t  RESERVED0[384];
X  volatile const  uint32_t  RESERVED0[384];
N  __IO uint32_t  REPLACEADDR[8];                    /*!< Address of first instruction to replace.                              */
X  volatile uint32_t  REPLACEADDR[8];                     
N  __I  uint32_t  RESERVED1[24];
X  volatile const  uint32_t  RESERVED1[24];
N  __IO uint32_t  PATCHADDR[8];                      /*!< Relative address of patch instructions.                               */
X  volatile uint32_t  PATCHADDR[8];                       
N  __I  uint32_t  RESERVED2[24];
X  volatile const  uint32_t  RESERVED2[24];
N  __IO uint32_t  PATCHEN;                           /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHEN;                            
N  __IO uint32_t  PATCHENSET;                        /*!< Patch enable register.                                                */
X  volatile uint32_t  PATCHENSET;                         
N  __IO uint32_t  PATCHENCLR;                        /*!< Patch disable register.                                               */
X  volatile uint32_t  PATCHENCLR;                         
N} NRF_PU_Type;
N
N
N/* ================================================================================ */
N/* ================                      AMLI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AHB Multi-Layer Interface. (AMLI)
N  */
N
Ntypedef struct {                                    /*!< AMLI Structure                                                        */
N  __I  uint32_t  RESERVED0[896];
X  volatile const  uint32_t  RESERVED0[896];
N  AMLI_RAMPRI_Type RAMPRI;                          /*!< RAM configurable priority configuration structure.                    */
N} NRF_AMLI_Type;
N
N
N/* ================================================================================ */
N/* ================                      RADIO                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief The radio. (RADIO)
N  */
N
Ntypedef struct {                                    /*!< RADIO Structure                                                       */
N  __O  uint32_t  TASKS_TXEN;                        /*!< Enable radio in TX mode.                                              */
X  volatile  uint32_t  TASKS_TXEN;                         
N  __O  uint32_t  TASKS_RXEN;                        /*!< Enable radio in RX mode.                                              */
X  volatile  uint32_t  TASKS_RXEN;                         
N  __O  uint32_t  TASKS_START;                       /*!< Start radio.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop radio.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_DISABLE;                     /*!< Disable radio.                                                        */
X  volatile  uint32_t  TASKS_DISABLE;                      
N  __O  uint32_t  TASKS_RSSISTART;                   /*!< Start the RSSI and take one sample of the receive signal strength.    */
X  volatile  uint32_t  TASKS_RSSISTART;                    
N  __O  uint32_t  TASKS_RSSISTOP;                    /*!< Stop the RSSI measurement.                                            */
X  volatile  uint32_t  TASKS_RSSISTOP;                     
N  __O  uint32_t  TASKS_BCSTART;                     /*!< Start the bit counter.                                                */
X  volatile  uint32_t  TASKS_BCSTART;                      
N  __O  uint32_t  TASKS_BCSTOP;                      /*!< Stop the bit counter.                                                 */
X  volatile  uint32_t  TASKS_BCSTOP;                       
N  __I  uint32_t  RESERVED0[55];
X  volatile const  uint32_t  RESERVED0[55];
N  __IO uint32_t  EVENTS_READY;                      /*!< Ready event.                                                          */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_ADDRESS;                    /*!< Address event.                                                        */
X  volatile uint32_t  EVENTS_ADDRESS;                     
N  __IO uint32_t  EVENTS_PAYLOAD;                    /*!< Payload event.                                                        */
X  volatile uint32_t  EVENTS_PAYLOAD;                     
N  __IO uint32_t  EVENTS_END;                        /*!< End event.                                                            */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_DISABLED;                   /*!< Disable event.                                                        */
X  volatile uint32_t  EVENTS_DISABLED;                    
N  __IO uint32_t  EVENTS_DEVMATCH;                   /*!< A device address match occurred on the last received packet.          */
X  volatile uint32_t  EVENTS_DEVMATCH;                    
N  __IO uint32_t  EVENTS_DEVMISS;                    /*!< No device address match occurred on the last received packet.         */
X  volatile uint32_t  EVENTS_DEVMISS;                     
N  __IO uint32_t  EVENTS_RSSIEND;                    /*!< Sampling of the receive signal strength complete. A new RSSI
X  volatile uint32_t  EVENTS_RSSIEND;                    
N                                                         sample is ready for readout at the RSSISAMPLE register.               */
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __IO uint32_t  EVENTS_BCMATCH;                    /*!< Bit counter reached bit count value specified in BC register.         */
X  volatile uint32_t  EVENTS_BCMATCH;                     
N  __I  uint32_t  RESERVED2[53];
X  volatile const  uint32_t  RESERVED2[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the radio.                                               */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[61];
X  volatile const  uint32_t  RESERVED4[61];
N  __I  uint32_t  CRCSTATUS;                         /*!< CRC status of received packet.                                        */
X  volatile const  uint32_t  CRCSTATUS;                          
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __I  uint32_t  RXMATCH;                           /*!< Received address.                                                     */
X  volatile const  uint32_t  RXMATCH;                            
N  __I  uint32_t  RXCRC;                             /*!< Received CRC.                                                         */
X  volatile const  uint32_t  RXCRC;                              
N  __IO uint32_t  DAI;                               /*!< Device address match index.                                           */
X  volatile uint32_t  DAI;                                
N  __I  uint32_t  RESERVED6[60];
X  volatile const  uint32_t  RESERVED6[60];
N  __IO uint32_t  PACKETPTR;                         /*!< Packet pointer. Decision point: START task.                           */
X  volatile uint32_t  PACKETPTR;                          
N  __IO uint32_t  FREQUENCY;                         /*!< Frequency.                                                            */
X  volatile uint32_t  FREQUENCY;                          
N  __IO uint32_t  TXPOWER;                           /*!< Output power.                                                         */
X  volatile uint32_t  TXPOWER;                            
N  __IO uint32_t  MODE;                              /*!< Data rate and modulation.                                             */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  PCNF0;                             /*!< Packet configuration 0.                                               */
X  volatile uint32_t  PCNF0;                              
N  __IO uint32_t  PCNF1;                             /*!< Packet configuration 1.                                               */
X  volatile uint32_t  PCNF1;                              
N  __IO uint32_t  BASE0;                             /*!< Radio base address 0. Decision point: START task.                     */
X  volatile uint32_t  BASE0;                              
N  __IO uint32_t  BASE1;                             /*!< Radio base address 1. Decision point: START task.                     */
X  volatile uint32_t  BASE1;                              
N  __IO uint32_t  PREFIX0;                           /*!< Prefixes bytes for logical addresses 0 to 3.                          */
X  volatile uint32_t  PREFIX0;                            
N  __IO uint32_t  PREFIX1;                           /*!< Prefixes bytes for logical addresses 4 to 7.                          */
X  volatile uint32_t  PREFIX1;                            
N  __IO uint32_t  TXADDRESS;                         /*!< Transmit address select.                                              */
X  volatile uint32_t  TXADDRESS;                          
N  __IO uint32_t  RXADDRESSES;                       /*!< Receive address select.                                               */
X  volatile uint32_t  RXADDRESSES;                        
N  __IO uint32_t  CRCCNF;                            /*!< CRC configuration.                                                    */
X  volatile uint32_t  CRCCNF;                             
N  __IO uint32_t  CRCPOLY;                           /*!< CRC polynomial.                                                       */
X  volatile uint32_t  CRCPOLY;                            
N  __IO uint32_t  CRCINIT;                           /*!< CRC initial value.                                                    */
X  volatile uint32_t  CRCINIT;                            
N  __IO uint32_t  TEST;                              /*!< Test features enable register.                                        */
X  volatile uint32_t  TEST;                               
N  __IO uint32_t  TIFS;                              /*!< Inter Frame Spacing in microseconds.                                  */
X  volatile uint32_t  TIFS;                               
N  __IO uint32_t  RSSISAMPLE;                        /*!< RSSI sample.                                                          */
X  volatile uint32_t  RSSISAMPLE;                         
N  __I  uint32_t  RESERVED7;
X  volatile const  uint32_t  RESERVED7;
N  __I  uint32_t  STATE;                             /*!< Current radio state.                                                  */
X  volatile const  uint32_t  STATE;                              
N  __IO uint32_t  DATAWHITEIV;                       /*!< Data whitening initial value.                                         */
X  volatile uint32_t  DATAWHITEIV;                        
N  __I  uint32_t  RESERVED8[2];
X  volatile const  uint32_t  RESERVED8[2];
N  __IO uint32_t  BCC;                               /*!< Bit counter compare.                                                  */
X  volatile uint32_t  BCC;                                
N  __I  uint32_t  RESERVED9[39];
X  volatile const  uint32_t  RESERVED9[39];
N  __IO uint32_t  DAB[8];                            /*!< Device address base segment.                                          */
X  volatile uint32_t  DAB[8];                             
N  __IO uint32_t  DAP[8];                            /*!< Device address prefix.                                                */
X  volatile uint32_t  DAP[8];                             
N  __IO uint32_t  DACNF;                             /*!< Device address match configuration.                                   */
X  volatile uint32_t  DACNF;                              
N  __I  uint32_t  RESERVED10[56];
X  volatile const  uint32_t  RESERVED10[56];
N  __IO uint32_t  OVERRIDE0;                         /*!< Trim value override register 0.                                       */
X  volatile uint32_t  OVERRIDE0;                          
N  __IO uint32_t  OVERRIDE1;                         /*!< Trim value override register 1.                                       */
X  volatile uint32_t  OVERRIDE1;                          
N  __IO uint32_t  OVERRIDE2;                         /*!< Trim value override register 2.                                       */
X  volatile uint32_t  OVERRIDE2;                          
N  __IO uint32_t  OVERRIDE3;                         /*!< Trim value override register 3.                                       */
X  volatile uint32_t  OVERRIDE3;                          
N  __IO uint32_t  OVERRIDE4;                         /*!< Trim value override register 4.                                       */
X  volatile uint32_t  OVERRIDE4;                          
N  __I  uint32_t  RESERVED11[561];
X  volatile const  uint32_t  RESERVED11[561];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RADIO_Type;
N
N
N/* ================================================================================ */
N/* ================                      UART                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Universal Asynchronous Receiver/Transmitter, version 1.0. (UART)
N  */
N
Ntypedef struct {                                    /*!< UART Structure                                                        */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start UART receiver.                                                  */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __O  uint32_t  TASKS_STOPRX;                      /*!< Stop UART receiver.                                                   */
X  volatile  uint32_t  TASKS_STOPRX;                       
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start UART transmitter.                                               */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __O  uint32_t  TASKS_STOPTX;                      /*!< Stop UART transmitter.                                                */
X  volatile  uint32_t  TASKS_STOPTX;                       
N  __I  uint32_t  RESERVED0[3];
X  volatile const  uint32_t  RESERVED0[3];
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend UART.                                                         */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __I  uint32_t  RESERVED1[58];
X  volatile const  uint32_t  RESERVED1[58];
N  __IO uint32_t  EVENTS_RXDRDY;                     /*!< Data received in RXD.                                                 */
X  volatile uint32_t  EVENTS_RXDRDY;                      
N  __I  uint32_t  RESERVED2[4];
X  volatile const  uint32_t  RESERVED2[4];
N  __IO uint32_t  EVENTS_TXDRDY;                     /*!< Data sent from TXD.                                                   */
X  volatile uint32_t  EVENTS_TXDRDY;                      
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error detected.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED4[7];
X  volatile const  uint32_t  RESERVED4[7];
N  __IO uint32_t  EVENTS_RXTO;                       /*!< Receiver timeout.                                                     */
X  volatile uint32_t  EVENTS_RXTO;                        
N  __I  uint32_t  RESERVED5[111];
X  volatile const  uint32_t  RESERVED5[111];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED6[93];
X  volatile const  uint32_t  RESERVED6[93];
N  __IO uint32_t  ERRORSRC;                          /*!< Error source. Write error field to 1 to clear error.                  */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED7[31];
X  volatile const  uint32_t  RESERVED7[31];
N  __IO uint32_t  ENABLE;                            /*!< Enable UART and acquire IOs.                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELRTS;                           /*!< Pin select for RTS.                                                   */
X  volatile uint32_t  PSELRTS;                            
N  __IO uint32_t  PSELTXD;                           /*!< Pin select for TXD.                                                   */
X  volatile uint32_t  PSELTXD;                            
N  __IO uint32_t  PSELCTS;                           /*!< Pin select for CTS.                                                   */
X  volatile uint32_t  PSELCTS;                            
N  __IO uint32_t  PSELRXD;                           /*!< Pin select for RXD.                                                   */
X  volatile uint32_t  PSELRXD;                            
N  __I  uint32_t  RXD;                               /*!< RXD register. On read action the buffer pointer is displaced.
X  volatile const  uint32_t  RXD;                               
N                                                         Once read the character is consummed. If read when no character
N                                                          available, the UART will stop working.                               */
N  __O  uint32_t  TXD;                               /*!< TXD register.                                                         */
X  volatile  uint32_t  TXD;                                
N  __I  uint32_t  RESERVED9;
X  volatile const  uint32_t  RESERVED9;
N  __IO uint32_t  BAUDRATE;                          /*!< UART Baudrate.                                                        */
X  volatile uint32_t  BAUDRATE;                           
N  __I  uint32_t  RESERVED10[17];
X  volatile const  uint32_t  RESERVED10[17];
N  __IO uint32_t  CONFIG;                            /*!< Configuration of parity and hardware flow control register.           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED11[675];
X  volatile const  uint32_t  RESERVED11[675];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_UART_Type;
N
N
N/* ================================================================================ */
N/* ================                       SPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI master 0. (SPI)
N  */
N
Ntypedef struct {                                    /*!< SPI Structure                                                         */
N  __I  uint32_t  RESERVED0[66];
X  volatile const  uint32_t  RESERVED0[66];
N  __IO uint32_t  EVENTS_READY;                      /*!< TXD byte sent and RXD byte received.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __I  uint32_t  RESERVED1[126];
X  volatile const  uint32_t  RESERVED1[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[125];
X  volatile const  uint32_t  RESERVED2[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPI.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED3;
X  volatile const  uint32_t  RESERVED3;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __I  uint32_t  RESERVED4;
X  volatile const  uint32_t  RESERVED4;
N  __IO uint32_t  RXD;                               /*!< RX data.                                                              */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data.                                                              */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  FREQUENCY;                         /*!< SPI frequency                                                         */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED7[681];
X  volatile const  uint32_t  RESERVED7[681];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPI_Type;
N
N
N/* ================================================================================ */
N/* ================                       TWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Two-wire interface master 0. (TWI)
N  */
N
Ntypedef struct {                                    /*!< TWI Structure                                                         */
N  __O  uint32_t  TASKS_STARTRX;                     /*!< Start 2-Wire master receive sequence.                                 */
X  volatile  uint32_t  TASKS_STARTRX;                      
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STARTTX;                     /*!< Start 2-Wire master transmit sequence.                                */
X  volatile  uint32_t  TASKS_STARTTX;                      
N  __I  uint32_t  RESERVED1[2];
X  volatile const  uint32_t  RESERVED1[2];
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop 2-Wire transaction.                                              */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __O  uint32_t  TASKS_SUSPEND;                     /*!< Suspend 2-Wire transaction.                                           */
X  volatile  uint32_t  TASKS_SUSPEND;                      
N  __O  uint32_t  TASKS_RESUME;                      /*!< Resume 2-Wire transaction.                                            */
X  volatile  uint32_t  TASKS_RESUME;                       
N  __I  uint32_t  RESERVED3[56];
X  volatile const  uint32_t  RESERVED3[56];
N  __IO uint32_t  EVENTS_STOPPED;                    /*!< Two-wire stopped.                                                     */
X  volatile uint32_t  EVENTS_STOPPED;                     
N  __IO uint32_t  EVENTS_RXDREADY;                   /*!< Two-wire ready to deliver new RXD byte received.                      */
X  volatile uint32_t  EVENTS_RXDREADY;                    
N  __I  uint32_t  RESERVED4[4];
X  volatile const  uint32_t  RESERVED4[4];
N  __IO uint32_t  EVENTS_TXDSENT;                    /*!< Two-wire finished sending last TXD byte.                              */
X  volatile uint32_t  EVENTS_TXDSENT;                     
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Two-wire error detected.                                              */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED6[4];
X  volatile const  uint32_t  RESERVED6[4];
N  __IO uint32_t  EVENTS_BB;                         /*!< Two-wire byte boundary.                                               */
X  volatile uint32_t  EVENTS_BB;                          
N  __I  uint32_t  RESERVED7[49];
X  volatile const  uint32_t  RESERVED7[49];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for TWI.                                                    */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED8[64];
X  volatile const  uint32_t  RESERVED8[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED9[110];
X  volatile const  uint32_t  RESERVED9[110];
N  __IO uint32_t  ERRORSRC;                          /*!< Two-wire error source. Write error field to 1 to clear error.         */
X  volatile uint32_t  ERRORSRC;                           
N  __I  uint32_t  RESERVED10[14];
X  volatile const  uint32_t  RESERVED10[14];
N  __IO uint32_t  ENABLE;                            /*!< Enable two-wire master.                                               */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  PSELSCL;                           /*!< Pin select for SCL.                                                   */
X  volatile uint32_t  PSELSCL;                            
N  __IO uint32_t  PSELSDA;                           /*!< Pin select for SDA.                                                   */
X  volatile uint32_t  PSELSDA;                            
N  __I  uint32_t  RESERVED12[2];
X  volatile const  uint32_t  RESERVED12[2];
N  __IO uint32_t  RXD;                               /*!< RX data register.                                                     */
X  volatile uint32_t  RXD;                                
N  __IO uint32_t  TXD;                               /*!< TX data register.                                                     */
X  volatile uint32_t  TXD;                                
N  __I  uint32_t  RESERVED13;
X  volatile const  uint32_t  RESERVED13;
N  __IO uint32_t  FREQUENCY;                         /*!< Two-wire frequency.                                                   */
X  volatile uint32_t  FREQUENCY;                          
N  __I  uint32_t  RESERVED14[24];
X  volatile const  uint32_t  RESERVED14[24];
N  __IO uint32_t  ADDRESS;                           /*!< Address used in the two-wire transfer.                                */
X  volatile uint32_t  ADDRESS;                            
N  __I  uint32_t  RESERVED15[668];
X  volatile const  uint32_t  RESERVED15[668];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      SPIS                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SPI slave 1. (SPIS)
N  */
N
Ntypedef struct {                                    /*!< SPIS Structure                                                        */
N  __I  uint32_t  RESERVED0[9];
X  volatile const  uint32_t  RESERVED0[9];
N  __O  uint32_t  TASKS_ACQUIRE;                     /*!< Acquire SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_ACQUIRE;                      
N  __O  uint32_t  TASKS_RELEASE;                     /*!< Release SPI semaphore.                                                */
X  volatile  uint32_t  TASKS_RELEASE;                      
N  __I  uint32_t  RESERVED1[54];
X  volatile const  uint32_t  RESERVED1[54];
N  __IO uint32_t  EVENTS_END;                        /*!< Granted transaction completed.                                        */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED2[8];
X  volatile const  uint32_t  RESERVED2[8];
N  __IO uint32_t  EVENTS_ACQUIRED;                   /*!< Semaphore acquired.                                                   */
X  volatile uint32_t  EVENTS_ACQUIRED;                    
N  __I  uint32_t  RESERVED3[53];
X  volatile const  uint32_t  RESERVED3[53];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for SPIS.                                                   */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED4[64];
X  volatile const  uint32_t  RESERVED4[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED5[61];
X  volatile const  uint32_t  RESERVED5[61];
N  __I  uint32_t  SEMSTAT;                           /*!< Semaphore status.                                                     */
X  volatile const  uint32_t  SEMSTAT;                            
N  __I  uint32_t  RESERVED6[15];
X  volatile const  uint32_t  RESERVED6[15];
N  __IO uint32_t  STATUS;                            /*!< Status from last transaction.                                         */
X  volatile uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED7[47];
X  volatile const  uint32_t  RESERVED7[47];
N  __IO uint32_t  ENABLE;                            /*!< Enable SPIS.                                                          */
X  volatile uint32_t  ENABLE;                             
N  __I  uint32_t  RESERVED8;
X  volatile const  uint32_t  RESERVED8;
N  __IO uint32_t  PSELSCK;                           /*!< Pin select for SCK.                                                   */
X  volatile uint32_t  PSELSCK;                            
N  __IO uint32_t  PSELMISO;                          /*!< Pin select for MISO.                                                  */
X  volatile uint32_t  PSELMISO;                           
N  __IO uint32_t  PSELMOSI;                          /*!< Pin select for MOSI.                                                  */
X  volatile uint32_t  PSELMOSI;                           
N  __IO uint32_t  PSELCSN;                           /*!< Pin select for CSN.                                                   */
X  volatile uint32_t  PSELCSN;                            
N  __I  uint32_t  RESERVED9[7];
X  volatile const  uint32_t  RESERVED9[7];
N  __IO uint32_t  RXDPTR;                            /*!< RX data pointer.                                                      */
X  volatile uint32_t  RXDPTR;                             
N  __IO uint32_t  MAXRX;                             /*!< Maximum number of bytes in the receive buffer.                        */
X  volatile uint32_t  MAXRX;                              
N  __IO uint32_t  AMOUNTRX;                          /*!< Number of bytes received in last granted transaction.                 */
X  volatile uint32_t  AMOUNTRX;                           
N  __I  uint32_t  RESERVED10;
X  volatile const  uint32_t  RESERVED10;
N  __IO uint32_t  TXDPTR;                            /*!< TX data pointer.                                                      */
X  volatile uint32_t  TXDPTR;                             
N  __IO uint32_t  MAXTX;                             /*!< Maximum number of bytes in the transmit buffer.                       */
X  volatile uint32_t  MAXTX;                              
N  __IO uint32_t  AMOUNTTX;                          /*!< Number of bytes transmitted in last granted transaction.              */
X  volatile uint32_t  AMOUNTTX;                           
N  __I  uint32_t  RESERVED11;
X  volatile const  uint32_t  RESERVED11;
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED12;
X  volatile const  uint32_t  RESERVED12;
N  __IO uint32_t  DEF;                               /*!< Default character.                                                    */
X  volatile uint32_t  DEF;                                
N  __I  uint32_t  RESERVED13[24];
X  volatile const  uint32_t  RESERVED13[24];
N  __IO uint32_t  ORC;                               /*!< Over-read character.                                                  */
X  volatile uint32_t  ORC;                                
N  __I  uint32_t  RESERVED14[654];
X  volatile const  uint32_t  RESERVED14[654];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_SPIS_Type;
N
N
N/* ================================================================================ */
N/* ================                     GPIOTE                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief GPIO tasks and events. (GPIOTE)
N  */
N
Ntypedef struct {                                    /*!< GPIOTE Structure                                                      */
N  __O  uint32_t  TASKS_OUT[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile  uint32_t  TASKS_OUT[4];                       
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_IN[4];                      /*!< Tasks asssociated with GPIOTE channels.                               */
X  volatile uint32_t  EVENTS_IN[4];                       
N  __I  uint32_t  RESERVED1[27];
X  volatile const  uint32_t  RESERVED1[27];
N  __IO uint32_t  EVENTS_PORT;                       /*!< Event generated from multiple pins.                                   */
X  volatile uint32_t  EVENTS_PORT;                        
N  __I  uint32_t  RESERVED2[97];
X  volatile const  uint32_t  RESERVED2[97];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[129];
X  volatile const  uint32_t  RESERVED3[129];
N  __IO uint32_t  CONFIG[4];                         /*!< Channel configuration registers.                                      */
X  volatile uint32_t  CONFIG[4];                          
N  __I  uint32_t  RESERVED4[695];
X  volatile const  uint32_t  RESERVED4[695];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_GPIOTE_Type;
N
N
N/* ================================================================================ */
N/* ================                       ADC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Analog to digital converter. (ADC)
N  */
N
Ntypedef struct {                                    /*!< ADC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start an ADC conversion.                                              */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop ADC.                                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_END;                        /*!< ADC conversion complete.                                              */
X  volatile uint32_t  EVENTS_END;                         
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  BUSY;                              /*!< ADC busy register.                                                    */
X  volatile const  uint32_t  BUSY;                               
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  ENABLE;                            /*!< ADC enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  CONFIG;                            /*!< ADC configuration register.                                           */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESULT;                            /*!< Result of ADC conversion.                                             */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ADC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TIMER                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Timer 0. (TIMER)
N  */
N
Ntypedef struct {                                    /*!< TIMER Structure                                                       */
N  __O  uint32_t  TASKS_START;                       /*!< Start Timer.                                                          */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop Timer.                                                           */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_COUNT;                       /*!< Increment Timer (In counter mode).                                    */
X  volatile  uint32_t  TASKS_COUNT;                        
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear timer.                                                          */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __I  uint32_t  RESERVED0[12];
X  volatile const  uint32_t  RESERVED0[12];
N  __O  uint32_t  TASKS_CAPTURE[4];                  /*!< Capture Timer value to CC[n] registers.                               */
X  volatile  uint32_t  TASKS_CAPTURE[4];                   
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[44];
X  volatile const  uint32_t  RESERVED2[44];
N  __IO uint32_t  SHORTS;                            /*!< Shortcuts for Timer.                                                  */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED3[64];
X  volatile const  uint32_t  RESERVED3[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED4[126];
X  volatile const  uint32_t  RESERVED4[126];
N  __IO uint32_t  MODE;                              /*!< Timer Mode selection.                                                 */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  BITMODE;                           /*!< Sets timer behaviour.                                                 */
X  volatile uint32_t  BITMODE;                            
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  PRESCALER;                         /*!< 4-bit prescaler to source clock frequency (max value 9). Source
X  volatile uint32_t  PRESCALER;                         
N                                                         clock frequency is divided by 2^SCALE.                                */
N  __I  uint32_t  RESERVED6[11];
X  volatile const  uint32_t  RESERVED6[11];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED7[683];
X  volatile const  uint32_t  RESERVED7[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TIMER_Type;
N
N
N/* ================================================================================ */
N/* ================                       RTC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Real time counter 0. (RTC)
N  */
N
Ntypedef struct {                                    /*!< RTC Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop RTC Counter.                                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_CLEAR;                       /*!< Clear RTC Counter.                                                    */
X  volatile  uint32_t  TASKS_CLEAR;                        
N  __O  uint32_t  TASKS_TRIGOVRFLW;                  /*!< Set COUNTER to 0xFFFFFFF0.                                            */
X  volatile  uint32_t  TASKS_TRIGOVRFLW;                   
N  __I  uint32_t  RESERVED0[60];
X  volatile const  uint32_t  RESERVED0[60];
N  __IO uint32_t  EVENTS_TICK;                       /*!< Event on COUNTER increment.                                           */
X  volatile uint32_t  EVENTS_TICK;                        
N  __IO uint32_t  EVENTS_OVRFLW;                     /*!< Event on COUNTER overflow.                                            */
X  volatile uint32_t  EVENTS_OVRFLW;                      
N  __I  uint32_t  RESERVED1[14];
X  volatile const  uint32_t  RESERVED1[14];
N  __IO uint32_t  EVENTS_COMPARE[4];                 /*!< Compare event on CC[n] match.                                         */
X  volatile uint32_t  EVENTS_COMPARE[4];                  
N  __I  uint32_t  RESERVED2[109];
X  volatile const  uint32_t  RESERVED2[109];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[13];
X  volatile const  uint32_t  RESERVED3[13];
N  __IO uint32_t  EVTEN;                             /*!< Configures event enable routing to PPI for each RTC event.            */
X  volatile uint32_t  EVTEN;                              
N  __IO uint32_t  EVTENSET;                          /*!< Enable events routing to PPI. The reading of this register gives
X  volatile uint32_t  EVTENSET;                          
N                                                         the value of EVTEN.                                                   */
N  __IO uint32_t  EVTENCLR;                          /*!< Disable events routing to PPI. The reading of this register
X  volatile uint32_t  EVTENCLR;                          
N                                                         gives the value of EVTEN.                                             */
N  __I  uint32_t  RESERVED4[110];
X  volatile const  uint32_t  RESERVED4[110];
N  __IO uint32_t  COUNTER;                           /*!< Current COUNTER value.                                                */
X  volatile uint32_t  COUNTER;                            
N  __IO uint32_t  PRESCALER;                         /*!< 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)).
X  volatile uint32_t  PRESCALER;                         
N                                                         Must be written when RTC is STOPed.                                   */
N  __I  uint32_t  RESERVED5[13];
X  volatile const  uint32_t  RESERVED5[13];
N  __IO uint32_t  CC[4];                             /*!< Capture/compare registers.                                            */
X  volatile uint32_t  CC[4];                              
N  __I  uint32_t  RESERVED6[683];
X  volatile const  uint32_t  RESERVED6[683];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RTC_Type;
N
N
N/* ================================================================================ */
N/* ================                      TEMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Temperature Sensor. (TEMP)
N  */
N
Ntypedef struct {                                    /*!< TEMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start temperature measurement.                                        */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop temperature measurement.                                         */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_DATARDY;                    /*!< Temperature measurement complete, data ready event.                   */
X  volatile uint32_t  EVENTS_DATARDY;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[127];
X  volatile const  uint32_t  RESERVED2[127];
N  __I  int32_t   TEMP;                              /*!< Die temperature in degC, 2's complement format, 0.25 degC pecision.   */
X  volatile const  int32_t   TEMP;                               
N  __I  uint32_t  RESERVED3[700];
X  volatile const  uint32_t  RESERVED3[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_TEMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       RNG                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Random Number Generator. (RNG)
N  */
N
Ntypedef struct {                                    /*!< RNG Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the random number generator.                                    */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the random number generator.                                     */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_VALRDY;                     /*!< New random number generated and written to VALUE register.            */
X  volatile uint32_t  EVENTS_VALRDY;                      
N  __I  uint32_t  RESERVED1[63];
X  volatile const  uint32_t  RESERVED1[63];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the RNG.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register                                         */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register                                       */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[126];
X  volatile const  uint32_t  RESERVED3[126];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  VALUE;                             /*!< RNG random number.                                                    */
X  volatile const  uint32_t  VALUE;                              
N  __I  uint32_t  RESERVED4[700];
X  volatile const  uint32_t  RESERVED4[700];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_RNG_Type;
N
N
N/* ================================================================================ */
N/* ================                       ECB                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES ECB Mode Encryption. (ECB)
N  */
N
Ntypedef struct {                                    /*!< ECB Structure                                                         */
N  __O  uint32_t  TASKS_STARTECB;                    /*!< Start ECB block encrypt. If a crypto operation is running, this
X  volatile  uint32_t  TASKS_STARTECB;                    
N                                                         will not initiate a new encryption and the ERRORECB event will
N                                                          be triggered.                                                        */
N  __O  uint32_t  TASKS_STOPECB;                     /*!< Stop current ECB encryption. If a crypto operation is running,
X  volatile  uint32_t  TASKS_STOPECB;                     
N                                                         this will will trigger the ERRORECB event.                            */
N  __I  uint32_t  RESERVED0[62];
X  volatile const  uint32_t  RESERVED0[62];
N  __IO uint32_t  EVENTS_ENDECB;                     /*!< ECB block encrypt complete.                                           */
X  volatile uint32_t  EVENTS_ENDECB;                      
N  __IO uint32_t  EVENTS_ERRORECB;                   /*!< ECB block encrypt aborted due to a STOPECB task or due to an
X  volatile uint32_t  EVENTS_ERRORECB;                   
N                                                         error.                                                                */
N  __I  uint32_t  RESERVED1[127];
X  volatile const  uint32_t  RESERVED1[127];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  ECBDATAPTR;                        /*!< ECB block encrypt memory pointer.                                     */
X  volatile uint32_t  ECBDATAPTR;                         
N  __I  uint32_t  RESERVED3[701];
X  volatile const  uint32_t  RESERVED3[701];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_ECB_Type;
N
N
N/* ================================================================================ */
N/* ================                       AAR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Accelerated Address Resolver. (AAR)
N  */
N
Ntypedef struct {                                    /*!< AAR Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start resolving addresses based on IRKs specified in the IRK
X  volatile  uint32_t  TASKS_START;                       
N                                                         data structure.                                                       */
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop resolving addresses.                                             */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  EVENTS_END;                        /*!< Address resolution procedure completed.                               */
X  volatile uint32_t  EVENTS_END;                         
N  __IO uint32_t  EVENTS_RESOLVED;                   /*!< Address resolved.                                                     */
X  volatile uint32_t  EVENTS_RESOLVED;                    
N  __IO uint32_t  EVENTS_NOTRESOLVED;                /*!< Address not resolved.                                                 */
X  volatile uint32_t  EVENTS_NOTRESOLVED;                 
N  __I  uint32_t  RESERVED2[126];
X  volatile const  uint32_t  RESERVED2[126];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  STATUS;                            /*!< Resolution status.                                                    */
X  volatile const  uint32_t  STATUS;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable AAR.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  NIRK;                              /*!< Number of Identity root Keys in the IRK data structure.               */
X  volatile uint32_t  NIRK;                               
N  __IO uint32_t  IRKPTR;                            /*!< Pointer to the IRK data structure.                                    */
X  volatile uint32_t  IRKPTR;                             
N  __I  uint32_t  RESERVED5;
X  volatile const  uint32_t  RESERVED5;
N  __IO uint32_t  ADDRPTR;                           /*!< Pointer to the resolvable address (6 bytes).                          */
X  volatile uint32_t  ADDRPTR;                            
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 3 bytes must be reserved.                    */
N  __I  uint32_t  RESERVED6[697];
X  volatile const  uint32_t  RESERVED6[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_AAR_Type;
N
N
N/* ================================================================================ */
N/* ================                       CCM                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief AES CCM Mode Encryption. (CCM)
N  */
N
Ntypedef struct {                                    /*!< CCM Structure                                                         */
N  __O  uint32_t  TASKS_KSGEN;                       /*!< Start generation of key-stream. This operation will stop by
X  volatile  uint32_t  TASKS_KSGEN;                       
N                                                         itself when completed.                                                */
N  __O  uint32_t  TASKS_CRYPT;                       /*!< Start encrypt/decrypt. This operation will stop by itself when
X  volatile  uint32_t  TASKS_CRYPT;                       
N                                                         completed.                                                            */
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop encrypt/decrypt.                                                 */
X  volatile  uint32_t  TASKS_STOP;                         
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_ENDKSGEN;                   /*!< Keystream generation completed.                                       */
X  volatile uint32_t  EVENTS_ENDKSGEN;                    
N  __IO uint32_t  EVENTS_ENDCRYPT;                   /*!< Encrypt/decrypt completed.                                            */
X  volatile uint32_t  EVENTS_ENDCRYPT;                    
N  __IO uint32_t  EVENTS_ERROR;                      /*!< Error happened.                                                       */
X  volatile uint32_t  EVENTS_ERROR;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the CCM.                                                 */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  MICSTATUS;                         /*!< CCM RX MIC check result.                                              */
X  volatile const  uint32_t  MICSTATUS;                          
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< CCM enable.                                                           */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  MODE;                              /*!< Operation mode.                                                       */
X  volatile uint32_t  MODE;                               
N  __IO uint32_t  CNFPTR;                            /*!< Pointer to data structure holding AES key and NONCE vector.           */
X  volatile uint32_t  CNFPTR;                             
N  __IO uint32_t  INPTR;                             /*!< Pointer to input packet.                                              */
X  volatile uint32_t  INPTR;                              
N  __IO uint32_t  OUTPTR;                            /*!< Pointer to output packet.                                             */
X  volatile uint32_t  OUTPTR;                             
N  __IO uint32_t  SCRATCHPTR;                        /*!< Pointer to "scratch" data area used for temporary storage during
X  volatile uint32_t  SCRATCHPTR;                        
N                                                         resolution. A minimum of 43 bytes must be reserved.                   */
N  __I  uint32_t  RESERVED5[697];
X  volatile const  uint32_t  RESERVED5[697];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_CCM_Type;
N
N
N/* ================================================================================ */
N/* ================                       WDT                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Watchdog Timer. (WDT)
N  */
N
Ntypedef struct {                                    /*!< WDT Structure                                                         */
N  __O  uint32_t  TASKS_START;                       /*!< Start the watchdog.                                                   */
X  volatile  uint32_t  TASKS_START;                        
N  __I  uint32_t  RESERVED0[63];
X  volatile const  uint32_t  RESERVED0[63];
N  __IO uint32_t  EVENTS_TIMEOUT;                    /*!< Watchdog timeout.                                                     */
X  volatile uint32_t  EVENTS_TIMEOUT;                     
N  __I  uint32_t  RESERVED1[128];
X  volatile const  uint32_t  RESERVED1[128];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED2[61];
X  volatile const  uint32_t  RESERVED2[61];
N  __I  uint32_t  RUNSTATUS;                         /*!< Watchdog running status.                                              */
X  volatile const  uint32_t  RUNSTATUS;                          
N  __I  uint32_t  REQSTATUS;                         /*!< Request status.                                                       */
X  volatile const  uint32_t  REQSTATUS;                          
N  __I  uint32_t  RESERVED3[63];
X  volatile const  uint32_t  RESERVED3[63];
N  __IO uint32_t  CRV;                               /*!< Counter reload value in number of 32kiHz clock cycles.                */
X  volatile uint32_t  CRV;                                
N  __IO uint32_t  RREN;                              /*!< Reload request enable.                                                */
X  volatile uint32_t  RREN;                               
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __I  uint32_t  RESERVED4[60];
X  volatile const  uint32_t  RESERVED4[60];
N  __O  uint32_t  RR[8];                             /*!< Reload requests registers.                                            */
X  volatile  uint32_t  RR[8];                              
N  __I  uint32_t  RESERVED5[631];
X  volatile const  uint32_t  RESERVED5[631];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_WDT_Type;
N
N
N/* ================================================================================ */
N/* ================                      QDEC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Rotary decoder. (QDEC)
N  */
N
Ntypedef struct {                                    /*!< QDEC Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the quadrature decoder.                                         */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the quadrature decoder.                                          */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_READCLRACC;                  /*!< Transfers the content from ACC registers to ACCREAD registers,
X  volatile  uint32_t  TASKS_READCLRACC;                  
N                                                         and clears the ACC registers.                                         */
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_SAMPLERDY;                  /*!< A new sample is written to the sample register.                       */
X  volatile uint32_t  EVENTS_SAMPLERDY;                   
N  __IO uint32_t  EVENTS_REPORTRDY;                  /*!< REPORTPER number of samples accumulated in ACC register, and
X  volatile uint32_t  EVENTS_REPORTRDY;                  
N                                                         ACC register different than zero.                                     */
N  __IO uint32_t  EVENTS_ACCOF;                      /*!< ACC or ACCDBL register overflow.                                      */
X  volatile uint32_t  EVENTS_ACCOF;                       
N  __I  uint32_t  RESERVED1[61];
X  volatile const  uint32_t  RESERVED1[61];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the QDEC.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[125];
X  volatile const  uint32_t  RESERVED3[125];
N  __IO uint32_t  ENABLE;                            /*!< Enable the QDEC.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  LEDPOL;                            /*!< LED output pin polarity.                                              */
X  volatile uint32_t  LEDPOL;                             
N  __IO uint32_t  SAMPLEPER;                         /*!< Sample period.                                                        */
X  volatile uint32_t  SAMPLEPER;                          
N  __I  int32_t   SAMPLE;                            /*!< Motion sample value.                                                  */
X  volatile const  int32_t   SAMPLE;                             
N  __IO uint32_t  REPORTPER;                         /*!< Number of samples to generate an EVENT_REPORTRDY.                     */
X  volatile uint32_t  REPORTPER;                          
N  __I  int32_t   ACC;                               /*!< Accumulated valid transitions register.                               */
X  volatile const  int32_t   ACC;                                
N  __I  int32_t   ACCREAD;                           /*!< Snapshot of ACC register. Value generated by the TASKS_READCLEACC
X  volatile const  int32_t   ACCREAD;                           
N                                                         task.                                                                 */
N  __IO uint32_t  PSELLED;                           /*!< Pin select for LED output.                                            */
X  volatile uint32_t  PSELLED;                            
N  __IO uint32_t  PSELA;                             /*!< Pin select for phase A input.                                         */
X  volatile uint32_t  PSELA;                              
N  __IO uint32_t  PSELB;                             /*!< Pin select for phase B input.                                         */
X  volatile uint32_t  PSELB;                              
N  __IO uint32_t  DBFEN;                             /*!< Enable debouncer input filters.                                       */
X  volatile uint32_t  DBFEN;                              
N  __I  uint32_t  RESERVED4[5];
X  volatile const  uint32_t  RESERVED4[5];
N  __IO uint32_t  LEDPRE;                            /*!< Time LED is switched ON before the sample.                            */
X  volatile uint32_t  LEDPRE;                             
N  __I  uint32_t  ACCDBL;                            /*!< Accumulated double (error) transitions register.                      */
X  volatile const  uint32_t  ACCDBL;                             
N  __I  uint32_t  ACCDBLREAD;                        /*!< Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC
X  volatile const  uint32_t  ACCDBLREAD;                        
N                                                         task.                                                                 */
N  __I  uint32_t  RESERVED5[684];
X  volatile const  uint32_t  RESERVED5[684];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_QDEC_Type;
N
N
N/* ================================================================================ */
N/* ================                     LPCOMP                     ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Wakeup Comparator. (LPCOMP)
N  */
N
Ntypedef struct {                                    /*!< LPCOMP Structure                                                      */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< LPCOMP is ready and output is valid.                                  */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the LPCOMP.                                              */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Result of last compare.                                               */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the LPCOMP.                                                    */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[4];
X  volatile const  uint32_t  RESERVED5[4];
N  __IO uint32_t  ANADETECT;                         /*!< Analog detect configuration.                                          */
X  volatile uint32_t  ANADETECT;                          
N  __I  uint32_t  RESERVED6[694];
X  volatile const  uint32_t  RESERVED6[694];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_LPCOMP_Type;
N
N
N/* ================================================================================ */
N/* ================                      COMP                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Comparator. (COMP)
N  */
N
Ntypedef struct {                                    /*!< COMP Structure                                                        */
N  __O  uint32_t  TASKS_START;                       /*!< Start the comparator.                                                 */
X  volatile  uint32_t  TASKS_START;                        
N  __O  uint32_t  TASKS_STOP;                        /*!< Stop the comparator.                                                  */
X  volatile  uint32_t  TASKS_STOP;                         
N  __O  uint32_t  TASKS_SAMPLE;                      /*!< Sample comparator value.                                              */
X  volatile  uint32_t  TASKS_SAMPLE;                       
N  __I  uint32_t  RESERVED0[61];
X  volatile const  uint32_t  RESERVED0[61];
N  __IO uint32_t  EVENTS_READY;                      /*!< COMP is ready and output is valid.                                    */
X  volatile uint32_t  EVENTS_READY;                       
N  __IO uint32_t  EVENTS_DOWN;                       /*!< Input voltage crossed the threshold going down.                       */
X  volatile uint32_t  EVENTS_DOWN;                        
N  __IO uint32_t  EVENTS_UP;                         /*!< Input voltage crossed the threshold going up.                         */
X  volatile uint32_t  EVENTS_UP;                          
N  __IO uint32_t  EVENTS_CROSS;                      /*!< Input voltage crossed the threshold in any direction.                 */
X  volatile uint32_t  EVENTS_CROSS;                       
N  __I  uint32_t  RESERVED1[60];
X  volatile const  uint32_t  RESERVED1[60];
N  __IO uint32_t  SHORTS;                            /*!< Shortcut for the COMP.                                                */
X  volatile uint32_t  SHORTS;                             
N  __I  uint32_t  RESERVED2[64];
X  volatile const  uint32_t  RESERVED2[64];
N  __IO uint32_t  INTENSET;                          /*!< Interrupt enable set register.                                        */
X  volatile uint32_t  INTENSET;                           
N  __IO uint32_t  INTENCLR;                          /*!< Interrupt enable clear register.                                      */
X  volatile uint32_t  INTENCLR;                           
N  __I  uint32_t  RESERVED3[61];
X  volatile const  uint32_t  RESERVED3[61];
N  __I  uint32_t  RESULT;                            /*!< Compare result.                                                       */
X  volatile const  uint32_t  RESULT;                             
N  __I  uint32_t  RESERVED4[63];
X  volatile const  uint32_t  RESERVED4[63];
N  __IO uint32_t  ENABLE;                            /*!< Enable the COMP.                                                      */
X  volatile uint32_t  ENABLE;                             
N  __IO uint32_t  PSEL;                              /*!< Input pin select.                                                     */
X  volatile uint32_t  PSEL;                               
N  __IO uint32_t  REFSEL;                            /*!< Reference select.                                                     */
X  volatile uint32_t  REFSEL;                             
N  __IO uint32_t  EXTREFSEL;                         /*!< External reference select.                                            */
X  volatile uint32_t  EXTREFSEL;                          
N  __I  uint32_t  RESERVED5[8];
X  volatile const  uint32_t  RESERVED5[8];
N  __IO uint32_t  TH;                                /*!< Threshold configuration for hysteresis unit.                          */
X  volatile uint32_t  TH;                                 
N  __IO uint32_t  MODE;                              /*!< Mode configuration.                                                   */
X  volatile uint32_t  MODE;                               
N  __I  uint32_t  RESERVED6[689];
X  volatile const  uint32_t  RESERVED6[689];
N  __IO uint32_t  POWER;                             /*!< Peripheral power control.                                             */
X  volatile uint32_t  POWER;                              
N} NRF_COMP_Type;
N
N
N/* ================================================================================ */
N/* ================                       SWI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief SW Interrupts. (SWI)
N  */
N
Ntypedef struct {                                    /*!< SWI Structure                                                         */
N  __I  uint32_t  UNUSED;                            /*!< Unused.                                                               */
X  volatile const  uint32_t  UNUSED;                             
N} NRF_SWI_Type;
N
N
N/* ================================================================================ */
N/* ================                      NVMC                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Non Volatile Memory Controller. (NVMC)
N  */
N
Ntypedef struct {                                    /*!< NVMC Structure                                                        */
N  __I  uint32_t  RESERVED0[256];
X  volatile const  uint32_t  RESERVED0[256];
N  __I  uint32_t  READY;                             /*!< Ready flag.                                                           */
X  volatile const  uint32_t  READY;                              
N  __I  uint32_t  RESERVED1[64];
X  volatile const  uint32_t  RESERVED1[64];
N  __IO uint32_t  CONFIG;                            /*!< Configuration register.                                               */
X  volatile uint32_t  CONFIG;                             
N  __IO uint32_t  ERASEPAGE;                         /*!< Register for erasing a non-protected non-volatile memory page.        */
X  volatile uint32_t  ERASEPAGE;                          
N  __IO uint32_t  ERASEALL;                          /*!< Register for erasing all non-volatile user memory.                    */
X  volatile uint32_t  ERASEALL;                           
N  __IO uint32_t  ERASEPROTECTEDPAGE;                /*!< Register for erasing a protected non-volatile memory page.            */
X  volatile uint32_t  ERASEPROTECTEDPAGE;                 
N  __IO uint32_t  ERASEUICR;                         /*!< Register for start erasing User Information Congfiguration Registers. */
X  volatile uint32_t  ERASEUICR;                          
N} NRF_NVMC_Type;
N
N
N/* ================================================================================ */
N/* ================                       PPI                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief PPI controller. (PPI)
N  */
N
Ntypedef struct {                                    /*!< PPI Structure                                                         */
N  PPI_TASKS_CHG_Type TASKS_CHG[4];                  /*!< Channel group tasks.                                                  */
N  __I  uint32_t  RESERVED0[312];
X  volatile const  uint32_t  RESERVED0[312];
N  __IO uint32_t  CHEN;                              /*!< Channel enable.                                                       */
X  volatile uint32_t  CHEN;                               
N  __IO uint32_t  CHENSET;                           /*!< Channel enable set.                                                   */
X  volatile uint32_t  CHENSET;                            
N  __IO uint32_t  CHENCLR;                           /*!< Channel enable clear.                                                 */
X  volatile uint32_t  CHENCLR;                            
N  __I  uint32_t  RESERVED1;
X  volatile const  uint32_t  RESERVED1;
N  PPI_CH_Type CH[16];                               /*!< PPI Channel.                                                          */
N  __I  uint32_t  RESERVED2[156];
X  volatile const  uint32_t  RESERVED2[156];
N  __IO uint32_t  CHG[4];                            /*!< Channel group configuration.                                          */
X  volatile uint32_t  CHG[4];                             
N} NRF_PPI_Type;
N
N
N/* ================================================================================ */
N/* ================                      FICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief Factory Information Configuration. (FICR)
N  */
N
Ntypedef struct {                                    /*!< FICR Structure                                                        */
N  __I  uint32_t  RESERVED0[4];
X  volatile const  uint32_t  RESERVED0[4];
N  __I  uint32_t  CODEPAGESIZE;                      /*!< Code memory page size in bytes.                                       */
X  volatile const  uint32_t  CODEPAGESIZE;                       
N  __I  uint32_t  CODESIZE;                          /*!< Code memory size in pages.                                            */
X  volatile const  uint32_t  CODESIZE;                           
N  __I  uint32_t  RESERVED1[4];
X  volatile const  uint32_t  RESERVED1[4];
N  __I  uint32_t  CLENR0;                            /*!< Length of code region 0 in bytes.                                     */
X  volatile const  uint32_t  CLENR0;                             
N  __I  uint32_t  PPFC;                              /*!< Pre-programmed factory code present.                                  */
X  volatile const  uint32_t  PPFC;                               
N  __I  uint32_t  RESERVED2;
X  volatile const  uint32_t  RESERVED2;
N  __I  uint32_t  NUMRAMBLOCK;                       /*!< Number of individualy controllable RAM blocks.                        */
X  volatile const  uint32_t  NUMRAMBLOCK;                        
N  __I  uint32_t  SIZERAMBLOCK[4];                   /*!< Size of RAM block in bytes.                                           */
X  volatile const  uint32_t  SIZERAMBLOCK[4];                    
N  __I  uint32_t  RESERVED3[5];
X  volatile const  uint32_t  RESERVED3[5];
N  __I  uint32_t  CONFIGID;                          /*!< Configuration identifier.                                             */
X  volatile const  uint32_t  CONFIGID;                           
N  __I  uint32_t  DEVICEID[2];                       /*!< Device identifier.                                                    */
X  volatile const  uint32_t  DEVICEID[2];                        
N  __I  uint32_t  RESERVED4[6];
X  volatile const  uint32_t  RESERVED4[6];
N  __I  uint32_t  ER[4];                             /*!< Encryption root.                                                      */
X  volatile const  uint32_t  ER[4];                              
N  __I  uint32_t  IR[4];                             /*!< Identity root.                                                        */
X  volatile const  uint32_t  IR[4];                              
N  __I  uint32_t  DEVICEADDRTYPE;                    /*!< Device address type.                                                  */
X  volatile const  uint32_t  DEVICEADDRTYPE;                     
N  __I  uint32_t  DEVICEADDR[2];                     /*!< Device address.                                                       */
X  volatile const  uint32_t  DEVICEADDR[2];                      
N  __I  uint32_t  OVERRIDEEN;                        /*!< Radio calibration override enable.                                    */
X  volatile const  uint32_t  OVERRIDEEN;                         
N  __I  uint32_t  RESERVED5[15];
X  volatile const  uint32_t  RESERVED5[15];
N  __I  uint32_t  BLE_1MBIT[5];                      /*!< Override values for the OVERRIDEn registers in RADIO for BLE_1Mbit
X  volatile const  uint32_t  BLE_1MBIT[5];                      
N                                                         mode.                                                                 */
N} NRF_FICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      UICR                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief User Information Configuration. (UICR)
N  */
N
Ntypedef struct {                                    /*!< UICR Structure                                                        */
N  __IO uint32_t  CLENR0;                            /*!< Length of code region 0.                                              */
X  volatile uint32_t  CLENR0;                             
N  __IO uint32_t  RBPCONF;                           /*!< Readback protection configuration.                                    */
X  volatile uint32_t  RBPCONF;                            
N  __IO uint32_t  XTALFREQ;                          /*!< Reset value for CLOCK XTALFREQ register.                              */
X  volatile uint32_t  XTALFREQ;                           
N  __I  uint32_t  RESERVED0;
X  volatile const  uint32_t  RESERVED0;
N  __I  uint32_t  FWID;                              /*!< Firmware ID.                                                          */
X  volatile const  uint32_t  FWID;                               
N  __IO uint32_t  BOOTLOADERADDR;                    /*!< Bootloader start address.                                             */
X  volatile uint32_t  BOOTLOADERADDR;                     
N} NRF_UICR_Type;
N
N
N/* ================================================================================ */
N/* ================                      GPIO                      ================ */
N/* ================================================================================ */
N
N
N/**
N  * @brief General purpose input and output. (GPIO)
N  */
N
Ntypedef struct {                                    /*!< GPIO Structure                                                        */
N  __I  uint32_t  RESERVED0[321];
X  volatile const  uint32_t  RESERVED0[321];
N  __IO uint32_t  OUT;                               /*!< Write GPIO port.                                                      */
X  volatile uint32_t  OUT;                                
N  __IO uint32_t  OUTSET;                            /*!< Set individual bits in GPIO port.                                     */
X  volatile uint32_t  OUTSET;                             
N  __IO uint32_t  OUTCLR;                            /*!< Clear individual bits in GPIO port.                                   */
X  volatile uint32_t  OUTCLR;                             
N  __I  uint32_t  IN;                                /*!< Read GPIO port.                                                       */
X  volatile const  uint32_t  IN;                                 
N  __IO uint32_t  DIR;                               /*!< Direction of GPIO pins.                                               */
X  volatile uint32_t  DIR;                                
N  __IO uint32_t  DIRSET;                            /*!< DIR set register.                                                     */
X  volatile uint32_t  DIRSET;                             
N  __IO uint32_t  DIRCLR;                            /*!< DIR clear register.                                                   */
X  volatile uint32_t  DIRCLR;                             
N  __I  uint32_t  RESERVED1[120];
X  volatile const  uint32_t  RESERVED1[120];
N  __IO uint32_t  PIN_CNF[32];                       /*!< Configuration of GPIO pins.                                           */
X  volatile uint32_t  PIN_CNF[32];                        
N} NRF_GPIO_Type;
N
N
N/* --------------------  End of section using anonymous unions  ------------------- */
N#if defined(__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined(__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif defined(__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined(__TASKING__)
S  #pragma warning restore
S#else
S  #warning Not supported compiler type
N#endif
N
N
N
N
N/* ================================================================================ */
N/* ================              Peripheral memory map             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER_BASE                  0x40000000UL
N#define NRF_CLOCK_BASE                  0x40000000UL
N#define NRF_MPU_BASE                    0x40000000UL
N#define NRF_PU_BASE                     0x40000000UL
N#define NRF_AMLI_BASE                   0x40000000UL
N#define NRF_RADIO_BASE                  0x40001000UL
N#define NRF_UART0_BASE                  0x40002000UL
N#define NRF_SPI0_BASE                   0x40003000UL
N#define NRF_TWI0_BASE                   0x40003000UL
N#define NRF_SPI1_BASE                   0x40004000UL
N#define NRF_TWI1_BASE                   0x40004000UL
N#define NRF_SPIS1_BASE                  0x40004000UL
N#define NRF_GPIOTE_BASE                 0x40006000UL
N#define NRF_ADC_BASE                    0x40007000UL
N#define NRF_TIMER0_BASE                 0x40008000UL
N#define NRF_TIMER1_BASE                 0x40009000UL
N#define NRF_TIMER2_BASE                 0x4000A000UL
N#define NRF_RTC0_BASE                   0x4000B000UL
N#define NRF_TEMP_BASE                   0x4000C000UL
N#define NRF_RNG_BASE                    0x4000D000UL
N#define NRF_ECB_BASE                    0x4000E000UL
N#define NRF_AAR_BASE                    0x4000F000UL
N#define NRF_CCM_BASE                    0x4000F000UL
N#define NRF_WDT_BASE                    0x40010000UL
N#define NRF_RTC1_BASE                   0x40011000UL
N#define NRF_QDEC_BASE                   0x40012000UL
N#define NRF_LPCOMP_BASE                 0x40013000UL
N#define NRF_COMP_BASE                   0x40013000UL
N#define NRF_SWI_BASE                    0x40014000UL
N#define NRF_NVMC_BASE                   0x4001E000UL
N#define NRF_PPI_BASE                    0x4001F000UL
N#define NRF_FICR_BASE                   0x10000000UL
N#define NRF_UICR_BASE                   0x10001000UL
N#define NRF_GPIO_BASE                   0x50000000UL
N
N
N/* ================================================================================ */
N/* ================             Peripheral declaration             ================ */
N/* ================================================================================ */
N
N#define NRF_POWER                       ((NRF_POWER_Type          *) NRF_POWER_BASE)
N#define NRF_CLOCK                       ((NRF_CLOCK_Type          *) NRF_CLOCK_BASE)
N#define NRF_MPU                         ((NRF_MPU_Type            *) NRF_MPU_BASE)
N#define NRF_PU                          ((NRF_PU_Type             *) NRF_PU_BASE)
N#define NRF_AMLI                        ((NRF_AMLI_Type           *) NRF_AMLI_BASE)
N#define NRF_RADIO                       ((NRF_RADIO_Type          *) NRF_RADIO_BASE)
N#define NRF_UART0                       ((NRF_UART_Type           *) NRF_UART0_BASE)
N#define NRF_SPI0                        ((NRF_SPI_Type            *) NRF_SPI0_BASE)
N#define NRF_TWI0                        ((NRF_TWI_Type            *) NRF_TWI0_BASE)
N#define NRF_SPI1                        ((NRF_SPI_Type            *) NRF_SPI1_BASE)
N#define NRF_TWI1                        ((NRF_TWI_Type            *) NRF_TWI1_BASE)
N#define NRF_SPIS1                       ((NRF_SPIS_Type           *) NRF_SPIS1_BASE)
N#define NRF_GPIOTE                      ((NRF_GPIOTE_Type         *) NRF_GPIOTE_BASE)
N#define NRF_ADC                         ((NRF_ADC_Type            *) NRF_ADC_BASE)
N#define NRF_TIMER0                      ((NRF_TIMER_Type          *) NRF_TIMER0_BASE)
N#define NRF_TIMER1                      ((NRF_TIMER_Type          *) NRF_TIMER1_BASE)
N#define NRF_TIMER2                      ((NRF_TIMER_Type          *) NRF_TIMER2_BASE)
N#define NRF_RTC0                        ((NRF_RTC_Type            *) NRF_RTC0_BASE)
N#define NRF_TEMP                        ((NRF_TEMP_Type           *) NRF_TEMP_BASE)
N#define NRF_RNG                         ((NRF_RNG_Type            *) NRF_RNG_BASE)
N#define NRF_ECB                         ((NRF_ECB_Type            *) NRF_ECB_BASE)
N#define NRF_AAR                         ((NRF_AAR_Type            *) NRF_AAR_BASE)
N#define NRF_CCM                         ((NRF_CCM_Type            *) NRF_CCM_BASE)
N#define NRF_WDT                         ((NRF_WDT_Type            *) NRF_WDT_BASE)
N#define NRF_RTC1                        ((NRF_RTC_Type            *) NRF_RTC1_BASE)
N#define NRF_QDEC                        ((NRF_QDEC_Type           *) NRF_QDEC_BASE)
N#define NRF_LPCOMP                      ((NRF_LPCOMP_Type         *) NRF_LPCOMP_BASE)
N#define NRF_COMP                        ((NRF_COMP_Type           *) NRF_COMP_BASE)
N#define NRF_SWI                         ((NRF_SWI_Type            *) NRF_SWI_BASE)
N#define NRF_NVMC                        ((NRF_NVMC_Type           *) NRF_NVMC_BASE)
N#define NRF_PPI                         ((NRF_PPI_Type            *) NRF_PPI_BASE)
N#define NRF_FICR                        ((NRF_FICR_Type           *) NRF_FICR_BASE)
N#define NRF_UICR                        ((NRF_UICR_Type           *) NRF_UICR_BASE)
N#define NRF_GPIO                        ((NRF_GPIO_Type           *) NRF_GPIO_BASE)
N
N
N/** @} */ /* End of group Device_Peripheral_Registers */
N/** @} */ /* End of group nRF51 */
N/** @} */ /* End of group Nordic Semiconductor */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif  /* nRF51_H */
N
L 34 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "nrf_sdm.h"
L 1 "..\..\..\Software\Include\nrf_sdm.h" 1
N/*
N * Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N/**
N  @defgroup nrf_sdm_api SoftDevice Manager API
N  @{
N     
N  @brief APIs for SoftDevice management.
N 
N*/
N
N/* Header guard */
N#ifndef NRF_SDM_H__
N#define NRF_SDM_H__
N
N#include "nrf_svc.h"
N#include "nrf51.h"
N#include "nrf_soc.h"
L 1 "..\..\..\Software\Include\nrf_soc.h" 1
N/* Copyright (c) 2011 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N 
N/**
N  @defgroup nrf_soc_api SoC Library API
N  @{
N  
N  @brief APIs for the SoC library.
N  
N*/
N
N#ifndef NRF_SOC_H__
N#define NRF_SOC_H__
N
N#include <stdint.h>
N#include <stdbool.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision: 172039 $
N * Checkin $Date: 2011-11-02 12:58:12 +0000 (Wed, 02 Nov 2011) $
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 410000
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 22 "..\..\..\Software\Include\nrf_soc.h" 2
N#include "nrf_svc.h"
N#include "nrf51.h"
N#include "nrf51_bitfields.h"
L 1 "..\..\..\Software\Include\nrf51_bitfields.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N
N#ifndef __NRF51_BITS_H
N#define __NRF51_BITS_H
N
N/*lint ++flb "Enter library region */
N
N#include <core_cm0.h>
L 1 "C:\Keil\ARM\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.02
N * @date     16. July 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
S#define __CORE_CM0_H_GENERIC
S
S/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
S  CMSIS violates the following MISRA-C:2004 rules:
S
S   \li Required Rule 8.5, object/function definition in header file.<br>
S     Function definitions in header files are used to allow 'inlining'.
S
S   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
S     Unions are used for effective representation of core registers.
S
S   \li Advisory Rule 19.7, Function-like macro defined.<br>
S     Function-like macros are used to allow more efficient code.
S */
S
S
S/*******************************************************************************
S *                 CMSIS definitions
S ******************************************************************************/
S/** \ingroup Cortex_M0
S  @{
S */
S
S/*  CMSIS CM0 definitions */
S#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
S#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
S#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
S                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
S
S#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
S
S
S#if   defined ( __CC_ARM )
S  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
S  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
S  #define __STATIC_INLINE  static __inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#endif
S
S/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
S*/
S#define __FPU_USED       0
S
S#if defined ( __CC_ARM )
S  #if defined __TARGET_FPU_VFP
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S#endif
S
S#include <stdint.h>                      /* standard types definitions                      */
S#include <core_cmInstr.h>                /* Core Instruction Access                         */
S#include <core_cmFunc.h>                 /* Core Function Access                            */
S
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
S#define __CORE_CM0_H_DEPENDANT
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions                */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
S
S/*@} end of group Cortex_M0 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S ******************************************************************************/
S/** \defgroup CMSIS_core_register Defines and Type Definitions
S    \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_CORE  Status and Control Registers
S    \brief  Core Register type definitions.
S  @{
S */
S
S/** \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
S#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
S#endif
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} APSR_Type;
S
S
S/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} IPSR_Type;
S
S
S/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
S#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
S#endif
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} xPSR_Type;
S
S
S/** \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} CONTROL_Type;
S
S/*@} end of group CMSIS_CORE */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S    \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
S       uint32_t RESERVED0[31];
S  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
S       uint32_t RSERVED1[31];
S  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
S       uint32_t RESERVED2[31];
S  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
S       uint32_t RESERVED3[31];
S       uint32_t RESERVED4[64];
S  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
S}  NVIC_Type;
S
S/*@} end of group CMSIS_NVIC */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCB     System Control Block (SCB)
S    \brief      Type definitions for the System Control Block Registers
S  @{
S */
S
S/** \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
S  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
S       uint32_t RESERVED0;
S  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
S  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
S  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
S       uint32_t RESERVED1;
S  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
S  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S    \brief      Type definitions for the System Timer Registers.
S  @{
S */
S
S/** \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
S  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
S  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
S                are only accessible over DAP and not via processor. Therefore
S                they are not covered by the Cortex-M0 header file.
S  @{
S */
S/*@} end of group CMSIS_CoreDebug */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_core_base     Core Definitions
S    \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M0 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
S
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
S
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S    \brief      Functions that manage interrupts and exceptions via the NVIC.
S    @{
S */
S
S/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
S/* The following MACROS handle generation of the register offset and byte masks */
S#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
S#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
S#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
S
S
S/** \brief  Enable External Interrupt
S
S    The function enables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Disable External Interrupt
S
S    The function disables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Get Pending Interrupt
S
S    The function reads the pending register in the NVIC and returns the pending bit
S    for the specified interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not pending.
S    \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
S}
S
S
S/** \brief  Set Pending Interrupt
S
S    The function sets the pending bit of an external interrupt.
S
S    \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
S}
S
S
S/** \brief  Clear Pending Interrupt
S
S    The function clears the pending bit of an external interrupt.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
S}
S
S
S/** \brief  Set Interrupt Priority
S
S    The function sets the priority of an interrupt.
S
S    \note The priority cannot be set for every core interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S    \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if(IRQn < 0) {
S    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S  else {
S    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
S        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
S}
S
S
S/** \brief  Get Interrupt Priority
S
S    The function reads the priority of an interrupt. The interrupt
S    number can be positive to specify an external (device specific)
S    interrupt, or negative to specify an internal (core) interrupt.
S
S
S    \param [in]   IRQn  Interrupt number.
S    \return             Interrupt Priority. Value is aligned automatically to the implemented
S                        priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if(IRQn < 0) {
S    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
S  else {
S    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
S}
S
S
S/** \brief  System Reset
S
S    The function initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                     /* Ensure all outstanding memory accesses included
S                                                                  buffered write are completed before reset */
S  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
S                 SCB_AIRCR_SYSRESETREQ_Msk);
S  __DSB();                                                     /* Ensure completion of memory access */
S  while(1);                                                    /* wait until reset */
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S    \brief      Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0)
S
S/** \brief  System Tick Configuration
S
S    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
S    Counter is in free running mode to generate periodic interrupts.
S
S    \param [in]  ticks  Number of ticks between two interrupts.
S
S    \return          0  Function succeeded.
S    \return          1  Function failed.
S
S    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S    must contain a vendor-specific implementation of this function.
S
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
S
S  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
S  return (0);                                                  /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N#ifdef __cplusplus
S}
N#endif
L 20 "..\..\..\Software\Include\nrf51_bitfields.h" 2
N
N/* Peripheral: AAR */
N/* Description: Accelerated Address Resolver. */
N
N/* Register: AAR_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on NOTRESOLVED event. */
N#define AAR_INTENSET_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Msk (0x1UL << AAR_INTENSET_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENSET_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_NOTRESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on RESOLVED event. */
N#define AAR_INTENSET_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Msk (0x1UL << AAR_INTENSET_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENSET_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_RESOLVED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define AAR_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENSET_END_Msk (0x1UL << AAR_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: AAR_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on NOTRESOLVED event. */
N#define AAR_INTENCLR_NOTRESOLVED_Pos (2UL) /*!< Position of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Msk (0x1UL << AAR_INTENCLR_NOTRESOLVED_Pos) /*!< Bit mask of NOTRESOLVED field. */
N#define AAR_INTENCLR_NOTRESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_NOTRESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on RESOLVED event. */
N#define AAR_INTENCLR_RESOLVED_Pos (1UL) /*!< Position of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Msk (0x1UL << AAR_INTENCLR_RESOLVED_Pos) /*!< Bit mask of RESOLVED field. */
N#define AAR_INTENCLR_RESOLVED_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_RESOLVED_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_RESOLVED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define AAR_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define AAR_INTENCLR_END_Msk (0x1UL << AAR_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define AAR_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define AAR_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define AAR_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: AAR_STATUS */
N/* Description: Resolution status. */
N
N/* Bits 3..0 : The IRK used last time an address was resolved. */
N#define AAR_STATUS_STATUS_Pos (0UL) /*!< Position of STATUS field. */
N#define AAR_STATUS_STATUS_Msk (0xFUL << AAR_STATUS_STATUS_Pos) /*!< Bit mask of STATUS field. */
N
N/* Register: AAR_ENABLE */
N/* Description: Enable AAR. */
N
N/* Bits 1..0 : Enable AAR. */
N#define AAR_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Msk (0x3UL << AAR_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define AAR_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled AAR. */
N#define AAR_ENABLE_ENABLE_Enabled (0x03UL) /*!< Enable AAR. */
N
N/* Register: AAR_NIRK */
N/* Description: Number of Identity root Keys in the IRK data structure. */
N
N/* Bits 4..0 : Number of Identity root Keys in the IRK data structure. */
N#define AAR_NIRK_NIRK_Pos (0UL) /*!< Position of NIRK field. */
N#define AAR_NIRK_NIRK_Msk (0x1FUL << AAR_NIRK_NIRK_Pos) /*!< Bit mask of NIRK field. */
N
N/* Register: AAR_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define AAR_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define AAR_POWER_POWER_Msk (0x1UL << AAR_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define AAR_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define AAR_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ADC */
N/* Description: Analog to digital converter. */
N
N/* Register: ADC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on END event. */
N#define ADC_INTENSET_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENSET_END_Msk (0x1UL << ADC_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ADC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on END event. */
N#define ADC_INTENCLR_END_Pos (0UL) /*!< Position of END field. */
N#define ADC_INTENCLR_END_Msk (0x1UL << ADC_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define ADC_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define ADC_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define ADC_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ADC_BUSY */
N/* Description: ADC busy register. */
N
N/* Bit 0 : ADC busy register. */
N#define ADC_BUSY_BUSY_Pos (0UL) /*!< Position of BUSY field. */
N#define ADC_BUSY_BUSY_Msk (0x1UL << ADC_BUSY_BUSY_Pos) /*!< Bit mask of BUSY field. */
N#define ADC_BUSY_BUSY_Ready (0UL) /*!< No ongoing ADC conversion is taking place. ADC is ready. */
N#define ADC_BUSY_BUSY_Busy (1UL) /*!< An ADC conversion is taking place. ADC is busy. */
N
N/* Register: ADC_ENABLE */
N/* Description: ADC enable. */
N
N/* Bits 1..0 : ADC enable. */
N#define ADC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Msk (0x3UL << ADC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define ADC_ENABLE_ENABLE_Disabled (0x00UL) /*!< ADC is disabled. */
N#define ADC_ENABLE_ENABLE_Enabled (0x01UL) /*!< ADC is enabled. If an analog input pin is selected as source of the conversion, the selected pin is configured as an analog input. */
N
N/* Register: ADC_CONFIG */
N/* Description: ADC configuration register. */
N
N/* Bits 17..16 : ADC external reference pin selection. */
N#define ADC_CONFIG_EXTREFSEL_Pos (16UL) /*!< Position of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_Msk (0x3UL << ADC_CONFIG_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define ADC_CONFIG_EXTREFSEL_None (0UL) /*!< Analog external reference inputs disabled. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference0 (1UL) /*!< Use analog reference 0 as reference. */
N#define ADC_CONFIG_EXTREFSEL_AnalogReference1 (2UL) /*!< Use analog reference 1 as reference. */
N
N/* Bits 15..8 : ADC analog pin selection. */
N#define ADC_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define ADC_CONFIG_PSEL_Msk (0xFFUL << ADC_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define ADC_CONFIG_PSEL_Disabled (0UL) /*!< Analog input pins disabled. */
N#define ADC_CONFIG_PSEL_AnalogInput0 (1UL) /*!< Use analog input 0 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput1 (2UL) /*!< Use analog input 1 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput2 (4UL) /*!< Use analog input 2 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput3 (8UL) /*!< Use analog input 3 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput4 (16UL) /*!< Use analog input 4 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput5 (32UL) /*!< Use analog input 5 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput6 (64UL) /*!< Use analog input 6 as analog input. */
N#define ADC_CONFIG_PSEL_AnalogInput7 (128UL) /*!< Use analog input 7 as analog input. */
N
N/* Bits 6..5 : ADC reference selection. */
N#define ADC_CONFIG_REFSEL_Pos (5UL) /*!< Position of REFSEL field. */
N#define ADC_CONFIG_REFSEL_Msk (0x3UL << ADC_CONFIG_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define ADC_CONFIG_REFSEL_VBG (0x00UL) /*!< Use internal 1.2V bandgap voltage as reference for conversion. */
N#define ADC_CONFIG_REFSEL_External (0x01UL) /*!< Use external source configured by EXTREFSEL as reference for conversion. */
N#define ADC_CONFIG_REFSEL_SupplyOneHalfPrescaling (0x02UL) /*!< Use supply voltage with 1/2 prescaling as reference for conversion. Only usable when supply voltage is between 1.7V and 2.6V. */
N#define ADC_CONFIG_REFSEL_SupplyOneThirdPrescaling (0x03UL) /*!< Use supply voltage with 1/3 prescaling as reference for conversion. Only usable when supply voltage is between 2.5V and 3.6V. */
N
N/* Bits 4..2 : ADC input selection. */
N#define ADC_CONFIG_INPSEL_Pos (2UL) /*!< Position of INPSEL field. */
N#define ADC_CONFIG_INPSEL_Msk (0x7UL << ADC_CONFIG_INPSEL_Pos) /*!< Bit mask of INPSEL field. */
N#define ADC_CONFIG_INPSEL_AnalogInputNoPrescaling (0x00UL) /*!< Analog input specified by PSEL with no prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputTwoThirdsPrescaling (0x01UL) /*!< Analog input specified by PSEL with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_AnalogInputOneThirdPrescaling (0x02UL) /*!< Analog input specified by PSEL with 1/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyTwoThirdsPrescaling (0x05UL) /*!< Supply voltage with 2/3 prescaling used as input for the conversion. */
N#define ADC_CONFIG_INPSEL_SupplyOneThirdPrescaling (0x06UL) /*!< Supply voltage with 1/3 prescaling used as input for the conversion. */
N
N/* Bits 1..0 : ADC resolution. */
N#define ADC_CONFIG_RES_Pos (0UL) /*!< Position of RES field. */
N#define ADC_CONFIG_RES_Msk (0x3UL << ADC_CONFIG_RES_Pos) /*!< Bit mask of RES field. */
N#define ADC_CONFIG_RES_8bit (0x00UL) /*!< 8bit ADC resolution. */
N#define ADC_CONFIG_RES_9bit (0x01UL) /*!< 9bit ADC resolution. */
N#define ADC_CONFIG_RES_10bit (0x02UL) /*!< 10bit ADC resolution. */
N
N/* Register: ADC_RESULT */
N/* Description: Result of ADC conversion. */
N
N/* Bits 9..0 : Result of ADC conversion. */
N#define ADC_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define ADC_RESULT_RESULT_Msk (0x3FFUL << ADC_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N
N/* Register: ADC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ADC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ADC_POWER_POWER_Msk (0x1UL << ADC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ADC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ADC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: AMLI */
N/* Description: AHB Multi-Layer Interface. */
N
N/* Register: AMLI_RAMPRI_CPU0 */
N/* Description: Configurable priority configuration register for CPU0. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_CPU0_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_CPU0_RAM3_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_CPU0_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_CPU0_RAM2_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_CPU0_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_CPU0_RAM1_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_CPU0_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_CPU0_RAM0_Msk (0xFUL << AMLI_RAMPRI_CPU0_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_SPIS1 */
N/* Description: Configurable priority configuration register for SPIS1. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_SPIS1_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_SPIS1_RAM3_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_SPIS1_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_SPIS1_RAM2_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_SPIS1_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_SPIS1_RAM1_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_SPIS1_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_SPIS1_RAM0_Msk (0xFUL << AMLI_RAMPRI_SPIS1_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_RADIO */
N/* Description: Configurable priority configuration register for RADIO. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_RADIO_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_RADIO_RAM3_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_RADIO_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_RADIO_RAM2_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_RADIO_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_RADIO_RAM1_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_RADIO_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_RADIO_RAM0_Msk (0xFUL << AMLI_RAMPRI_RADIO_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_ECB */
N/* Description: Configurable priority configuration register for ECB. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_ECB_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_ECB_RAM3_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_ECB_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_ECB_RAM2_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_ECB_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_ECB_RAM1_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_ECB_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_ECB_RAM0_Msk (0xFUL << AMLI_RAMPRI_ECB_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_CCM */
N/* Description: Configurable priority configuration register for CCM. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_CCM_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_CCM_RAM3_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_CCM_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_CCM_RAM2_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_CCM_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_CCM_RAM1_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_CCM_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_CCM_RAM0_Msk (0xFUL << AMLI_RAMPRI_CCM_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Register: AMLI_RAMPRI_AAR */
N/* Description: Configurable priority configuration register for AAR. */
N
N/* Bits 15..12 : Configuration field for RAM block 3. */
N#define AMLI_RAMPRI_AAR_RAM3_Pos (12UL) /*!< Position of RAM3 field. */
N#define AMLI_RAMPRI_AAR_RAM3_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM3_Pos) /*!< Bit mask of RAM3 field. */
N
N/* Bits 11..8 : Configuration field for RAM block 2. */
N#define AMLI_RAMPRI_AAR_RAM2_Pos (8UL) /*!< Position of RAM2 field. */
N#define AMLI_RAMPRI_AAR_RAM2_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM2_Pos) /*!< Bit mask of RAM2 field. */
N
N/* Bits 7..4 : Configuration field for RAM block 1. */
N#define AMLI_RAMPRI_AAR_RAM1_Pos (4UL) /*!< Position of RAM1 field. */
N#define AMLI_RAMPRI_AAR_RAM1_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM1_Pos) /*!< Bit mask of RAM1 field. */
N
N/* Bits 3..0 : Configuration field for RAM block 0. */
N#define AMLI_RAMPRI_AAR_RAM0_Pos (0UL) /*!< Position of RAM0 field. */
N#define AMLI_RAMPRI_AAR_RAM0_Msk (0xFUL << AMLI_RAMPRI_AAR_RAM0_Pos) /*!< Bit mask of RAM0 field. */
N
N/* Peripheral: CCM */
N/* Description: AES CCM Mode Encryption. */
N
N/* Register: CCM_SHORTS */
N/* Description: Shortcut for the CCM. */
N
N/* Bit 0 : Short-cut between ENDKSGEN event and CRYPT task. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Pos (0UL) /*!< Position of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Msk (0x1UL << CCM_SHORTS_ENDKSGEN_CRYPT_Pos) /*!< Bit mask of ENDKSGEN_CRYPT field. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Disabled (0UL) /*!< Shortcut disabled. */
N#define CCM_SHORTS_ENDKSGEN_CRYPT_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: CCM_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ERROR event. */
N#define CCM_INTENSET_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENSET_ERROR_Msk (0x1UL << CCM_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ENDCRYPT event. */
N#define CCM_INTENSET_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Msk (0x1UL << CCM_INTENSET_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENSET_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDCRYPT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDKSGEN event. */
N#define CCM_INTENSET_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Msk (0x1UL << CCM_INTENSET_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENSET_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENSET_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENSET_ENDKSGEN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CCM_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ERROR event. */
N#define CCM_INTENCLR_ERROR_Pos (2UL) /*!< Position of ERROR field. */
N#define CCM_INTENCLR_ERROR_Msk (0x1UL << CCM_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define CCM_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ENDCRYPT event. */
N#define CCM_INTENCLR_ENDCRYPT_Pos (1UL) /*!< Position of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Msk (0x1UL << CCM_INTENCLR_ENDCRYPT_Pos) /*!< Bit mask of ENDCRYPT field. */
N#define CCM_INTENCLR_ENDCRYPT_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDCRYPT_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDCRYPT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDKSGEN event. */
N#define CCM_INTENCLR_ENDKSGEN_Pos (0UL) /*!< Position of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Msk (0x1UL << CCM_INTENCLR_ENDKSGEN_Pos) /*!< Bit mask of ENDKSGEN field. */
N#define CCM_INTENCLR_ENDKSGEN_Disabled (0UL) /*!< Interrupt disabled. */
N#define CCM_INTENCLR_ENDKSGEN_Enabled (1UL) /*!< Interrupt enabled. */
N#define CCM_INTENCLR_ENDKSGEN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CCM_MICSTATUS */
N/* Description: CCM RX MIC check result. */
N
N/* Bit 0 : Result of the MIC check performed during the previous CCM RX STARTCRYPT */
N#define CCM_MICSTATUS_MICSTATUS_Pos (0UL) /*!< Position of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_Msk (0x1UL << CCM_MICSTATUS_MICSTATUS_Pos) /*!< Bit mask of MICSTATUS field. */
N#define CCM_MICSTATUS_MICSTATUS_CheckFailed (0UL) /*!< MIC check failed. */
N#define CCM_MICSTATUS_MICSTATUS_CheckPassed (1UL) /*!< MIC check passed. */
N
N/* Register: CCM_ENABLE */
N/* Description: CCM enable. */
N
N/* Bits 1..0 : CCM enable. */
N#define CCM_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Msk (0x3UL << CCM_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define CCM_ENABLE_ENABLE_Disabled (0x00UL) /*!< CCM is disabled. */
N#define CCM_ENABLE_ENABLE_Enabled (0x02UL) /*!< CCM is enabled. */
N
N/* Register: CCM_MODE */
N/* Description: Operation mode. */
N
N/* Bit 0 : CCM mode operation. */
N#define CCM_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define CCM_MODE_MODE_Msk (0x1UL << CCM_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define CCM_MODE_MODE_Encryption (0UL) /*!< CCM mode TX */
N#define CCM_MODE_MODE_Decryption (1UL) /*!< CCM mode TX */
N
N/* Register: CCM_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define CCM_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define CCM_POWER_POWER_Msk (0x1UL << CCM_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define CCM_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define CCM_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: CLOCK */
N/* Description: Clock control. */
N
N/* Register: CLOCK_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 4 : Enable interrupt on CTTO event. */
N#define CLOCK_INTENSET_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Msk (0x1UL << CLOCK_INTENSET_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENSET_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_CTTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on DONE event. */
N#define CLOCK_INTENSET_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENSET_DONE_Msk (0x1UL << CLOCK_INTENSET_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENSET_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_DONE_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_LFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENSET_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENSET_HFCLKSTARTED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: CLOCK_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 4 : Disable interrupt on CTTO event. */
N#define CLOCK_INTENCLR_CTTO_Pos (4UL) /*!< Position of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Msk (0x1UL << CLOCK_INTENCLR_CTTO_Pos) /*!< Bit mask of CTTO field. */
N#define CLOCK_INTENCLR_CTTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_CTTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_CTTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on DONE event. */
N#define CLOCK_INTENCLR_DONE_Pos (3UL) /*!< Position of DONE field. */
N#define CLOCK_INTENCLR_DONE_Msk (0x1UL << CLOCK_INTENCLR_DONE_Pos) /*!< Bit mask of DONE field. */
N#define CLOCK_INTENCLR_DONE_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_DONE_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_DONE_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on LFCLKSTARTED event. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Pos (1UL) /*!< Position of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_LFCLKSTARTED_Pos) /*!< Bit mask of LFCLKSTARTED field. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_LFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on HFCLKSTARTED event. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Pos (0UL) /*!< Position of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Msk (0x1UL << CLOCK_INTENCLR_HFCLKSTARTED_Pos) /*!< Bit mask of HFCLKSTARTED field. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Disabled (0UL) /*!< Interrupt disabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Enabled (1UL) /*!< Interrupt enabled. */
N#define CLOCK_INTENCLR_HFCLKSTARTED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: CLOCK_HFCLKSTAT */
N/* Description: High frequency clock status. */
N
N/* Bit 16 : State for the HFCLK. */
N#define CLOCK_HFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_Msk (0x1UL << CLOCK_HFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_HFCLKSTAT_STATE_NotRunning (0UL) /*!< HFCLK clock not running. */
N#define CLOCK_HFCLKSTAT_STATE_Running (1UL) /*!< HFCLK clock running. */
N
N/* Bit 0 : Active clock source for the HF clock. */
N#define CLOCK_HFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_Msk (0x1UL << CLOCK_HFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_HFCLKSTAT_SRC_RC (0UL) /*!< Internal 16MHz RC oscillator running and generating the HFCLK clock. */
N#define CLOCK_HFCLKSTAT_SRC_Xtal (1UL) /*!< External 16MHz/32MHz crystal oscillator running and generating the HFCLK clock. */
N
N/* Register: CLOCK_LFCLKSTAT */
N/* Description: Low frequency clock status. */
N
N/* Bit 16 : State for the LF clock. */
N#define CLOCK_LFCLKSTAT_STATE_Pos (16UL) /*!< Position of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_Msk (0x1UL << CLOCK_LFCLKSTAT_STATE_Pos) /*!< Bit mask of STATE field. */
N#define CLOCK_LFCLKSTAT_STATE_NotRunning (0UL) /*!< LFCLK clock not running. */
N#define CLOCK_LFCLKSTAT_STATE_Running (1UL) /*!< LFCLK clock running. */
N
N/* Bits 1..0 : Active clock source for the LF clock. */
N#define CLOCK_LFCLKSTAT_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_Msk (0x3UL << CLOCK_LFCLKSTAT_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSTAT_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Xtal (1UL) /*!< External 32KiHz crystal oscillator running and generating the LFCLK clock. */
N#define CLOCK_LFCLKSTAT_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from the HFCLK running and generating the LFCLK clock. */
N
N/* Register: CLOCK_LFCLKSRC */
N/* Description: Clock source for the LFCLK clock. */
N
N/* Bits 1..0 : Clock source. */
N#define CLOCK_LFCLKSRC_SRC_Pos (0UL) /*!< Position of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_Msk (0x3UL << CLOCK_LFCLKSRC_SRC_Pos) /*!< Bit mask of SRC field. */
N#define CLOCK_LFCLKSRC_SRC_RC (0UL) /*!< Internal 32KiHz RC oscillator. */
N#define CLOCK_LFCLKSRC_SRC_Xtal (1UL) /*!< External 32KiHz crystal. */
N#define CLOCK_LFCLKSRC_SRC_Synth (2UL) /*!< Internal 32KiHz synthesizer from HFCLK system clock. */
N
N/* Register: CLOCK_CTIV */
N/* Description: Calibration timer interval. */
N
N/* Bits 6..0 : Calibration timer interval in 0.25s resolution. */
N#define CLOCK_CTIV_CTIV_Pos (0UL) /*!< Position of CTIV field. */
N#define CLOCK_CTIV_CTIV_Msk (0x7FUL << CLOCK_CTIV_CTIV_Pos) /*!< Bit mask of CTIV field. */
N
N/* Register: CLOCK_XTALFREQ */
N/* Description: Crystal frequency. */
N
N/* Bits 7..0 : External Xtal frequency selection. */
N#define CLOCK_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_Msk (0xFFUL << CLOCK_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define CLOCK_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz xtal is used. */
N#define CLOCK_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz xtal is used. */
N
N
N/* Peripheral: COMP */
N/* Description: Comparator. */
N
N/* Register: COMP_SHORTS */
N/* Description: Shortcut for the COMP. */
N
N/* Bit 4 : Short-cut between CROSS event and STOP task. */
N#define COMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Msk (0x1UL << COMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define COMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Short-cut between UP event and STOP task. */
N#define COMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Msk (0x1UL << COMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define COMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Short-cut between DOWN event and STOP task. */
N#define COMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Msk (0x1UL << COMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define COMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Short-cut between RADY event and STOP task. */
N#define COMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Msk (0x1UL << COMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define COMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between READY event and SAMPLE task. */
N#define COMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Msk (0x1UL << COMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define COMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define COMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: COMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define COMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENSET_CROSS_Msk (0x1UL << COMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define COMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENSET_UP_Msk (0x1UL << COMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define COMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENSET_DOWN_Msk (0x1UL << COMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define COMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENSET_READY_Msk (0x1UL << COMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: COMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define COMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define COMP_INTENCLR_CROSS_Msk (0x1UL << COMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define COMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define COMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define COMP_INTENCLR_UP_Msk (0x1UL << COMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define COMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define COMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define COMP_INTENCLR_DOWN_Msk (0x1UL << COMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define COMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define COMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define COMP_INTENCLR_READY_Msk (0x1UL << COMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define COMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define COMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define COMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: COMP_RESULT */
N/* Description: Compare result. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define COMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define COMP_RESULT_RESULT_Msk (0x1UL << COMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define COMP_RESULT_RESULT_Bellow (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define COMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: COMP_ENABLE */
N/* Description: Enable the COMP. */
N
N/* Bits 1..0 : Enable or disable COMP. */
N#define COMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Msk (0x3UL << COMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define COMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled COMP. */
N#define COMP_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable COMP. */
N
N/* Register: COMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define COMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define COMP_PSEL_PSEL_Msk (0x7UL << COMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define COMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define COMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: COMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define COMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Msk (0x7UL << COMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define COMP_REFSEL_REFSEL_Int1V5 (0UL) /*!< Use internal 1V5 as reference. */
N#define COMP_REFSEL_REFSEL_Int2V0 (1UL) /*!< Use internal 2V0 as reference. */
N#define COMP_REFSEL_REFSEL_Int2V5 (2UL) /*!< Use internal 2V5 as reference. */
N#define COMP_REFSEL_REFSEL_Supply (4UL) /*!< Use supply as reference. */
N#define COMP_REFSEL_REFSEL_ARef (5UL) /*!< Use external analog reference as reference. */
N
N/* Register: COMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define COMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << COMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define COMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: COMP_TH */
N/* Description: Threshold configuration for hysteresis unit. */
N
N/* Bits 13..8 : VDOWN configuration. */
N#define COMP_TH_THDOWN_Pos (8UL) /*!< Position of THDOWN field. */
N#define COMP_TH_THDOWN_Msk (0x3FUL << COMP_TH_THDOWN_Pos) /*!< Bit mask of THDOWN field. */
N
N/* Bits 5..0 : VUP configuration. */
N#define COMP_TH_THUP_Pos (0UL) /*!< Position of THUP field. */
N#define COMP_TH_THUP_Msk (0x3FUL << COMP_TH_THUP_Pos) /*!< Bit mask of THUP field. */
N
N/* Register: COMP_MODE */
N/* Description: Mode configuration. */
N
N/* Bit 8 : Main operation mode. */
N#define COMP_MODE_MAIN_Pos (8UL) /*!< Position of MAIN field. */
N#define COMP_MODE_MAIN_Msk (0x1UL << COMP_MODE_MAIN_Pos) /*!< Bit mask of MAIN field. */
N#define COMP_MODE_MAIN_Single (0UL) /*!< Single ended mode. */
N#define COMP_MODE_MAIN_Diff (1UL) /*!< Differential mode. */
N
N/* Bits 1..0 : Speed and power mode. */
N#define COMP_MODE_SP_Pos (0UL) /*!< Position of SP field. */
N#define COMP_MODE_SP_Msk (0x3UL << COMP_MODE_SP_Pos) /*!< Bit mask of SP field. */
N#define COMP_MODE_SP_Low (0UL) /*!< Low power mode. */
N#define COMP_MODE_SP_Normal (1UL) /*!< Normal mode. */
N#define COMP_MODE_SP_High (2UL) /*!< High speed mode. */
N
N/* Register: COMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define COMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define COMP_POWER_POWER_Msk (0x1UL << COMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define COMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define COMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: ECB */
N/* Description: AES ECB Mode Encryption. */
N
N/* Register: ECB_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 1 : Enable interrupt on ERRORECB event. */
N#define ECB_INTENSET_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Msk (0x1UL << ECB_INTENSET_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENSET_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ERRORECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on ENDECB event. */
N#define ECB_INTENSET_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Msk (0x1UL << ECB_INTENSET_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENSET_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENSET_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENSET_ENDECB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: ECB_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 1 : Disable interrupt on ERRORECB event. */
N#define ECB_INTENCLR_ERRORECB_Pos (1UL) /*!< Position of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Msk (0x1UL << ECB_INTENCLR_ERRORECB_Pos) /*!< Bit mask of ERRORECB field. */
N#define ECB_INTENCLR_ERRORECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ERRORECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ERRORECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on ENDECB event. */
N#define ECB_INTENCLR_ENDECB_Pos (0UL) /*!< Position of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Msk (0x1UL << ECB_INTENCLR_ENDECB_Pos) /*!< Bit mask of ENDECB field. */
N#define ECB_INTENCLR_ENDECB_Disabled (0UL) /*!< Interrupt disabled. */
N#define ECB_INTENCLR_ENDECB_Enabled (1UL) /*!< Interrupt enabled. */
N#define ECB_INTENCLR_ENDECB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: ECB_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define ECB_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define ECB_POWER_POWER_Msk (0x1UL << ECB_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define ECB_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define ECB_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: FICR */
N/* Description: Factory Information Configuration. */
N
N/* Register: FICR_PPFC */
N/* Description: Pre-programmed factory code present. */
N
N/* Bits 7..0 : Pre-programmed factory code present. */
N#define FICR_PPFC_PPFC_Pos (0UL) /*!< Position of PPFC field. */
N#define FICR_PPFC_PPFC_Msk (0xFFUL << FICR_PPFC_PPFC_Pos) /*!< Bit mask of PPFC field. */
N#define FICR_PPFC_PPFC_NotPresent (0xFFUL) /*!< Not present. */
N#define FICR_PPFC_PPFC_Present (0x00UL) /*!< Present. */
N
N/* Register: FICR_CONFIGID */
N/* Description: Configuration identifier. */
N
N/* Bits 31..16 : Firmware Identification Number pre-loaded into the flash. */
N#define FICR_CONFIGID_FWID_Pos (16UL) /*!< Position of FWID field. */
N#define FICR_CONFIGID_FWID_Msk (0xFFFFUL << FICR_CONFIGID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N/* Bits 15..0 : Hardware Identification Number. */
N#define FICR_CONFIGID_HWID_Pos (0UL) /*!< Position of HWID field. */
N#define FICR_CONFIGID_HWID_Msk (0xFFFFUL << FICR_CONFIGID_HWID_Pos) /*!< Bit mask of HWID field. */
N
N/* Register: FICR_DEVICEADDRTYPE */
N/* Description: Device address type. */
N
N/* Bit 0 : Device address type. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos (0UL) /*!< Position of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Msk (0x1UL << FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Pos) /*!< Bit mask of DEVICEADDRTYPE field. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Public (0UL) /*!< Public address. */
N#define FICR_DEVICEADDRTYPE_DEVICEADDRTYPE_Random (1UL) /*!< Random address. */
N
N/* Register: FICR_OVERRIDEEN */
N/* Description: Radio calibration override enable. */
N
N/* Bit 3 : Override default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Pos (3UL) /*!< Position of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Msk (0x1UL << FICR_OVERRIDEEN_BLE_1MBIT_Pos) /*!< Bit mask of BLE_1MBIT field. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_Override (0UL) /*!< Override the default values for BLE_1Mbit mode. */
N#define FICR_OVERRIDEEN_BLE_1MBIT_NotOverride (1UL) /*!< Do not override the default values for BLE_1Mbit mode. */
N
N
N/* Peripheral: GPIO */
N/* Description: General purpose input and output. */
N
N/* Register: GPIO_OUT */
N/* Description: Write GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUT_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUT_PIN31_Msk (0x1UL << GPIO_OUT_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUT_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN31_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUT_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUT_PIN30_Msk (0x1UL << GPIO_OUT_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUT_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN30_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUT_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUT_PIN29_Msk (0x1UL << GPIO_OUT_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUT_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN29_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUT_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUT_PIN28_Msk (0x1UL << GPIO_OUT_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUT_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN28_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUT_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUT_PIN27_Msk (0x1UL << GPIO_OUT_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUT_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN27_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUT_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUT_PIN26_Msk (0x1UL << GPIO_OUT_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUT_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN26_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUT_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUT_PIN25_Msk (0x1UL << GPIO_OUT_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUT_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN25_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUT_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUT_PIN24_Msk (0x1UL << GPIO_OUT_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUT_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN24_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUT_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUT_PIN23_Msk (0x1UL << GPIO_OUT_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUT_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN23_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUT_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUT_PIN22_Msk (0x1UL << GPIO_OUT_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUT_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN22_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUT_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUT_PIN21_Msk (0x1UL << GPIO_OUT_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUT_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN21_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUT_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUT_PIN20_Msk (0x1UL << GPIO_OUT_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUT_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN20_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUT_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUT_PIN19_Msk (0x1UL << GPIO_OUT_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUT_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN19_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUT_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUT_PIN18_Msk (0x1UL << GPIO_OUT_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUT_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN18_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUT_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUT_PIN17_Msk (0x1UL << GPIO_OUT_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUT_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN17_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUT_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUT_PIN16_Msk (0x1UL << GPIO_OUT_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUT_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN16_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUT_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUT_PIN15_Msk (0x1UL << GPIO_OUT_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUT_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN15_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUT_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUT_PIN14_Msk (0x1UL << GPIO_OUT_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUT_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN14_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUT_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUT_PIN13_Msk (0x1UL << GPIO_OUT_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUT_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN13_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUT_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUT_PIN12_Msk (0x1UL << GPIO_OUT_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUT_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN12_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUT_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUT_PIN11_Msk (0x1UL << GPIO_OUT_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUT_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN11_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUT_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUT_PIN10_Msk (0x1UL << GPIO_OUT_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUT_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN10_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUT_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUT_PIN9_Msk (0x1UL << GPIO_OUT_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUT_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN9_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUT_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUT_PIN8_Msk (0x1UL << GPIO_OUT_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUT_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN8_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUT_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUT_PIN7_Msk (0x1UL << GPIO_OUT_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUT_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN7_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUT_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUT_PIN6_Msk (0x1UL << GPIO_OUT_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUT_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN6_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUT_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUT_PIN5_Msk (0x1UL << GPIO_OUT_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUT_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN5_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUT_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUT_PIN4_Msk (0x1UL << GPIO_OUT_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUT_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN4_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUT_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUT_PIN3_Msk (0x1UL << GPIO_OUT_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUT_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN3_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUT_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUT_PIN2_Msk (0x1UL << GPIO_OUT_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUT_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN2_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUT_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUT_PIN1_Msk (0x1UL << GPIO_OUT_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUT_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN1_High (1UL) /*!< Pin driver is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUT_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUT_PIN0_Msk (0x1UL << GPIO_OUT_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUT_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUT_PIN0_High (1UL) /*!< Pin driver is high. */
N
N/* Register: GPIO_OUTSET */
N/* Description: Set individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Msk (0x1UL << GPIO_OUTSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTSET_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN31_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Msk (0x1UL << GPIO_OUTSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTSET_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN30_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Msk (0x1UL << GPIO_OUTSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTSET_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN29_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Msk (0x1UL << GPIO_OUTSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTSET_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN28_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Msk (0x1UL << GPIO_OUTSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTSET_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN27_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Msk (0x1UL << GPIO_OUTSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTSET_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN26_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Msk (0x1UL << GPIO_OUTSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTSET_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN25_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Msk (0x1UL << GPIO_OUTSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTSET_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN24_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Msk (0x1UL << GPIO_OUTSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTSET_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN23_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Msk (0x1UL << GPIO_OUTSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTSET_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN22_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Msk (0x1UL << GPIO_OUTSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTSET_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN21_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Msk (0x1UL << GPIO_OUTSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTSET_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN20_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Msk (0x1UL << GPIO_OUTSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTSET_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN19_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Msk (0x1UL << GPIO_OUTSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTSET_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN18_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Msk (0x1UL << GPIO_OUTSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTSET_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN17_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Msk (0x1UL << GPIO_OUTSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTSET_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN16_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Msk (0x1UL << GPIO_OUTSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTSET_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN15_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Msk (0x1UL << GPIO_OUTSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTSET_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN14_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Msk (0x1UL << GPIO_OUTSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTSET_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN13_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Msk (0x1UL << GPIO_OUTSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTSET_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN12_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Msk (0x1UL << GPIO_OUTSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTSET_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN11_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Msk (0x1UL << GPIO_OUTSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTSET_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN10_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Msk (0x1UL << GPIO_OUTSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTSET_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN9_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Msk (0x1UL << GPIO_OUTSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTSET_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN8_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Msk (0x1UL << GPIO_OUTSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTSET_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN7_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Msk (0x1UL << GPIO_OUTSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTSET_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN6_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Msk (0x1UL << GPIO_OUTSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTSET_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN5_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Msk (0x1UL << GPIO_OUTSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTSET_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN4_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Msk (0x1UL << GPIO_OUTSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTSET_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN3_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Msk (0x1UL << GPIO_OUTSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTSET_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN2_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Msk (0x1UL << GPIO_OUTSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTSET_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN1_Set (1UL) /*!< Set pin driver high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Msk (0x1UL << GPIO_OUTSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTSET_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTSET_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTSET_PIN0_Set (1UL) /*!< Set pin driver high. */
N
N/* Register: GPIO_OUTCLR */
N/* Description: Clear individual bits in GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_OUTCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Msk (0x1UL << GPIO_OUTCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_OUTCLR_PIN31_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN31_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN31_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_OUTCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Msk (0x1UL << GPIO_OUTCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_OUTCLR_PIN30_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN30_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN30_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_OUTCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Msk (0x1UL << GPIO_OUTCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_OUTCLR_PIN29_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN29_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN29_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_OUTCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Msk (0x1UL << GPIO_OUTCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_OUTCLR_PIN28_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN28_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN28_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_OUTCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Msk (0x1UL << GPIO_OUTCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_OUTCLR_PIN27_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN27_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN27_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_OUTCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Msk (0x1UL << GPIO_OUTCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_OUTCLR_PIN26_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN26_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN26_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_OUTCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Msk (0x1UL << GPIO_OUTCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_OUTCLR_PIN25_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN25_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN25_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_OUTCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Msk (0x1UL << GPIO_OUTCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_OUTCLR_PIN24_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN24_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN24_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_OUTCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Msk (0x1UL << GPIO_OUTCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_OUTCLR_PIN23_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN23_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN23_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_OUTCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Msk (0x1UL << GPIO_OUTCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_OUTCLR_PIN22_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN22_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN22_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_OUTCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Msk (0x1UL << GPIO_OUTCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_OUTCLR_PIN21_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN21_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN21_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_OUTCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Msk (0x1UL << GPIO_OUTCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_OUTCLR_PIN20_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN20_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN20_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_OUTCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Msk (0x1UL << GPIO_OUTCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_OUTCLR_PIN19_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN19_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN19_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_OUTCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Msk (0x1UL << GPIO_OUTCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_OUTCLR_PIN18_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN18_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN18_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_OUTCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Msk (0x1UL << GPIO_OUTCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_OUTCLR_PIN17_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN17_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN17_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_OUTCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Msk (0x1UL << GPIO_OUTCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_OUTCLR_PIN16_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN16_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN16_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_OUTCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Msk (0x1UL << GPIO_OUTCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_OUTCLR_PIN15_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN15_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN15_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_OUTCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Msk (0x1UL << GPIO_OUTCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_OUTCLR_PIN14_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN14_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN14_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_OUTCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Msk (0x1UL << GPIO_OUTCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_OUTCLR_PIN13_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN13_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN13_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_OUTCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Msk (0x1UL << GPIO_OUTCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_OUTCLR_PIN12_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN12_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN12_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_OUTCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Msk (0x1UL << GPIO_OUTCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_OUTCLR_PIN11_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN11_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN11_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_OUTCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Msk (0x1UL << GPIO_OUTCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_OUTCLR_PIN10_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN10_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN10_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_OUTCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Msk (0x1UL << GPIO_OUTCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_OUTCLR_PIN9_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN9_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN9_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_OUTCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Msk (0x1UL << GPIO_OUTCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_OUTCLR_PIN8_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN8_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN8_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_OUTCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Msk (0x1UL << GPIO_OUTCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_OUTCLR_PIN7_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN7_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN7_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_OUTCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Msk (0x1UL << GPIO_OUTCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_OUTCLR_PIN6_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN6_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN6_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_OUTCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Msk (0x1UL << GPIO_OUTCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_OUTCLR_PIN5_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN5_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN5_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_OUTCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Msk (0x1UL << GPIO_OUTCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_OUTCLR_PIN4_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN4_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN4_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_OUTCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Msk (0x1UL << GPIO_OUTCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_OUTCLR_PIN3_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN3_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN3_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_OUTCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Msk (0x1UL << GPIO_OUTCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_OUTCLR_PIN2_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN2_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN2_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_OUTCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Msk (0x1UL << GPIO_OUTCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_OUTCLR_PIN1_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN1_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN1_Clear (1UL) /*!< Set pin driver low. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_OUTCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Msk (0x1UL << GPIO_OUTCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_OUTCLR_PIN0_Low (0UL) /*!< Pin driver is low. */
N#define GPIO_OUTCLR_PIN0_High (1UL) /*!< Pin driver is high. */
N#define GPIO_OUTCLR_PIN0_Clear (1UL) /*!< Set pin driver low. */
N
N/* Register: GPIO_IN */
N/* Description: Read GPIO port. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_IN_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_IN_PIN31_Msk (0x1UL << GPIO_IN_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_IN_PIN31_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN31_High (1UL) /*!< Pin input is high. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_IN_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_IN_PIN30_Msk (0x1UL << GPIO_IN_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_IN_PIN30_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN30_High (1UL) /*!< Pin input is high. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_IN_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_IN_PIN29_Msk (0x1UL << GPIO_IN_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_IN_PIN29_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN29_High (1UL) /*!< Pin input is high. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_IN_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_IN_PIN28_Msk (0x1UL << GPIO_IN_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_IN_PIN28_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN28_High (1UL) /*!< Pin input is high. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_IN_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_IN_PIN27_Msk (0x1UL << GPIO_IN_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_IN_PIN27_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN27_High (1UL) /*!< Pin input is high. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_IN_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_IN_PIN26_Msk (0x1UL << GPIO_IN_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_IN_PIN26_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN26_High (1UL) /*!< Pin input is high. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_IN_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_IN_PIN25_Msk (0x1UL << GPIO_IN_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_IN_PIN25_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN25_High (1UL) /*!< Pin input is high. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_IN_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_IN_PIN24_Msk (0x1UL << GPIO_IN_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_IN_PIN24_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN24_High (1UL) /*!< Pin input is high. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_IN_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_IN_PIN23_Msk (0x1UL << GPIO_IN_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_IN_PIN23_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN23_High (1UL) /*!< Pin input is high. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_IN_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_IN_PIN22_Msk (0x1UL << GPIO_IN_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_IN_PIN22_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN22_High (1UL) /*!< Pin input is high. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_IN_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_IN_PIN21_Msk (0x1UL << GPIO_IN_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_IN_PIN21_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN21_High (1UL) /*!< Pin input is high. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_IN_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_IN_PIN20_Msk (0x1UL << GPIO_IN_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_IN_PIN20_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN20_High (1UL) /*!< Pin input is high. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_IN_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_IN_PIN19_Msk (0x1UL << GPIO_IN_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_IN_PIN19_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN19_High (1UL) /*!< Pin input is high. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_IN_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_IN_PIN18_Msk (0x1UL << GPIO_IN_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_IN_PIN18_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN18_High (1UL) /*!< Pin input is high. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_IN_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_IN_PIN17_Msk (0x1UL << GPIO_IN_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_IN_PIN17_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN17_High (1UL) /*!< Pin input is high. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_IN_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_IN_PIN16_Msk (0x1UL << GPIO_IN_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_IN_PIN16_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN16_High (1UL) /*!< Pin input is high. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_IN_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_IN_PIN15_Msk (0x1UL << GPIO_IN_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_IN_PIN15_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN15_High (1UL) /*!< Pin input is high. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_IN_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_IN_PIN14_Msk (0x1UL << GPIO_IN_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_IN_PIN14_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN14_High (1UL) /*!< Pin input is high. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_IN_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_IN_PIN13_Msk (0x1UL << GPIO_IN_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_IN_PIN13_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN13_High (1UL) /*!< Pin input is high. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_IN_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_IN_PIN12_Msk (0x1UL << GPIO_IN_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_IN_PIN12_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN12_High (1UL) /*!< Pin input is high. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_IN_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_IN_PIN11_Msk (0x1UL << GPIO_IN_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_IN_PIN11_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN11_High (1UL) /*!< Pin input is high. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_IN_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_IN_PIN10_Msk (0x1UL << GPIO_IN_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_IN_PIN10_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN10_High (1UL) /*!< Pin input is high. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_IN_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_IN_PIN9_Msk (0x1UL << GPIO_IN_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_IN_PIN9_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN9_High (1UL) /*!< Pin input is high. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_IN_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_IN_PIN8_Msk (0x1UL << GPIO_IN_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_IN_PIN8_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN8_High (1UL) /*!< Pin input is high. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_IN_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_IN_PIN7_Msk (0x1UL << GPIO_IN_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_IN_PIN7_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN7_High (1UL) /*!< Pin input is high. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_IN_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_IN_PIN6_Msk (0x1UL << GPIO_IN_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_IN_PIN6_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN6_High (1UL) /*!< Pin input is high. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_IN_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_IN_PIN5_Msk (0x1UL << GPIO_IN_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_IN_PIN5_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN5_High (1UL) /*!< Pin input is high. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_IN_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_IN_PIN4_Msk (0x1UL << GPIO_IN_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_IN_PIN4_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN4_High (1UL) /*!< Pin input is high. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_IN_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_IN_PIN3_Msk (0x1UL << GPIO_IN_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_IN_PIN3_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN3_High (1UL) /*!< Pin input is high. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_IN_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_IN_PIN2_Msk (0x1UL << GPIO_IN_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_IN_PIN2_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN2_High (1UL) /*!< Pin input is high. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_IN_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_IN_PIN1_Msk (0x1UL << GPIO_IN_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_IN_PIN1_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN1_High (1UL) /*!< Pin input is high. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_IN_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_IN_PIN0_Msk (0x1UL << GPIO_IN_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_IN_PIN0_Low (0UL) /*!< Pin input is low. */
N#define GPIO_IN_PIN0_High (1UL) /*!< Pin input is high. */
N
N/* Register: GPIO_DIR */
N/* Description: Direction of GPIO pins. */
N
N/* Bit 31 : Pin 31. */
N#define GPIO_DIR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIR_PIN31_Msk (0x1UL << GPIO_DIR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN31_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 30 : Pin 30. */
N#define GPIO_DIR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIR_PIN30_Msk (0x1UL << GPIO_DIR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN30_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 29 : Pin 29. */
N#define GPIO_DIR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIR_PIN29_Msk (0x1UL << GPIO_DIR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN29_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 28 : Pin 28. */
N#define GPIO_DIR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIR_PIN28_Msk (0x1UL << GPIO_DIR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN28_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 27 : Pin 27. */
N#define GPIO_DIR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIR_PIN27_Msk (0x1UL << GPIO_DIR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN27_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 26 : Pin 26. */
N#define GPIO_DIR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIR_PIN26_Msk (0x1UL << GPIO_DIR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN26_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 25 : Pin 25. */
N#define GPIO_DIR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIR_PIN25_Msk (0x1UL << GPIO_DIR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN25_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 24 : Pin 24. */
N#define GPIO_DIR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIR_PIN24_Msk (0x1UL << GPIO_DIR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN24_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 23 : Pin 23. */
N#define GPIO_DIR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIR_PIN23_Msk (0x1UL << GPIO_DIR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN23_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 22 : Pin 22. */
N#define GPIO_DIR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIR_PIN22_Msk (0x1UL << GPIO_DIR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN22_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 21 : Pin 21. */
N#define GPIO_DIR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIR_PIN21_Msk (0x1UL << GPIO_DIR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN21_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 20 : Pin 20. */
N#define GPIO_DIR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIR_PIN20_Msk (0x1UL << GPIO_DIR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN20_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 19 : Pin 19. */
N#define GPIO_DIR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIR_PIN19_Msk (0x1UL << GPIO_DIR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN19_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 18 : Pin 18. */
N#define GPIO_DIR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIR_PIN18_Msk (0x1UL << GPIO_DIR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN18_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 17 : Pin 17. */
N#define GPIO_DIR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIR_PIN17_Msk (0x1UL << GPIO_DIR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN17_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 16 : Pin 16. */
N#define GPIO_DIR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIR_PIN16_Msk (0x1UL << GPIO_DIR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN16_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 15 : Pin 15. */
N#define GPIO_DIR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIR_PIN15_Msk (0x1UL << GPIO_DIR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN15_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 14 : Pin 14. */
N#define GPIO_DIR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIR_PIN14_Msk (0x1UL << GPIO_DIR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN14_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 13 : Pin 13. */
N#define GPIO_DIR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIR_PIN13_Msk (0x1UL << GPIO_DIR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN13_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 12 : Pin 12. */
N#define GPIO_DIR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIR_PIN12_Msk (0x1UL << GPIO_DIR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN12_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 11 : Pin 11. */
N#define GPIO_DIR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIR_PIN11_Msk (0x1UL << GPIO_DIR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN11_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 10 : Pin 10. */
N#define GPIO_DIR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIR_PIN10_Msk (0x1UL << GPIO_DIR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN10_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 9 : Pin 9. */
N#define GPIO_DIR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIR_PIN9_Msk (0x1UL << GPIO_DIR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN9_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 8 : Pin 8. */
N#define GPIO_DIR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIR_PIN8_Msk (0x1UL << GPIO_DIR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN8_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 7 : Pin 7. */
N#define GPIO_DIR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIR_PIN7_Msk (0x1UL << GPIO_DIR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN7_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 6 : Pin 6. */
N#define GPIO_DIR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIR_PIN6_Msk (0x1UL << GPIO_DIR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN6_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 5 : Pin 5. */
N#define GPIO_DIR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIR_PIN5_Msk (0x1UL << GPIO_DIR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN5_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 4 : Pin 4. */
N#define GPIO_DIR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIR_PIN4_Msk (0x1UL << GPIO_DIR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN4_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 3 : Pin 3. */
N#define GPIO_DIR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIR_PIN3_Msk (0x1UL << GPIO_DIR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN3_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 2 : Pin 2. */
N#define GPIO_DIR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIR_PIN2_Msk (0x1UL << GPIO_DIR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN2_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 1 : Pin 1. */
N#define GPIO_DIR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIR_PIN1_Msk (0x1UL << GPIO_DIR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN1_Output (1UL) /*!< Pin set as output. */
N
N/* Bit 0 : Pin 0. */
N#define GPIO_DIR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIR_PIN0_Msk (0x1UL << GPIO_DIR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIR_PIN0_Output (1UL) /*!< Pin set as output. */
N
N/* Register: GPIO_DIRSET */
N/* Description: DIR set register. */
N
N/* Bit 31 : Set as output pin 31. */
N#define GPIO_DIRSET_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Msk (0x1UL << GPIO_DIRSET_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRSET_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN31_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 30 : Set as output pin 30. */
N#define GPIO_DIRSET_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Msk (0x1UL << GPIO_DIRSET_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRSET_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN30_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 29 : Set as output pin 29. */
N#define GPIO_DIRSET_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Msk (0x1UL << GPIO_DIRSET_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRSET_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN29_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 28 : Set as output pin 28. */
N#define GPIO_DIRSET_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Msk (0x1UL << GPIO_DIRSET_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRSET_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN28_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 27 : Set as output pin 27. */
N#define GPIO_DIRSET_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Msk (0x1UL << GPIO_DIRSET_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRSET_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN27_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 26 : Set as output pin 26. */
N#define GPIO_DIRSET_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Msk (0x1UL << GPIO_DIRSET_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRSET_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN26_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 25 : Set as output pin 25. */
N#define GPIO_DIRSET_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Msk (0x1UL << GPIO_DIRSET_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRSET_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN25_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 24 : Set as output pin 24. */
N#define GPIO_DIRSET_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Msk (0x1UL << GPIO_DIRSET_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRSET_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN24_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 23 : Set as output pin 23. */
N#define GPIO_DIRSET_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Msk (0x1UL << GPIO_DIRSET_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRSET_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN23_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 22 : Set as output pin 22. */
N#define GPIO_DIRSET_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Msk (0x1UL << GPIO_DIRSET_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRSET_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN22_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 21 : Set as output pin 21. */
N#define GPIO_DIRSET_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Msk (0x1UL << GPIO_DIRSET_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRSET_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN21_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 20 : Set as output pin 20. */
N#define GPIO_DIRSET_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Msk (0x1UL << GPIO_DIRSET_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRSET_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN20_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 19 : Set as output pin 19. */
N#define GPIO_DIRSET_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Msk (0x1UL << GPIO_DIRSET_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRSET_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN19_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 18 : Set as output pin 18. */
N#define GPIO_DIRSET_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Msk (0x1UL << GPIO_DIRSET_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRSET_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN18_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 17 : Set as output pin 17. */
N#define GPIO_DIRSET_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Msk (0x1UL << GPIO_DIRSET_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRSET_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN17_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 16 : Set as output pin 16. */
N#define GPIO_DIRSET_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Msk (0x1UL << GPIO_DIRSET_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRSET_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN16_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 15 : Set as output pin 15. */
N#define GPIO_DIRSET_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Msk (0x1UL << GPIO_DIRSET_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRSET_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN15_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 14 : Set as output pin 14. */
N#define GPIO_DIRSET_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Msk (0x1UL << GPIO_DIRSET_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRSET_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN14_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 13 : Set as output pin 13. */
N#define GPIO_DIRSET_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Msk (0x1UL << GPIO_DIRSET_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRSET_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN13_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 12 : Set as output pin 12. */
N#define GPIO_DIRSET_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Msk (0x1UL << GPIO_DIRSET_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRSET_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN12_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 11 : Set as output pin 11. */
N#define GPIO_DIRSET_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Msk (0x1UL << GPIO_DIRSET_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRSET_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN11_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 10 : Set as output pin 10. */
N#define GPIO_DIRSET_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Msk (0x1UL << GPIO_DIRSET_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRSET_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN10_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 9 : Set as output pin 9. */
N#define GPIO_DIRSET_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Msk (0x1UL << GPIO_DIRSET_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRSET_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN9_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 8 : Set as output pin 8. */
N#define GPIO_DIRSET_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Msk (0x1UL << GPIO_DIRSET_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRSET_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN8_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 7 : Set as output pin 7. */
N#define GPIO_DIRSET_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Msk (0x1UL << GPIO_DIRSET_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRSET_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN7_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 6 : Set as output pin 6. */
N#define GPIO_DIRSET_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Msk (0x1UL << GPIO_DIRSET_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRSET_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN6_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 5 : Set as output pin 5. */
N#define GPIO_DIRSET_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Msk (0x1UL << GPIO_DIRSET_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRSET_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN5_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 4 : Set as output pin 4. */
N#define GPIO_DIRSET_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Msk (0x1UL << GPIO_DIRSET_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRSET_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN4_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 3 : Set as output pin 3. */
N#define GPIO_DIRSET_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Msk (0x1UL << GPIO_DIRSET_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRSET_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN3_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 2 : Set as output pin 2. */
N#define GPIO_DIRSET_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Msk (0x1UL << GPIO_DIRSET_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRSET_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN2_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 1 : Set as output pin 1. */
N#define GPIO_DIRSET_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Msk (0x1UL << GPIO_DIRSET_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRSET_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN1_Set (1UL) /*!< Set pin as output. */
N
N/* Bit 0 : Set as output pin 0. */
N#define GPIO_DIRSET_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Msk (0x1UL << GPIO_DIRSET_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRSET_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRSET_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRSET_PIN0_Set (1UL) /*!< Set pin as output. */
N
N/* Register: GPIO_DIRCLR */
N/* Description: DIR clear register. */
N
N/* Bit 31 : Set as input pin 31. */
N#define GPIO_DIRCLR_PIN31_Pos (31UL) /*!< Position of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Msk (0x1UL << GPIO_DIRCLR_PIN31_Pos) /*!< Bit mask of PIN31 field. */
N#define GPIO_DIRCLR_PIN31_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN31_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN31_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 30 : Set as input pin 30. */
N#define GPIO_DIRCLR_PIN30_Pos (30UL) /*!< Position of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Msk (0x1UL << GPIO_DIRCLR_PIN30_Pos) /*!< Bit mask of PIN30 field. */
N#define GPIO_DIRCLR_PIN30_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN30_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN30_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 29 : Set as input pin 29. */
N#define GPIO_DIRCLR_PIN29_Pos (29UL) /*!< Position of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Msk (0x1UL << GPIO_DIRCLR_PIN29_Pos) /*!< Bit mask of PIN29 field. */
N#define GPIO_DIRCLR_PIN29_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN29_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN29_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 28 : Set as input pin 28. */
N#define GPIO_DIRCLR_PIN28_Pos (28UL) /*!< Position of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Msk (0x1UL << GPIO_DIRCLR_PIN28_Pos) /*!< Bit mask of PIN28 field. */
N#define GPIO_DIRCLR_PIN28_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN28_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN28_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 27 : Set as input pin 27. */
N#define GPIO_DIRCLR_PIN27_Pos (27UL) /*!< Position of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Msk (0x1UL << GPIO_DIRCLR_PIN27_Pos) /*!< Bit mask of PIN27 field. */
N#define GPIO_DIRCLR_PIN27_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN27_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN27_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 26 : Set as input pin 26. */
N#define GPIO_DIRCLR_PIN26_Pos (26UL) /*!< Position of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Msk (0x1UL << GPIO_DIRCLR_PIN26_Pos) /*!< Bit mask of PIN26 field. */
N#define GPIO_DIRCLR_PIN26_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN26_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN26_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 25 : Set as input pin 25. */
N#define GPIO_DIRCLR_PIN25_Pos (25UL) /*!< Position of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Msk (0x1UL << GPIO_DIRCLR_PIN25_Pos) /*!< Bit mask of PIN25 field. */
N#define GPIO_DIRCLR_PIN25_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN25_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN25_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 24 : Set as input pin 24. */
N#define GPIO_DIRCLR_PIN24_Pos (24UL) /*!< Position of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Msk (0x1UL << GPIO_DIRCLR_PIN24_Pos) /*!< Bit mask of PIN24 field. */
N#define GPIO_DIRCLR_PIN24_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN24_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN24_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 23 : Set as input pin 23. */
N#define GPIO_DIRCLR_PIN23_Pos (23UL) /*!< Position of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Msk (0x1UL << GPIO_DIRCLR_PIN23_Pos) /*!< Bit mask of PIN23 field. */
N#define GPIO_DIRCLR_PIN23_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN23_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN23_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 22 : Set as input pin 22. */
N#define GPIO_DIRCLR_PIN22_Pos (22UL) /*!< Position of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Msk (0x1UL << GPIO_DIRCLR_PIN22_Pos) /*!< Bit mask of PIN22 field. */
N#define GPIO_DIRCLR_PIN22_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN22_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN22_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 21 : Set as input pin 21. */
N#define GPIO_DIRCLR_PIN21_Pos (21UL) /*!< Position of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Msk (0x1UL << GPIO_DIRCLR_PIN21_Pos) /*!< Bit mask of PIN21 field. */
N#define GPIO_DIRCLR_PIN21_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN21_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN21_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 20 : Set as input pin 20. */
N#define GPIO_DIRCLR_PIN20_Pos (20UL) /*!< Position of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Msk (0x1UL << GPIO_DIRCLR_PIN20_Pos) /*!< Bit mask of PIN20 field. */
N#define GPIO_DIRCLR_PIN20_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN20_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN20_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 19 : Set as input pin 19. */
N#define GPIO_DIRCLR_PIN19_Pos (19UL) /*!< Position of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Msk (0x1UL << GPIO_DIRCLR_PIN19_Pos) /*!< Bit mask of PIN19 field. */
N#define GPIO_DIRCLR_PIN19_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN19_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN19_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 18 : Set as input pin 18. */
N#define GPIO_DIRCLR_PIN18_Pos (18UL) /*!< Position of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Msk (0x1UL << GPIO_DIRCLR_PIN18_Pos) /*!< Bit mask of PIN18 field. */
N#define GPIO_DIRCLR_PIN18_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN18_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN18_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 17 : Set as input pin 17. */
N#define GPIO_DIRCLR_PIN17_Pos (17UL) /*!< Position of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Msk (0x1UL << GPIO_DIRCLR_PIN17_Pos) /*!< Bit mask of PIN17 field. */
N#define GPIO_DIRCLR_PIN17_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN17_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN17_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 16 : Set as input pin 16. */
N#define GPIO_DIRCLR_PIN16_Pos (16UL) /*!< Position of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Msk (0x1UL << GPIO_DIRCLR_PIN16_Pos) /*!< Bit mask of PIN16 field. */
N#define GPIO_DIRCLR_PIN16_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN16_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN16_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 15 : Set as input pin 15. */
N#define GPIO_DIRCLR_PIN15_Pos (15UL) /*!< Position of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Msk (0x1UL << GPIO_DIRCLR_PIN15_Pos) /*!< Bit mask of PIN15 field. */
N#define GPIO_DIRCLR_PIN15_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN15_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN15_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 14 : Set as input pin 14. */
N#define GPIO_DIRCLR_PIN14_Pos (14UL) /*!< Position of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Msk (0x1UL << GPIO_DIRCLR_PIN14_Pos) /*!< Bit mask of PIN14 field. */
N#define GPIO_DIRCLR_PIN14_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN14_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN14_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 13 : Set as input pin 13. */
N#define GPIO_DIRCLR_PIN13_Pos (13UL) /*!< Position of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Msk (0x1UL << GPIO_DIRCLR_PIN13_Pos) /*!< Bit mask of PIN13 field. */
N#define GPIO_DIRCLR_PIN13_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN13_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN13_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 12 : Set as input pin 12. */
N#define GPIO_DIRCLR_PIN12_Pos (12UL) /*!< Position of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Msk (0x1UL << GPIO_DIRCLR_PIN12_Pos) /*!< Bit mask of PIN12 field. */
N#define GPIO_DIRCLR_PIN12_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN12_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN12_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 11 : Set as input pin 11. */
N#define GPIO_DIRCLR_PIN11_Pos (11UL) /*!< Position of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Msk (0x1UL << GPIO_DIRCLR_PIN11_Pos) /*!< Bit mask of PIN11 field. */
N#define GPIO_DIRCLR_PIN11_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN11_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN11_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 10 : Set as input pin 10. */
N#define GPIO_DIRCLR_PIN10_Pos (10UL) /*!< Position of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Msk (0x1UL << GPIO_DIRCLR_PIN10_Pos) /*!< Bit mask of PIN10 field. */
N#define GPIO_DIRCLR_PIN10_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN10_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN10_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 9 : Set as input pin 9. */
N#define GPIO_DIRCLR_PIN9_Pos (9UL) /*!< Position of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Msk (0x1UL << GPIO_DIRCLR_PIN9_Pos) /*!< Bit mask of PIN9 field. */
N#define GPIO_DIRCLR_PIN9_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN9_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN9_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 8 : Set as input pin 8. */
N#define GPIO_DIRCLR_PIN8_Pos (8UL) /*!< Position of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Msk (0x1UL << GPIO_DIRCLR_PIN8_Pos) /*!< Bit mask of PIN8 field. */
N#define GPIO_DIRCLR_PIN8_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN8_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN8_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 7 : Set as input pin 7. */
N#define GPIO_DIRCLR_PIN7_Pos (7UL) /*!< Position of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Msk (0x1UL << GPIO_DIRCLR_PIN7_Pos) /*!< Bit mask of PIN7 field. */
N#define GPIO_DIRCLR_PIN7_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN7_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN7_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 6 : Set as input pin 6. */
N#define GPIO_DIRCLR_PIN6_Pos (6UL) /*!< Position of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Msk (0x1UL << GPIO_DIRCLR_PIN6_Pos) /*!< Bit mask of PIN6 field. */
N#define GPIO_DIRCLR_PIN6_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN6_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN6_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 5 : Set as input pin 5. */
N#define GPIO_DIRCLR_PIN5_Pos (5UL) /*!< Position of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Msk (0x1UL << GPIO_DIRCLR_PIN5_Pos) /*!< Bit mask of PIN5 field. */
N#define GPIO_DIRCLR_PIN5_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN5_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN5_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 4 : Set as input pin 4. */
N#define GPIO_DIRCLR_PIN4_Pos (4UL) /*!< Position of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Msk (0x1UL << GPIO_DIRCLR_PIN4_Pos) /*!< Bit mask of PIN4 field. */
N#define GPIO_DIRCLR_PIN4_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN4_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN4_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 3 : Set as input pin 3. */
N#define GPIO_DIRCLR_PIN3_Pos (3UL) /*!< Position of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Msk (0x1UL << GPIO_DIRCLR_PIN3_Pos) /*!< Bit mask of PIN3 field. */
N#define GPIO_DIRCLR_PIN3_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN3_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN3_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 2 : Set as input pin 2. */
N#define GPIO_DIRCLR_PIN2_Pos (2UL) /*!< Position of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Msk (0x1UL << GPIO_DIRCLR_PIN2_Pos) /*!< Bit mask of PIN2 field. */
N#define GPIO_DIRCLR_PIN2_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN2_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN2_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 1 : Set as input pin 1. */
N#define GPIO_DIRCLR_PIN1_Pos (1UL) /*!< Position of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Msk (0x1UL << GPIO_DIRCLR_PIN1_Pos) /*!< Bit mask of PIN1 field. */
N#define GPIO_DIRCLR_PIN1_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN1_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN1_Clear (1UL) /*!< Set pin as input. */
N
N/* Bit 0 : Set as input pin 0. */
N#define GPIO_DIRCLR_PIN0_Pos (0UL) /*!< Position of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Msk (0x1UL << GPIO_DIRCLR_PIN0_Pos) /*!< Bit mask of PIN0 field. */
N#define GPIO_DIRCLR_PIN0_Input (0UL) /*!< Pin set as input. */
N#define GPIO_DIRCLR_PIN0_Output (1UL) /*!< Pin set as output. */
N#define GPIO_DIRCLR_PIN0_Clear (1UL) /*!< Set pin as input. */
N
N/* Register: GPIO_PIN_CNF */
N/* Description: Configuration of GPIO pins. */
N
N/* Bits 17..16 : Pin sensing mechanism. */
N#define GPIO_PIN_CNF_SENSE_Pos (16UL) /*!< Position of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Msk (0x3UL << GPIO_PIN_CNF_SENSE_Pos) /*!< Bit mask of SENSE field. */
N#define GPIO_PIN_CNF_SENSE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIO_PIN_CNF_SENSE_High (0x02UL) /*!< Wakeup on high level. */
N#define GPIO_PIN_CNF_SENSE_Low (0x03UL) /*!< Wakeup on low level. */
N
N/* Bits 10..8 : Drive configuration. */
N#define GPIO_PIN_CNF_DRIVE_Pos (8UL) /*!< Position of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_Msk (0x7UL << GPIO_PIN_CNF_DRIVE_Pos) /*!< Bit mask of DRIVE field. */
N#define GPIO_PIN_CNF_DRIVE_S0S1 (0x00UL) /*!< Standard '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0S1 (0x01UL) /*!< High '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0H1 (0x02UL) /*!< Standard '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0H1 (0x03UL) /*!< High '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0S1 (0x04UL) /*!< Disconnected '0', Standard '1'. */
N#define GPIO_PIN_CNF_DRIVE_D0H1 (0x05UL) /*!< Disconnected '0', High '1'. */
N#define GPIO_PIN_CNF_DRIVE_S0D1 (0x06UL) /*!< Standard '0', Disconnected '1'. */
N#define GPIO_PIN_CNF_DRIVE_H0D1 (0x07UL) /*!< High '0', Disconnected '1'. */
N
N/* Bits 3..2 : Pull-up or -down configuration. */
N#define GPIO_PIN_CNF_PULL_Pos (2UL) /*!< Position of PULL field. */
N#define GPIO_PIN_CNF_PULL_Msk (0x3UL << GPIO_PIN_CNF_PULL_Pos) /*!< Bit mask of PULL field. */
N#define GPIO_PIN_CNF_PULL_Disabled (0x00UL) /*!< No pull. */
N#define GPIO_PIN_CNF_PULL_Pulldown (0x01UL) /*!< Pulldown on pin. */
N#define GPIO_PIN_CNF_PULL_Pullup (0x03UL) /*!< Pullup on pin. */
N
N/* Bit 1 : Connect or disconnect input path. */
N#define GPIO_PIN_CNF_INPUT_Pos (1UL) /*!< Position of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Msk (0x1UL << GPIO_PIN_CNF_INPUT_Pos) /*!< Bit mask of INPUT field. */
N#define GPIO_PIN_CNF_INPUT_Connect (0UL) /*!< Connect input pin. */
N#define GPIO_PIN_CNF_INPUT_Disconnect (1UL) /*!< Disconnect input pin. */
N
N/* Bit 0 : Pin direction. */
N#define GPIO_PIN_CNF_DIR_Pos (0UL) /*!< Position of DIR field. */
N#define GPIO_PIN_CNF_DIR_Msk (0x1UL << GPIO_PIN_CNF_DIR_Pos) /*!< Bit mask of DIR field. */
N#define GPIO_PIN_CNF_DIR_Input (0UL) /*!< Configure pin as an input pin. */
N#define GPIO_PIN_CNF_DIR_Output (1UL) /*!< Configure pin as an output pin. */
N
N
N/* Peripheral: GPIOTE */
N/* Description: GPIO tasks and events. */
N
N/* Register: GPIOTE_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 31 : Enable interrupt on PORT event. */
N#define GPIOTE_INTENSET_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENSET_PORT_Msk (0x1UL << GPIOTE_INTENSET_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENSET_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_PORT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on IN[3] event. */
N#define GPIOTE_INTENSET_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Msk (0x1UL << GPIOTE_INTENSET_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENSET_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on IN[2] event. */
N#define GPIOTE_INTENSET_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Msk (0x1UL << GPIOTE_INTENSET_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENSET_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on IN[1] event. */
N#define GPIOTE_INTENSET_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Msk (0x1UL << GPIOTE_INTENSET_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENSET_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on IN[0] event. */
N#define GPIOTE_INTENSET_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Msk (0x1UL << GPIOTE_INTENSET_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENSET_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENSET_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENSET_IN0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: GPIOTE_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 31 : Disable interrupt on PORT event. */
N#define GPIOTE_INTENCLR_PORT_Pos (31UL) /*!< Position of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Msk (0x1UL << GPIOTE_INTENCLR_PORT_Pos) /*!< Bit mask of PORT field. */
N#define GPIOTE_INTENCLR_PORT_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_PORT_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_PORT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on IN[3] event. */
N#define GPIOTE_INTENCLR_IN3_Pos (3UL) /*!< Position of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Msk (0x1UL << GPIOTE_INTENCLR_IN3_Pos) /*!< Bit mask of IN3 field. */
N#define GPIOTE_INTENCLR_IN3_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN3_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on IN[2] event. */
N#define GPIOTE_INTENCLR_IN2_Pos (2UL) /*!< Position of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Msk (0x1UL << GPIOTE_INTENCLR_IN2_Pos) /*!< Bit mask of IN2 field. */
N#define GPIOTE_INTENCLR_IN2_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN2_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on IN[1] event. */
N#define GPIOTE_INTENCLR_IN1_Pos (1UL) /*!< Position of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Msk (0x1UL << GPIOTE_INTENCLR_IN1_Pos) /*!< Bit mask of IN1 field. */
N#define GPIOTE_INTENCLR_IN1_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN1_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on IN[0] event. */
N#define GPIOTE_INTENCLR_IN0_Pos (0UL) /*!< Position of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Msk (0x1UL << GPIOTE_INTENCLR_IN0_Pos) /*!< Bit mask of IN0 field. */
N#define GPIOTE_INTENCLR_IN0_Disabled (0UL) /*!< Interrupt disabled. */
N#define GPIOTE_INTENCLR_IN0_Enabled (1UL) /*!< Interrupt enabled. */
N#define GPIOTE_INTENCLR_IN0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: GPIOTE_CONFIG */
N/* Description: Channel configuration registers. */
N
N/* Bit 20 : Initial value of the output when the GPIOTE channel is configured as a Task. */
N#define GPIOTE_CONFIG_OUTINIT_Pos (20UL) /*!< Position of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Msk (0x1UL << GPIOTE_CONFIG_OUTINIT_Pos) /*!< Bit mask of OUTINIT field. */
N#define GPIOTE_CONFIG_OUTINIT_Low (0UL) /*!< Initial low output when in task mode. */
N#define GPIOTE_CONFIG_OUTINIT_High (1UL) /*!< Initial high output when in task mode. */
N
N/* Bits 17..16 : Effects on output when in Task mode, or events on input that generates an event. */
N#define GPIOTE_CONFIG_POLARITY_Pos (16UL) /*!< Position of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_Msk (0x3UL << GPIOTE_CONFIG_POLARITY_Pos) /*!< Bit mask of POLARITY field. */
N#define GPIOTE_CONFIG_POLARITY_LoToHi (0x01UL) /*!< Low to high. */
N#define GPIOTE_CONFIG_POLARITY_HiToLo (0x02UL) /*!< High to low. */
N#define GPIOTE_CONFIG_POLARITY_Toggle (0x03UL) /*!< Toggle. */
N
N/* Bits 12..8 : Pin select. */
N#define GPIOTE_CONFIG_PSEL_Pos (8UL) /*!< Position of PSEL field. */
N#define GPIOTE_CONFIG_PSEL_Msk (0x1FUL << GPIOTE_CONFIG_PSEL_Pos) /*!< Bit mask of PSEL field. */
N
N/* Bits 1..0 : Mode */
N#define GPIOTE_CONFIG_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define GPIOTE_CONFIG_MODE_Msk (0x3UL << GPIOTE_CONFIG_MODE_Pos) /*!< Bit mask of MODE field. */
N#define GPIOTE_CONFIG_MODE_Disabled (0x00UL) /*!< Disabled. */
N#define GPIOTE_CONFIG_MODE_Event (0x01UL) /*!< Channel configure in event mode. */
N#define GPIOTE_CONFIG_MODE_Task (0x03UL) /*!< Channel configure in task mode. */
N
N/* Register: GPIOTE_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define GPIOTE_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define GPIOTE_POWER_POWER_Msk (0x1UL << GPIOTE_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define GPIOTE_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define GPIOTE_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: LPCOMP */
N/* Description: Wakeup Comparator. */
N
N/* Register: LPCOMP_SHORTS */
N/* Description: Shortcut for the LPCOMP. */
N
N/* Bit 4 : Short-cut between CROSS event and STOP task. */
N#define LPCOMP_SHORTS_CROSS_STOP_Pos (4UL) /*!< Position of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Msk (0x1UL << LPCOMP_SHORTS_CROSS_STOP_Pos) /*!< Bit mask of CROSS_STOP field. */
N#define LPCOMP_SHORTS_CROSS_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_CROSS_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Short-cut between UP event and STOP task. */
N#define LPCOMP_SHORTS_UP_STOP_Pos (3UL) /*!< Position of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Msk (0x1UL << LPCOMP_SHORTS_UP_STOP_Pos) /*!< Bit mask of UP_STOP field. */
N#define LPCOMP_SHORTS_UP_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_UP_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Short-cut between DOWN event and STOP task. */
N#define LPCOMP_SHORTS_DOWN_STOP_Pos (2UL) /*!< Position of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Msk (0x1UL << LPCOMP_SHORTS_DOWN_STOP_Pos) /*!< Bit mask of DOWN_STOP field. */
N#define LPCOMP_SHORTS_DOWN_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_DOWN_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Short-cut between RADY event and STOP task. */
N#define LPCOMP_SHORTS_READY_STOP_Pos (1UL) /*!< Position of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Msk (0x1UL << LPCOMP_SHORTS_READY_STOP_Pos) /*!< Bit mask of READY_STOP field. */
N#define LPCOMP_SHORTS_READY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between READY event and SAMPLE task. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Pos (0UL) /*!< Position of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Msk (0x1UL << LPCOMP_SHORTS_READY_SAMPLE_Pos) /*!< Bit mask of READY_SAMPLE field. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define LPCOMP_SHORTS_READY_SAMPLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: LPCOMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 3 : Enable interrupt on CROSS event. */
N#define LPCOMP_INTENSET_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Msk (0x1UL << LPCOMP_INTENSET_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENSET_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_CROSS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on UP event. */
N#define LPCOMP_INTENSET_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENSET_UP_Msk (0x1UL << LPCOMP_INTENSET_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENSET_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_UP_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on DOWN event. */
N#define LPCOMP_INTENSET_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Msk (0x1UL << LPCOMP_INTENSET_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENSET_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_DOWN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define LPCOMP_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENSET_READY_Msk (0x1UL << LPCOMP_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: LPCOMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 3 : Disable interrupt on CROSS event. */
N#define LPCOMP_INTENCLR_CROSS_Pos (3UL) /*!< Position of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Msk (0x1UL << LPCOMP_INTENCLR_CROSS_Pos) /*!< Bit mask of CROSS field. */
N#define LPCOMP_INTENCLR_CROSS_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_CROSS_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_CROSS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on UP event. */
N#define LPCOMP_INTENCLR_UP_Pos (2UL) /*!< Position of UP field. */
N#define LPCOMP_INTENCLR_UP_Msk (0x1UL << LPCOMP_INTENCLR_UP_Pos) /*!< Bit mask of UP field. */
N#define LPCOMP_INTENCLR_UP_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_UP_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_UP_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on DOWN event. */
N#define LPCOMP_INTENCLR_DOWN_Pos (1UL) /*!< Position of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Msk (0x1UL << LPCOMP_INTENCLR_DOWN_Pos) /*!< Bit mask of DOWN field. */
N#define LPCOMP_INTENCLR_DOWN_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_DOWN_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_DOWN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define LPCOMP_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define LPCOMP_INTENCLR_READY_Msk (0x1UL << LPCOMP_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define LPCOMP_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define LPCOMP_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define LPCOMP_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: LPCOMP_RESULT */
N/* Description: Result of last compare. */
N
N/* Bit 0 : Result of last compare. Decision point SAMPLE task. */
N#define LPCOMP_RESULT_RESULT_Pos (0UL) /*!< Position of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Msk (0x1UL << LPCOMP_RESULT_RESULT_Pos) /*!< Bit mask of RESULT field. */
N#define LPCOMP_RESULT_RESULT_Bellow (0UL) /*!< Input voltage is bellow the reference threshold. */
N#define LPCOMP_RESULT_RESULT_Above (1UL) /*!< Input voltage is above the reference threshold. */
N
N/* Register: LPCOMP_ENABLE */
N/* Description: Enable the LPCOMP. */
N
N/* Bits 1..0 : Enable or disable LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Msk (0x3UL << LPCOMP_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define LPCOMP_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled LPCOMP. */
N#define LPCOMP_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable LPCOMP. */
N
N/* Register: LPCOMP_PSEL */
N/* Description: Input pin select. */
N
N/* Bits 2..0 : Analog input pin select. */
N#define LPCOMP_PSEL_PSEL_Pos (0UL) /*!< Position of PSEL field. */
N#define LPCOMP_PSEL_PSEL_Msk (0x7UL << LPCOMP_PSEL_PSEL_Pos) /*!< Bit mask of PSEL field. */
N#define LPCOMP_PSEL_PSEL_AnalogInput0 (0UL) /*!< Use analog input 0 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput1 (1UL) /*!< Use analog input 1 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput2 (2UL) /*!< Use analog input 2 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput3 (3UL) /*!< Use analog input 3 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput4 (4UL) /*!< Use analog input 4 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput5 (5UL) /*!< Use analog input 5 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput6 (6UL) /*!< Use analog input 6 as analog input. */
N#define LPCOMP_PSEL_PSEL_AnalogInput7 (7UL) /*!< Use analog input 7 as analog input. */
N
N/* Register: LPCOMP_REFSEL */
N/* Description: Reference select. */
N
N/* Bits 2..0 : Reference select. */
N#define LPCOMP_REFSEL_REFSEL_Pos (0UL) /*!< Position of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_Msk (0x7UL << LPCOMP_REFSEL_REFSEL_Pos) /*!< Bit mask of REFSEL field. */
N#define LPCOMP_REFSEL_REFSEL_SupplyOneEighthPrescaling (0UL) /*!< Use analog supply with a 1/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyTwoEighthsPrescaling (1UL) /*!< Use analog supply with a 2/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyThreeEighthsPrescaling (2UL) /*!< Use analog supply with a 3/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFourEighthsPrescaling (3UL) /*!< Use analog supply with a 4/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplyFiveEighthsPrescaling (4UL) /*!< Use analog supply with a 5/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySixEighthsPrescaling (5UL) /*!< Use analog supply with a 6/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_SupplySevenEighthsPrescaling (6UL) /*!< Use analog supply with a 7/8 prescaler as reference. */
N#define LPCOMP_REFSEL_REFSEL_ARef (7UL) /*!< Use external analog reference as reference. */
N
N/* Register: LPCOMP_EXTREFSEL */
N/* Description: External reference select. */
N
N/* Bit 0 : External analog reference pin selection. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Pos (0UL) /*!< Position of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_Msk (0x1UL << LPCOMP_EXTREFSEL_EXTREFSEL_Pos) /*!< Bit mask of EXTREFSEL field. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference0 (0UL) /*!< Use analog reference 0 as reference. */
N#define LPCOMP_EXTREFSEL_EXTREFSEL_AnalogReference1 (1UL) /*!< Use analog reference 1 as reference. */
N
N/* Register: LPCOMP_ANADETECT */
N/* Description: Analog detect configuration. */
N
N/* Bits 1..0 : Analog detect configuration. */
N#define LPCOMP_ANADETECT_ANADETECT_Pos (0UL) /*!< Position of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Msk (0x3UL << LPCOMP_ANADETECT_ANADETECT_Pos) /*!< Bit mask of ANADETECT field. */
N#define LPCOMP_ANADETECT_ANADETECT_Cross (0UL) /*!< Generate ANADETEC on crossing, both upwards and downwards crossing. */
N#define LPCOMP_ANADETECT_ANADETECT_Up (1UL) /*!< Generate ANADETEC on upwards crossing only. */
N#define LPCOMP_ANADETECT_ANADETECT_Down (2UL) /*!< Generate ANADETEC on downwards crossing only. */
N
N/* Register: LPCOMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define LPCOMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define LPCOMP_POWER_POWER_Msk (0x1UL << LPCOMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define LPCOMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define LPCOMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: MPU */
N/* Description: Memory Protection Unit. */
N
N/* Register: MPU_PERR0 */
N/* Description: Configuration of peripherals in mpu regions. */
N
N/* Bit 31 : PPI region configuration. */
N#define MPU_PERR0_PPI_Pos (31UL) /*!< Position of PPI field. */
N#define MPU_PERR0_PPI_Msk (0x1UL << MPU_PERR0_PPI_Pos) /*!< Bit mask of PPI field. */
N#define MPU_PERR0_PPI_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_PPI_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 30 : NVMC region configuration. */
N#define MPU_PERR0_NVMC_Pos (30UL) /*!< Position of NVMC field. */
N#define MPU_PERR0_NVMC_Msk (0x1UL << MPU_PERR0_NVMC_Pos) /*!< Bit mask of NVMC field. */
N#define MPU_PERR0_NVMC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_NVMC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 19 : LPCOMP_COMP region configuration. */
N#define MPU_PERR0_LPCOMP_COMP_Pos (19UL) /*!< Position of LPCOMP_COMP field. */
N#define MPU_PERR0_LPCOMP_COMP_Msk (0x1UL << MPU_PERR0_LPCOMP_COMP_Pos) /*!< Bit mask of LPCOMP_COMP field. */
N#define MPU_PERR0_LPCOMP_COMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_LPCOMP_COMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 18 : QDEC region configuration. */
N#define MPU_PERR0_QDEC_Pos (18UL) /*!< Position of QDEC field. */
N#define MPU_PERR0_QDEC_Msk (0x1UL << MPU_PERR0_QDEC_Pos) /*!< Bit mask of QDEC field. */
N#define MPU_PERR0_QDEC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_QDEC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 17 : RTC1 region configuration. */
N#define MPU_PERR0_RTC1_Pos (17UL) /*!< Position of RTC1 field. */
N#define MPU_PERR0_RTC1_Msk (0x1UL << MPU_PERR0_RTC1_Pos) /*!< Bit mask of RTC1 field. */
N#define MPU_PERR0_RTC1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 16 : WDT region configuration. */
N#define MPU_PERR0_WDT_Pos (16UL) /*!< Position of WDT field. */
N#define MPU_PERR0_WDT_Msk (0x1UL << MPU_PERR0_WDT_Pos) /*!< Bit mask of WDT field. */
N#define MPU_PERR0_WDT_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_WDT_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 15 : CCM and AAR region configuration. */
N#define MPU_PERR0_CCM_AAR_Pos (15UL) /*!< Position of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_Msk (0x1UL << MPU_PERR0_CCM_AAR_Pos) /*!< Bit mask of CCM_AAR field. */
N#define MPU_PERR0_CCM_AAR_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_CCM_AAR_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 14 : ECB region configuration. */
N#define MPU_PERR0_ECB_Pos (14UL) /*!< Position of ECB field. */
N#define MPU_PERR0_ECB_Msk (0x1UL << MPU_PERR0_ECB_Pos) /*!< Bit mask of ECB field. */
N#define MPU_PERR0_ECB_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ECB_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 13 : RNG region configuration. */
N#define MPU_PERR0_RNG_Pos (13UL) /*!< Position of RNG field. */
N#define MPU_PERR0_RNG_Msk (0x1UL << MPU_PERR0_RNG_Pos) /*!< Bit mask of RNG field. */
N#define MPU_PERR0_RNG_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RNG_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 12 : TEMP region configuration. */
N#define MPU_PERR0_TEMP_Pos (12UL) /*!< Position of TEMP field. */
N#define MPU_PERR0_TEMP_Msk (0x1UL << MPU_PERR0_TEMP_Pos) /*!< Bit mask of TEMP field. */
N#define MPU_PERR0_TEMP_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TEMP_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 11 : RTC0 region configuration. */
N#define MPU_PERR0_RTC0_Pos (11UL) /*!< Position of RTC0 field. */
N#define MPU_PERR0_RTC0_Msk (0x1UL << MPU_PERR0_RTC0_Pos) /*!< Bit mask of RTC0 field. */
N#define MPU_PERR0_RTC0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RTC0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 10 : TIMER2 region configuration. */
N#define MPU_PERR0_TIMER2_Pos (10UL) /*!< Position of TIMER2 field. */
N#define MPU_PERR0_TIMER2_Msk (0x1UL << MPU_PERR0_TIMER2_Pos) /*!< Bit mask of TIMER2 field. */
N#define MPU_PERR0_TIMER2_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER2_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 9 : TIMER1 region configuration. */
N#define MPU_PERR0_TIMER1_Pos (9UL) /*!< Position of TIMER1 field. */
N#define MPU_PERR0_TIMER1_Msk (0x1UL << MPU_PERR0_TIMER1_Pos) /*!< Bit mask of TIMER1 field. */
N#define MPU_PERR0_TIMER1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 8 : TIMER0 region configuration. */
N#define MPU_PERR0_TIMER0_Pos (8UL) /*!< Position of TIMER0 field. */
N#define MPU_PERR0_TIMER0_Msk (0x1UL << MPU_PERR0_TIMER0_Pos) /*!< Bit mask of TIMER0 field. */
N#define MPU_PERR0_TIMER0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_TIMER0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 7 : ADC region configuration. */
N#define MPU_PERR0_ADC_Pos (7UL) /*!< Position of ADC field. */
N#define MPU_PERR0_ADC_Msk (0x1UL << MPU_PERR0_ADC_Pos) /*!< Bit mask of ADC field. */
N#define MPU_PERR0_ADC_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_ADC_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 6 : GPIOTE region configuration. */
N#define MPU_PERR0_GPIOTE_Pos (6UL) /*!< Position of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_Msk (0x1UL << MPU_PERR0_GPIOTE_Pos) /*!< Bit mask of GPIOTE field. */
N#define MPU_PERR0_GPIOTE_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_GPIOTE_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 4 : SPI1 and TWI1 region configuration. */
N#define MPU_PERR0_SPI1_TWI1_Pos (4UL) /*!< Position of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_Msk (0x1UL << MPU_PERR0_SPI1_TWI1_Pos) /*!< Bit mask of SPI1_TWI1 field. */
N#define MPU_PERR0_SPI1_TWI1_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI1_TWI1_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 3 : SPI0 and TWI0 region configuration. */
N#define MPU_PERR0_SPI0_TWI0_Pos (3UL) /*!< Position of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_Msk (0x1UL << MPU_PERR0_SPI0_TWI0_Pos) /*!< Bit mask of SPI0_TWI0 field. */
N#define MPU_PERR0_SPI0_TWI0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_SPI0_TWI0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 2 : UART0 region configuration. */
N#define MPU_PERR0_UART0_Pos (2UL) /*!< Position of UART0 field. */
N#define MPU_PERR0_UART0_Msk (0x1UL << MPU_PERR0_UART0_Pos) /*!< Bit mask of UART0 field. */
N#define MPU_PERR0_UART0_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_UART0_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 1 : RADIO region configuration. */
N#define MPU_PERR0_RADIO_Pos (1UL) /*!< Position of RADIO field. */
N#define MPU_PERR0_RADIO_Msk (0x1UL << MPU_PERR0_RADIO_Pos) /*!< Bit mask of RADIO field. */
N#define MPU_PERR0_RADIO_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_RADIO_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Bit 0 : POWER_CLOCK region configuration. */
N#define MPU_PERR0_POWER_CLOCK_Pos (0UL) /*!< Position of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_Msk (0x1UL << MPU_PERR0_POWER_CLOCK_Pos) /*!< Bit mask of POWER_CLOCK field. */
N#define MPU_PERR0_POWER_CLOCK_InRegion1 (0UL) /*!< Peripheral configured in region 1. */
N#define MPU_PERR0_POWER_CLOCK_InRegion0 (1UL) /*!< Peripheral configured in region 0. */
N
N/* Register: MPU_PROTENSET0 */
N/* Description: Protection bit enable set register for low addresses. */
N
N/* Bit 31 : Protection enable for region 31. */
N#define MPU_PROTENSET0_PROTREG31_Pos (31UL) /*!< Position of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Msk (0x1UL << MPU_PROTENSET0_PROTREG31_Pos) /*!< Bit mask of PROTREG31 field. */
N#define MPU_PROTENSET0_PROTREG31_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG31_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG31_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 30. */
N#define MPU_PROTENSET0_PROTREG30_Pos (30UL) /*!< Position of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Msk (0x1UL << MPU_PROTENSET0_PROTREG30_Pos) /*!< Bit mask of PROTREG30 field. */
N#define MPU_PROTENSET0_PROTREG30_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG30_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG30_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 29. */
N#define MPU_PROTENSET0_PROTREG29_Pos (29UL) /*!< Position of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Msk (0x1UL << MPU_PROTENSET0_PROTREG29_Pos) /*!< Bit mask of PROTREG29 field. */
N#define MPU_PROTENSET0_PROTREG29_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG29_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG29_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 28. */
N#define MPU_PROTENSET0_PROTREG28_Pos (28UL) /*!< Position of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Msk (0x1UL << MPU_PROTENSET0_PROTREG28_Pos) /*!< Bit mask of PROTREG28 field. */
N#define MPU_PROTENSET0_PROTREG28_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG28_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG28_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 27. */
N#define MPU_PROTENSET0_PROTREG27_Pos (27UL) /*!< Position of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Msk (0x1UL << MPU_PROTENSET0_PROTREG27_Pos) /*!< Bit mask of PROTREG27 field. */
N#define MPU_PROTENSET0_PROTREG27_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG27_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG27_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 26. */
N#define MPU_PROTENSET0_PROTREG26_Pos (26UL) /*!< Position of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Msk (0x1UL << MPU_PROTENSET0_PROTREG26_Pos) /*!< Bit mask of PROTREG26 field. */
N#define MPU_PROTENSET0_PROTREG26_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG26_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG26_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 25. */
N#define MPU_PROTENSET0_PROTREG25_Pos (25UL) /*!< Position of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Msk (0x1UL << MPU_PROTENSET0_PROTREG25_Pos) /*!< Bit mask of PROTREG25 field. */
N#define MPU_PROTENSET0_PROTREG25_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG25_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG25_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 24. */
N#define MPU_PROTENSET0_PROTREG24_Pos (24UL) /*!< Position of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Msk (0x1UL << MPU_PROTENSET0_PROTREG24_Pos) /*!< Bit mask of PROTREG24 field. */
N#define MPU_PROTENSET0_PROTREG24_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG24_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG24_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 23. */
N#define MPU_PROTENSET0_PROTREG23_Pos (23UL) /*!< Position of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Msk (0x1UL << MPU_PROTENSET0_PROTREG23_Pos) /*!< Bit mask of PROTREG23 field. */
N#define MPU_PROTENSET0_PROTREG23_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG23_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG23_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 22. */
N#define MPU_PROTENSET0_PROTREG22_Pos (22UL) /*!< Position of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Msk (0x1UL << MPU_PROTENSET0_PROTREG22_Pos) /*!< Bit mask of PROTREG22 field. */
N#define MPU_PROTENSET0_PROTREG22_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG22_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG22_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 21. */
N#define MPU_PROTENSET0_PROTREG21_Pos (21UL) /*!< Position of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Msk (0x1UL << MPU_PROTENSET0_PROTREG21_Pos) /*!< Bit mask of PROTREG21 field. */
N#define MPU_PROTENSET0_PROTREG21_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG21_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG21_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 20. */
N#define MPU_PROTENSET0_PROTREG20_Pos (20UL) /*!< Position of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Msk (0x1UL << MPU_PROTENSET0_PROTREG20_Pos) /*!< Bit mask of PROTREG20 field. */
N#define MPU_PROTENSET0_PROTREG20_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG20_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG20_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 19. */
N#define MPU_PROTENSET0_PROTREG19_Pos (19UL) /*!< Position of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Msk (0x1UL << MPU_PROTENSET0_PROTREG19_Pos) /*!< Bit mask of PROTREG19 field. */
N#define MPU_PROTENSET0_PROTREG19_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG19_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG19_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 18. */
N#define MPU_PROTENSET0_PROTREG18_Pos (18UL) /*!< Position of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Msk (0x1UL << MPU_PROTENSET0_PROTREG18_Pos) /*!< Bit mask of PROTREG18 field. */
N#define MPU_PROTENSET0_PROTREG18_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG18_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG18_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 17. */
N#define MPU_PROTENSET0_PROTREG17_Pos (17UL) /*!< Position of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Msk (0x1UL << MPU_PROTENSET0_PROTREG17_Pos) /*!< Bit mask of PROTREG17 field. */
N#define MPU_PROTENSET0_PROTREG17_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG17_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG17_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 16. */
N#define MPU_PROTENSET0_PROTREG16_Pos (16UL) /*!< Position of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Msk (0x1UL << MPU_PROTENSET0_PROTREG16_Pos) /*!< Bit mask of PROTREG16 field. */
N#define MPU_PROTENSET0_PROTREG16_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG16_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG16_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 15. */
N#define MPU_PROTENSET0_PROTREG15_Pos (15UL) /*!< Position of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Msk (0x1UL << MPU_PROTENSET0_PROTREG15_Pos) /*!< Bit mask of PROTREG15 field. */
N#define MPU_PROTENSET0_PROTREG15_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG15_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG15_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 14. */
N#define MPU_PROTENSET0_PROTREG14_Pos (14UL) /*!< Position of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Msk (0x1UL << MPU_PROTENSET0_PROTREG14_Pos) /*!< Bit mask of PROTREG14 field. */
N#define MPU_PROTENSET0_PROTREG14_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG14_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG14_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 13. */
N#define MPU_PROTENSET0_PROTREG13_Pos (13UL) /*!< Position of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Msk (0x1UL << MPU_PROTENSET0_PROTREG13_Pos) /*!< Bit mask of PROTREG13 field. */
N#define MPU_PROTENSET0_PROTREG13_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG13_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG13_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 12. */
N#define MPU_PROTENSET0_PROTREG12_Pos (12UL) /*!< Position of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Msk (0x1UL << MPU_PROTENSET0_PROTREG12_Pos) /*!< Bit mask of PROTREG12 field. */
N#define MPU_PROTENSET0_PROTREG12_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG12_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG12_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 11. */
N#define MPU_PROTENSET0_PROTREG11_Pos (11UL) /*!< Position of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Msk (0x1UL << MPU_PROTENSET0_PROTREG11_Pos) /*!< Bit mask of PROTREG11 field. */
N#define MPU_PROTENSET0_PROTREG11_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG11_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG11_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 10. */
N#define MPU_PROTENSET0_PROTREG10_Pos (10UL) /*!< Position of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Msk (0x1UL << MPU_PROTENSET0_PROTREG10_Pos) /*!< Bit mask of PROTREG10 field. */
N#define MPU_PROTENSET0_PROTREG10_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG10_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG10_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 9. */
N#define MPU_PROTENSET0_PROTREG9_Pos (9UL) /*!< Position of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Msk (0x1UL << MPU_PROTENSET0_PROTREG9_Pos) /*!< Bit mask of PROTREG9 field. */
N#define MPU_PROTENSET0_PROTREG9_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG9_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG9_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 8. */
N#define MPU_PROTENSET0_PROTREG8_Pos (8UL) /*!< Position of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Msk (0x1UL << MPU_PROTENSET0_PROTREG8_Pos) /*!< Bit mask of PROTREG8 field. */
N#define MPU_PROTENSET0_PROTREG8_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG8_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG8_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 7. */
N#define MPU_PROTENSET0_PROTREG7_Pos (7UL) /*!< Position of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Msk (0x1UL << MPU_PROTENSET0_PROTREG7_Pos) /*!< Bit mask of PROTREG7 field. */
N#define MPU_PROTENSET0_PROTREG7_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG7_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG7_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 6. */
N#define MPU_PROTENSET0_PROTREG6_Pos (6UL) /*!< Position of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Msk (0x1UL << MPU_PROTENSET0_PROTREG6_Pos) /*!< Bit mask of PROTREG6 field. */
N#define MPU_PROTENSET0_PROTREG6_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG6_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG6_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 5. */
N#define MPU_PROTENSET0_PROTREG5_Pos (5UL) /*!< Position of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Msk (0x1UL << MPU_PROTENSET0_PROTREG5_Pos) /*!< Bit mask of PROTREG5 field. */
N#define MPU_PROTENSET0_PROTREG5_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG5_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG5_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 4. */
N#define MPU_PROTENSET0_PROTREG4_Pos (4UL) /*!< Position of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Msk (0x1UL << MPU_PROTENSET0_PROTREG4_Pos) /*!< Bit mask of PROTREG4 field. */
N#define MPU_PROTENSET0_PROTREG4_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG4_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG4_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 3. */
N#define MPU_PROTENSET0_PROTREG3_Pos (3UL) /*!< Position of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Msk (0x1UL << MPU_PROTENSET0_PROTREG3_Pos) /*!< Bit mask of PROTREG3 field. */
N#define MPU_PROTENSET0_PROTREG3_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG3_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG3_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 2. */
N#define MPU_PROTENSET0_PROTREG2_Pos (2UL) /*!< Position of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Msk (0x1UL << MPU_PROTENSET0_PROTREG2_Pos) /*!< Bit mask of PROTREG2 field. */
N#define MPU_PROTENSET0_PROTREG2_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG2_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG2_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 1. */
N#define MPU_PROTENSET0_PROTREG1_Pos (1UL) /*!< Position of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Msk (0x1UL << MPU_PROTENSET0_PROTREG1_Pos) /*!< Bit mask of PROTREG1 field. */
N#define MPU_PROTENSET0_PROTREG1_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG1_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG1_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 0. */
N#define MPU_PROTENSET0_PROTREG0_Pos (0UL) /*!< Position of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Msk (0x1UL << MPU_PROTENSET0_PROTREG0_Pos) /*!< Bit mask of PROTREG0 field. */
N#define MPU_PROTENSET0_PROTREG0_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET0_PROTREG0_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET0_PROTREG0_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_PROTENSET1 */
N/* Description: Protection bit enable set register for high addresses. */
N
N/* Bit 31 : Protection enable for region 63. */
N#define MPU_PROTENSET1_PROTREG63_Pos (31UL) /*!< Position of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Msk (0x1UL << MPU_PROTENSET1_PROTREG63_Pos) /*!< Bit mask of PROTREG63 field. */
N#define MPU_PROTENSET1_PROTREG63_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG63_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG63_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 30 : Protection enable for region 62. */
N#define MPU_PROTENSET1_PROTREG62_Pos (30UL) /*!< Position of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Msk (0x1UL << MPU_PROTENSET1_PROTREG62_Pos) /*!< Bit mask of PROTREG62 field. */
N#define MPU_PROTENSET1_PROTREG62_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG62_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG62_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 29 : Protection enable for region 61. */
N#define MPU_PROTENSET1_PROTREG61_Pos (29UL) /*!< Position of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Msk (0x1UL << MPU_PROTENSET1_PROTREG61_Pos) /*!< Bit mask of PROTREG61 field. */
N#define MPU_PROTENSET1_PROTREG61_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG61_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG61_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 28 : Protection enable for region 60. */
N#define MPU_PROTENSET1_PROTREG60_Pos (28UL) /*!< Position of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Msk (0x1UL << MPU_PROTENSET1_PROTREG60_Pos) /*!< Bit mask of PROTREG60 field. */
N#define MPU_PROTENSET1_PROTREG60_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG60_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG60_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 27 : Protection enable for region 59. */
N#define MPU_PROTENSET1_PROTREG59_Pos (27UL) /*!< Position of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Msk (0x1UL << MPU_PROTENSET1_PROTREG59_Pos) /*!< Bit mask of PROTREG59 field. */
N#define MPU_PROTENSET1_PROTREG59_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG59_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG59_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 26 : Protection enable for region 58. */
N#define MPU_PROTENSET1_PROTREG58_Pos (26UL) /*!< Position of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Msk (0x1UL << MPU_PROTENSET1_PROTREG58_Pos) /*!< Bit mask of PROTREG58 field. */
N#define MPU_PROTENSET1_PROTREG58_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG58_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG58_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 25 : Protection enable for region 57. */
N#define MPU_PROTENSET1_PROTREG57_Pos (25UL) /*!< Position of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Msk (0x1UL << MPU_PROTENSET1_PROTREG57_Pos) /*!< Bit mask of PROTREG57 field. */
N#define MPU_PROTENSET1_PROTREG57_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG57_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG57_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 24 : Protection enable for region 56. */
N#define MPU_PROTENSET1_PROTREG56_Pos (24UL) /*!< Position of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Msk (0x1UL << MPU_PROTENSET1_PROTREG56_Pos) /*!< Bit mask of PROTREG56 field. */
N#define MPU_PROTENSET1_PROTREG56_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG56_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG56_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 23 : Protection enable for region 55. */
N#define MPU_PROTENSET1_PROTREG55_Pos (23UL) /*!< Position of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Msk (0x1UL << MPU_PROTENSET1_PROTREG55_Pos) /*!< Bit mask of PROTREG55 field. */
N#define MPU_PROTENSET1_PROTREG55_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG55_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG55_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 22 : Protection enable for region 54. */
N#define MPU_PROTENSET1_PROTREG54_Pos (22UL) /*!< Position of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Msk (0x1UL << MPU_PROTENSET1_PROTREG54_Pos) /*!< Bit mask of PROTREG54 field. */
N#define MPU_PROTENSET1_PROTREG54_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG54_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG54_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 21 : Protection enable for region 53. */
N#define MPU_PROTENSET1_PROTREG53_Pos (21UL) /*!< Position of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Msk (0x1UL << MPU_PROTENSET1_PROTREG53_Pos) /*!< Bit mask of PROTREG53 field. */
N#define MPU_PROTENSET1_PROTREG53_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG53_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG53_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 20 : Protection enable for region 52. */
N#define MPU_PROTENSET1_PROTREG52_Pos (20UL) /*!< Position of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Msk (0x1UL << MPU_PROTENSET1_PROTREG52_Pos) /*!< Bit mask of PROTREG52 field. */
N#define MPU_PROTENSET1_PROTREG52_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG52_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG52_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 19 : Protection enable for region 51. */
N#define MPU_PROTENSET1_PROTREG51_Pos (19UL) /*!< Position of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Msk (0x1UL << MPU_PROTENSET1_PROTREG51_Pos) /*!< Bit mask of PROTREG51 field. */
N#define MPU_PROTENSET1_PROTREG51_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG51_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG51_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 18 : Protection enable for region 50. */
N#define MPU_PROTENSET1_PROTREG50_Pos (18UL) /*!< Position of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Msk (0x1UL << MPU_PROTENSET1_PROTREG50_Pos) /*!< Bit mask of PROTREG50 field. */
N#define MPU_PROTENSET1_PROTREG50_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG50_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG50_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 17 : Protection enable for region 49. */
N#define MPU_PROTENSET1_PROTREG49_Pos (17UL) /*!< Position of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Msk (0x1UL << MPU_PROTENSET1_PROTREG49_Pos) /*!< Bit mask of PROTREG49 field. */
N#define MPU_PROTENSET1_PROTREG49_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG49_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG49_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 16 : Protection enable for region 48. */
N#define MPU_PROTENSET1_PROTREG48_Pos (16UL) /*!< Position of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Msk (0x1UL << MPU_PROTENSET1_PROTREG48_Pos) /*!< Bit mask of PROTREG48 field. */
N#define MPU_PROTENSET1_PROTREG48_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG48_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG48_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 15 : Protection enable for region 47. */
N#define MPU_PROTENSET1_PROTREG47_Pos (15UL) /*!< Position of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Msk (0x1UL << MPU_PROTENSET1_PROTREG47_Pos) /*!< Bit mask of PROTREG47 field. */
N#define MPU_PROTENSET1_PROTREG47_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG47_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG47_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 14 : Protection enable for region 46. */
N#define MPU_PROTENSET1_PROTREG46_Pos (14UL) /*!< Position of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Msk (0x1UL << MPU_PROTENSET1_PROTREG46_Pos) /*!< Bit mask of PROTREG46 field. */
N#define MPU_PROTENSET1_PROTREG46_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG46_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG46_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 13 : Protection enable for region 45. */
N#define MPU_PROTENSET1_PROTREG45_Pos (13UL) /*!< Position of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Msk (0x1UL << MPU_PROTENSET1_PROTREG45_Pos) /*!< Bit mask of PROTREG45 field. */
N#define MPU_PROTENSET1_PROTREG45_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG45_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG45_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 12 : Protection enable for region 44. */
N#define MPU_PROTENSET1_PROTREG44_Pos (12UL) /*!< Position of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Msk (0x1UL << MPU_PROTENSET1_PROTREG44_Pos) /*!< Bit mask of PROTREG44 field. */
N#define MPU_PROTENSET1_PROTREG44_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG44_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG44_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 11 : Protection enable for region 43. */
N#define MPU_PROTENSET1_PROTREG43_Pos (11UL) /*!< Position of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Msk (0x1UL << MPU_PROTENSET1_PROTREG43_Pos) /*!< Bit mask of PROTREG43 field. */
N#define MPU_PROTENSET1_PROTREG43_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG43_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG43_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 10 : Protection enable for region 42. */
N#define MPU_PROTENSET1_PROTREG42_Pos (10UL) /*!< Position of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Msk (0x1UL << MPU_PROTENSET1_PROTREG42_Pos) /*!< Bit mask of PROTREG42 field. */
N#define MPU_PROTENSET1_PROTREG42_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG42_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG42_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 9 : Protection enable for region 41. */
N#define MPU_PROTENSET1_PROTREG41_Pos (9UL) /*!< Position of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Msk (0x1UL << MPU_PROTENSET1_PROTREG41_Pos) /*!< Bit mask of PROTREG41 field. */
N#define MPU_PROTENSET1_PROTREG41_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG41_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG41_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 8 : Protection enable for region 40. */
N#define MPU_PROTENSET1_PROTREG40_Pos (8UL) /*!< Position of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Msk (0x1UL << MPU_PROTENSET1_PROTREG40_Pos) /*!< Bit mask of PROTREG40 field. */
N#define MPU_PROTENSET1_PROTREG40_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG40_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG40_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 7 : Protection enable for region 39. */
N#define MPU_PROTENSET1_PROTREG39_Pos (7UL) /*!< Position of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Msk (0x1UL << MPU_PROTENSET1_PROTREG39_Pos) /*!< Bit mask of PROTREG39 field. */
N#define MPU_PROTENSET1_PROTREG39_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG39_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG39_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 6 : Protection enable for region 38. */
N#define MPU_PROTENSET1_PROTREG38_Pos (6UL) /*!< Position of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Msk (0x1UL << MPU_PROTENSET1_PROTREG38_Pos) /*!< Bit mask of PROTREG38 field. */
N#define MPU_PROTENSET1_PROTREG38_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG38_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG38_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 5 : Protection enable for region 37. */
N#define MPU_PROTENSET1_PROTREG37_Pos (5UL) /*!< Position of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Msk (0x1UL << MPU_PROTENSET1_PROTREG37_Pos) /*!< Bit mask of PROTREG37 field. */
N#define MPU_PROTENSET1_PROTREG37_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG37_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG37_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 4 : Protection enable for region 36. */
N#define MPU_PROTENSET1_PROTREG36_Pos (4UL) /*!< Position of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Msk (0x1UL << MPU_PROTENSET1_PROTREG36_Pos) /*!< Bit mask of PROTREG36 field. */
N#define MPU_PROTENSET1_PROTREG36_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG36_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG36_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 3 : Protection enable for region 35. */
N#define MPU_PROTENSET1_PROTREG35_Pos (3UL) /*!< Position of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Msk (0x1UL << MPU_PROTENSET1_PROTREG35_Pos) /*!< Bit mask of PROTREG35 field. */
N#define MPU_PROTENSET1_PROTREG35_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG35_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG35_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 2 : Protection enable for region 34. */
N#define MPU_PROTENSET1_PROTREG34_Pos (2UL) /*!< Position of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Msk (0x1UL << MPU_PROTENSET1_PROTREG34_Pos) /*!< Bit mask of PROTREG34 field. */
N#define MPU_PROTENSET1_PROTREG34_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG34_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG34_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 1 : Protection enable for region 33. */
N#define MPU_PROTENSET1_PROTREG33_Pos (1UL) /*!< Position of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Msk (0x1UL << MPU_PROTENSET1_PROTREG33_Pos) /*!< Bit mask of PROTREG33 field. */
N#define MPU_PROTENSET1_PROTREG33_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG33_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG33_Set (1UL) /*!< Enable protection on write. */
N
N/* Bit 0 : Protection enable for region 32. */
N#define MPU_PROTENSET1_PROTREG32_Pos (0UL) /*!< Position of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Msk (0x1UL << MPU_PROTENSET1_PROTREG32_Pos) /*!< Bit mask of PROTREG32 field. */
N#define MPU_PROTENSET1_PROTREG32_Disabled (0UL) /*!< Protection disabled. */
N#define MPU_PROTENSET1_PROTREG32_Enabled (1UL) /*!< Protection enabled. */
N#define MPU_PROTENSET1_PROTREG32_Set (1UL) /*!< Enable protection on write. */
N
N/* Register: MPU_DISABLEINDEBUG */
N/* Description: Disable protection mechanism in debug mode. */
N
N/* Bit 0 : Disable protection mechanism in debug mode. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos (0UL) /*!< Position of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Msk (0x1UL << MPU_DISABLEINDEBUG_DISABLEINDEBUG_Pos) /*!< Bit mask of DISABLEINDEBUG field. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Enabled (0UL) /*!< Protection enabled. */
N#define MPU_DISABLEINDEBUG_DISABLEINDEBUG_Disabled (1UL) /*!< Protection disabled. */
N
N
N/* Peripheral: NVMC */
N/* Description: Non Volatile Memory Controller. */
N
N/* Register: NVMC_READY */
N/* Description: Ready flag. */
N
N/* Bit 0 : NVMC ready. */
N#define NVMC_READY_READY_Pos (0UL) /*!< Position of READY field. */
N#define NVMC_READY_READY_Msk (0x1UL << NVMC_READY_READY_Pos) /*!< Bit mask of READY field. */
N#define NVMC_READY_READY_Busy (0UL) /*!< NVMC is busy (on-going write or erase operation). */
N#define NVMC_READY_READY_Ready (1UL) /*!< NVMC is ready. */
N
N/* Register: NVMC_CONFIG */
N/* Description: Configuration register. */
N
N/* Bits 1..0 : Program write enable. */
N#define NVMC_CONFIG_WEN_Pos (0UL) /*!< Position of WEN field. */
N#define NVMC_CONFIG_WEN_Msk (0x3UL << NVMC_CONFIG_WEN_Pos) /*!< Bit mask of WEN field. */
N#define NVMC_CONFIG_WEN_Ren (0x00UL) /*!< Read only access. */
N#define NVMC_CONFIG_WEN_Wen (0x01UL) /*!< Write enabled. */
N#define NVMC_CONFIG_WEN_Een (0x02UL) /*!< Erase enabled. */
N
N/* Register: NVMC_ERASEALL */
N/* Description: Register for erasing all non-volatile user memory. */
N
N/* Bit 0 : Starts the erasing of all user NVM (code region 0/1 and UICR registers). */
N#define NVMC_ERASEALL_ERASEALL_Pos (0UL) /*!< Position of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_Msk (0x1UL << NVMC_ERASEALL_ERASEALL_Pos) /*!< Bit mask of ERASEALL field. */
N#define NVMC_ERASEALL_ERASEALL_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEALL_ERASEALL_Erase (1UL) /*!< Start chip erase. */
N
N/* Register: NVMC_ERASEUICR */
N/* Description: Register for start erasing User Information Congfiguration Registers. */
N
N/* Bit 0 : It can only be used when all contents of code region 1 are erased. */
N#define NVMC_ERASEUICR_ERASEUICR_Pos (0UL) /*!< Position of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_Msk (0x1UL << NVMC_ERASEUICR_ERASEUICR_Pos) /*!< Bit mask of ERASEUICR field. */
N#define NVMC_ERASEUICR_ERASEUICR_NoOperation (0UL) /*!< No operation. */
N#define NVMC_ERASEUICR_ERASEUICR_Erase (1UL) /*!< Start UICR erase. */
N
N
N/* Peripheral: POWER */
N/* Description: Power Control. */
N
N/* Register: POWER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on POFWARN event. */
N#define POWER_INTENSET_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Msk (0x1UL << POWER_INTENSET_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENSET_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENSET_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENSET_POFWARN_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: POWER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on POFWARN event. */
N#define POWER_INTENCLR_POFWARN_Pos (2UL) /*!< Position of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Msk (0x1UL << POWER_INTENCLR_POFWARN_Pos) /*!< Bit mask of POFWARN field. */
N#define POWER_INTENCLR_POFWARN_Disabled (0UL) /*!< Interrupt disabled. */
N#define POWER_INTENCLR_POFWARN_Enabled (1UL) /*!< Interrupt enabled. */
N#define POWER_INTENCLR_POFWARN_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: POWER_RESETREAS */
N/* Description: Reset reason. */
N
N/* Bit 18 : Reset from wake-up from OFF mode detected by entering into debug interface mode. */
N#define POWER_RESETREAS_DIF_Pos (18UL) /*!< Position of DIF field. */
N#define POWER_RESETREAS_DIF_Msk (0x1UL << POWER_RESETREAS_DIF_Pos) /*!< Bit mask of DIF field. */
N
N/* Bit 17 : Reset from wake-up from OFF mode detected by the use of ANADETECT signal from LPCOMP. */
N#define POWER_RESETREAS_LPCOMP_Pos (17UL) /*!< Position of LPCOMP field. */
N#define POWER_RESETREAS_LPCOMP_Msk (0x1UL << POWER_RESETREAS_LPCOMP_Pos) /*!< Bit mask of LPCOMP field. */
N
N/* Bit 16 : Reset from wake-up from OFF mode detected by the use of DETECT signal from GPIO. */
N#define POWER_RESETREAS_OFF_Pos (16UL) /*!< Position of OFF field. */
N#define POWER_RESETREAS_OFF_Msk (0x1UL << POWER_RESETREAS_OFF_Pos) /*!< Bit mask of OFF field. */
N
N/* Bit 3 : Reset from CPU lock-up detected. */
N#define POWER_RESETREAS_LOCKUP_Pos (3UL) /*!< Position of LOCKUP field. */
N#define POWER_RESETREAS_LOCKUP_Msk (0x1UL << POWER_RESETREAS_LOCKUP_Pos) /*!< Bit mask of LOCKUP field. */
N
N/* Bit 2 : Reset from AIRCR.SYSRESETREQ detected. */
N#define POWER_RESETREAS_SREQ_Pos (2UL) /*!< Position of SREQ field. */
N#define POWER_RESETREAS_SREQ_Msk (0x1UL << POWER_RESETREAS_SREQ_Pos) /*!< Bit mask of SREQ field. */
N
N/* Bit 1 : Reset from watchdog detected. */
N#define POWER_RESETREAS_DOG_Pos (1UL) /*!< Position of DOG field. */
N#define POWER_RESETREAS_DOG_Msk (0x1UL << POWER_RESETREAS_DOG_Pos) /*!< Bit mask of DOG field. */
N
N/* Bit 0 : Reset from pin-reset detected. */
N#define POWER_RESETREAS_RESETPIN_Pos (0UL) /*!< Position of RESETPIN field. */
N#define POWER_RESETREAS_RESETPIN_Msk (0x1UL << POWER_RESETREAS_RESETPIN_Pos) /*!< Bit mask of RESETPIN field. */
N
N/* Register: POWER_SYSTEMOFF */
N/* Description: System off register. */
N
N/* Bit 0 : Enter system off mode. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Pos (0UL) /*!< Position of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Msk (0x1UL << POWER_SYSTEMOFF_SYSTEMOFF_Pos) /*!< Bit mask of SYSTEMOFF field. */
N#define POWER_SYSTEMOFF_SYSTEMOFF_Enter (1UL) /*!< Enter system off mode. */
N
N/* Register: POWER_POFCON */
N/* Description: Power failure configuration. */
N
N/* Bits 2..1 : Set threshold level. */
N#define POWER_POFCON_THRESHOLD_Pos (1UL) /*!< Position of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_Msk (0x3UL << POWER_POFCON_THRESHOLD_Pos) /*!< Bit mask of THRESHOLD field. */
N#define POWER_POFCON_THRESHOLD_V21 (0x00UL) /*!< Set threshold to 2.1Volts. */
N#define POWER_POFCON_THRESHOLD_V23 (0x01UL) /*!< Set threshold to 2.3Volts. */
N#define POWER_POFCON_THRESHOLD_V25 (0x02UL) /*!< Set threshold to 2.5Volts. */
N#define POWER_POFCON_THRESHOLD_V27 (0x03UL) /*!< Set threshold to 2.7Volts. */
N
N/* Bit 0 : Power failure comparator enable. */
N#define POWER_POFCON_POF_Pos (0UL) /*!< Position of POF field. */
N#define POWER_POFCON_POF_Msk (0x1UL << POWER_POFCON_POF_Pos) /*!< Bit mask of POF field. */
N#define POWER_POFCON_POF_Disabled (0UL) /*!< Disabled. */
N#define POWER_POFCON_POF_Enabled (1UL) /*!< Enabled. */
N
N/* Register: POWER_GPREGRET */
N/* Description: General purpose retention register. This register is a retained register. */
N
N/* Bits 7..0 : General purpose retention register. */
N#define POWER_GPREGRET_GPREGRET_Pos (0UL) /*!< Position of GPREGRET field. */
N#define POWER_GPREGRET_GPREGRET_Msk (0xFFUL << POWER_GPREGRET_GPREGRET_Pos) /*!< Bit mask of GPREGRET field. */
N
N/* Register: POWER_RAMON */
N/* Description: Ram on/off. */
N
N/* Bit 19 : RAM block 3 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM3_Pos (19UL) /*!< Position of OFFRAM3 field. */
N#define POWER_RAMON_OFFRAM3_Msk (0x1UL << POWER_RAMON_OFFRAM3_Pos) /*!< Bit mask of OFFRAM3 field. */
N#define POWER_RAMON_OFFRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM3_RAM3On (1UL) /*!< RAM block 3 ON in OFF mode. */
N
N/* Bit 18 : RAM block 2 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM2_Pos (18UL) /*!< Position of OFFRAM2 field. */
N#define POWER_RAMON_OFFRAM2_Msk (0x1UL << POWER_RAMON_OFFRAM2_Pos) /*!< Bit mask of OFFRAM2 field. */
N#define POWER_RAMON_OFFRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM2_RAM2On (1UL) /*!< RAM block 2 ON in OFF mode. */
N
N/* Bit 17 : RAM block 1 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM1_Pos (17UL) /*!< Position of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_Msk (0x1UL << POWER_RAMON_OFFRAM1_Pos) /*!< Bit mask of OFFRAM1 field. */
N#define POWER_RAMON_OFFRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM1_RAM1On (1UL) /*!< RAM block 1 ON in OFF mode. */
N
N/* Bit 16 : RAM block 0 behaviour in OFF mode. */
N#define POWER_RAMON_OFFRAM0_Pos (16UL) /*!< Position of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_Msk (0x1UL << POWER_RAMON_OFFRAM0_Pos) /*!< Bit mask of OFFRAM0 field. */
N#define POWER_RAMON_OFFRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in OFF mode. */
N#define POWER_RAMON_OFFRAM0_RAM0On (1UL) /*!< RAM block 0 ON in OFF mode. */
N
N/* Bit 3 : RAM block 3 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM3_Pos (3UL) /*!< Position of ONRAM3 field. */
N#define POWER_RAMON_ONRAM3_Msk (0x1UL << POWER_RAMON_ONRAM3_Pos) /*!< Bit mask of ONRAM3 field. */
N#define POWER_RAMON_ONRAM3_RAM3Off (0UL) /*!< RAM block 3 OFF in ON mode. */
N#define POWER_RAMON_ONRAM3_RAM3On (1UL) /*!< RAM block 3 ON in ON mode. */
N
N/* Bit 2 : RAM block 2 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM2_Pos (2UL) /*!< Position of ONRAM2 field. */
N#define POWER_RAMON_ONRAM2_Msk (0x1UL << POWER_RAMON_ONRAM2_Pos) /*!< Bit mask of ONRAM2 field. */
N#define POWER_RAMON_ONRAM2_RAM2Off (0UL) /*!< RAM block 2 OFF in ON mode. */
N#define POWER_RAMON_ONRAM2_RAM2On (1UL) /*!< RAM block 2 ON in ON mode. */
N
N/* Bit 1 : RAM block 1 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM1_Pos (1UL) /*!< Position of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_Msk (0x1UL << POWER_RAMON_ONRAM1_Pos) /*!< Bit mask of ONRAM1 field. */
N#define POWER_RAMON_ONRAM1_RAM1Off (0UL) /*!< RAM block 1 OFF in ON mode. */
N#define POWER_RAMON_ONRAM1_RAM1On (1UL) /*!< RAM block 1 ON in ON mode. */
N
N/* Bit 0 : RAM block 0 behaviour in ON mode. */
N#define POWER_RAMON_ONRAM0_Pos (0UL) /*!< Position of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_Msk (0x1UL << POWER_RAMON_ONRAM0_Pos) /*!< Bit mask of ONRAM0 field. */
N#define POWER_RAMON_ONRAM0_RAM0Off (0UL) /*!< RAM block 0 OFF in ON mode. */
N#define POWER_RAMON_ONRAM0_RAM0On (1UL) /*!< RAM block 0 ON in ON mode. */
N
N/* Register: POWER_RESET */
N/* Description: Pin reset functionality configuration register. This register is a retained register. */
N
N/* Bit 0 : Enable pin reset in debug interface mode. */
N#define POWER_RESET_RESET_Pos (0UL) /*!< Position of RESET field. */
N#define POWER_RESET_RESET_Msk (0x1UL << POWER_RESET_RESET_Pos) /*!< Bit mask of RESET field. */
N#define POWER_RESET_RESET_Disabled (0UL) /*!< Pin reset in debug interface mode disabled. */
N#define POWER_RESET_RESET_Enabled (1UL) /*!< Pin reset in debug interface mode enabled. */
N
N/* Register: POWER_DCDCEN */
N/* Description: DCDC converter enable configuration register. */
N
N/* Bit 0 : Enable DCDC converter. */
N#define POWER_DCDCEN_DCDCEN_Pos (0UL) /*!< Position of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Msk (0x1UL << POWER_DCDCEN_DCDCEN_Pos) /*!< Bit mask of DCDCEN field. */
N#define POWER_DCDCEN_DCDCEN_Disabled (0UL) /*!< DCDC converter disabled. */
N#define POWER_DCDCEN_DCDCEN_Enabled (1UL) /*!< DCDC converter enabled. */
N
N
N/* Peripheral: PPI */
N/* Description: PPI controller. */
N
N/* Register: PPI_CHEN */
N/* Description: Channel enable. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHEN_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHEN_CH31_Msk (0x1UL << PPI_CHEN_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHEN_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH31_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHEN_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHEN_CH30_Msk (0x1UL << PPI_CHEN_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHEN_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH30_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHEN_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHEN_CH29_Msk (0x1UL << PPI_CHEN_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHEN_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH29_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHEN_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHEN_CH28_Msk (0x1UL << PPI_CHEN_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHEN_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH28_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHEN_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHEN_CH27_Msk (0x1UL << PPI_CHEN_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHEN_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH27_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHEN_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHEN_CH26_Msk (0x1UL << PPI_CHEN_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHEN_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH26_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHEN_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHEN_CH25_Msk (0x1UL << PPI_CHEN_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHEN_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH25_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHEN_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHEN_CH24_Msk (0x1UL << PPI_CHEN_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHEN_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH24_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHEN_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHEN_CH23_Msk (0x1UL << PPI_CHEN_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHEN_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH23_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHEN_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHEN_CH22_Msk (0x1UL << PPI_CHEN_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHEN_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH22_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHEN_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHEN_CH21_Msk (0x1UL << PPI_CHEN_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHEN_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH21_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHEN_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHEN_CH20_Msk (0x1UL << PPI_CHEN_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHEN_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH20_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHEN_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHEN_CH15_Msk (0x1UL << PPI_CHEN_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHEN_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH15_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHEN_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHEN_CH14_Msk (0x1UL << PPI_CHEN_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHEN_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH14_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHEN_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHEN_CH13_Msk (0x1UL << PPI_CHEN_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHEN_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH13_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHEN_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHEN_CH12_Msk (0x1UL << PPI_CHEN_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHEN_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH12_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHEN_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHEN_CH11_Msk (0x1UL << PPI_CHEN_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHEN_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH11_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHEN_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHEN_CH10_Msk (0x1UL << PPI_CHEN_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHEN_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH10_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHEN_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHEN_CH9_Msk (0x1UL << PPI_CHEN_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHEN_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH9_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHEN_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHEN_CH8_Msk (0x1UL << PPI_CHEN_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHEN_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH8_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHEN_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHEN_CH7_Msk (0x1UL << PPI_CHEN_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHEN_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH7_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHEN_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHEN_CH6_Msk (0x1UL << PPI_CHEN_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHEN_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH6_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHEN_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHEN_CH5_Msk (0x1UL << PPI_CHEN_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHEN_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH5_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHEN_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHEN_CH4_Msk (0x1UL << PPI_CHEN_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHEN_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH4_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHEN_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHEN_CH3_Msk (0x1UL << PPI_CHEN_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHEN_CH3_Disabled (0UL) /*!< Channel disabled */
N#define PPI_CHEN_CH3_Enabled (1UL) /*!< Channel enabled */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHEN_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHEN_CH2_Msk (0x1UL << PPI_CHEN_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHEN_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH2_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHEN_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHEN_CH1_Msk (0x1UL << PPI_CHEN_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHEN_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH1_Enabled (1UL) /*!< Channel enabled. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHEN_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHEN_CH0_Msk (0x1UL << PPI_CHEN_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHEN_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHEN_CH0_Enabled (1UL) /*!< Channel enabled. */
N
N/* Register: PPI_CHENSET */
N/* Description: Channel enable set. */
N
N/* Bit 31 : Enable PPI channel 31. */
N#define PPI_CHENSET_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENSET_CH31_Msk (0x1UL << PPI_CHENSET_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENSET_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH31_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 30 : Enable PPI channel 30. */
N#define PPI_CHENSET_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENSET_CH30_Msk (0x1UL << PPI_CHENSET_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENSET_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH30_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 29 : Enable PPI channel 29. */
N#define PPI_CHENSET_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENSET_CH29_Msk (0x1UL << PPI_CHENSET_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENSET_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH29_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 28 : Enable PPI channel 28. */
N#define PPI_CHENSET_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENSET_CH28_Msk (0x1UL << PPI_CHENSET_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENSET_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH28_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 27 : Enable PPI channel 27. */
N#define PPI_CHENSET_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENSET_CH27_Msk (0x1UL << PPI_CHENSET_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENSET_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH27_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 26 : Enable PPI channel 26. */
N#define PPI_CHENSET_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENSET_CH26_Msk (0x1UL << PPI_CHENSET_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENSET_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH26_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 25 : Enable PPI channel 25. */
N#define PPI_CHENSET_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENSET_CH25_Msk (0x1UL << PPI_CHENSET_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENSET_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH25_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 24 : Enable PPI channel 24. */
N#define PPI_CHENSET_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENSET_CH24_Msk (0x1UL << PPI_CHENSET_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENSET_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH24_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 23 : Enable PPI channel 23. */
N#define PPI_CHENSET_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENSET_CH23_Msk (0x1UL << PPI_CHENSET_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENSET_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH23_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 22 : Enable PPI channel 22. */
N#define PPI_CHENSET_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENSET_CH22_Msk (0x1UL << PPI_CHENSET_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENSET_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH22_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 21 : Enable PPI channel 21. */
N#define PPI_CHENSET_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENSET_CH21_Msk (0x1UL << PPI_CHENSET_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENSET_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH21_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 20 : Enable PPI channel 20. */
N#define PPI_CHENSET_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENSET_CH20_Msk (0x1UL << PPI_CHENSET_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENSET_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH20_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 15 : Enable PPI channel 15. */
N#define PPI_CHENSET_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENSET_CH15_Msk (0x1UL << PPI_CHENSET_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENSET_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH15_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 14 : Enable PPI channel 14. */
N#define PPI_CHENSET_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENSET_CH14_Msk (0x1UL << PPI_CHENSET_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENSET_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH14_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 13 : Enable PPI channel 13. */
N#define PPI_CHENSET_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENSET_CH13_Msk (0x1UL << PPI_CHENSET_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENSET_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH13_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 12 : Enable PPI channel 12. */
N#define PPI_CHENSET_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENSET_CH12_Msk (0x1UL << PPI_CHENSET_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENSET_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH12_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 11 : Enable PPI channel 11. */
N#define PPI_CHENSET_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENSET_CH11_Msk (0x1UL << PPI_CHENSET_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENSET_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH11_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 10 : Enable PPI channel 10. */
N#define PPI_CHENSET_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENSET_CH10_Msk (0x1UL << PPI_CHENSET_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENSET_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH10_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 9 : Enable PPI channel 9. */
N#define PPI_CHENSET_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENSET_CH9_Msk (0x1UL << PPI_CHENSET_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENSET_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH9_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 8 : Enable PPI channel 8. */
N#define PPI_CHENSET_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENSET_CH8_Msk (0x1UL << PPI_CHENSET_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENSET_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH8_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 7 : Enable PPI channel 7. */
N#define PPI_CHENSET_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENSET_CH7_Msk (0x1UL << PPI_CHENSET_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENSET_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH7_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 6 : Enable PPI channel 6. */
N#define PPI_CHENSET_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENSET_CH6_Msk (0x1UL << PPI_CHENSET_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENSET_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH6_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 5 : Enable PPI channel 5. */
N#define PPI_CHENSET_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENSET_CH5_Msk (0x1UL << PPI_CHENSET_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENSET_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH5_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 4 : Enable PPI channel 4. */
N#define PPI_CHENSET_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENSET_CH4_Msk (0x1UL << PPI_CHENSET_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENSET_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH4_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 3 : Enable PPI channel 3. */
N#define PPI_CHENSET_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENSET_CH3_Msk (0x1UL << PPI_CHENSET_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENSET_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH3_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 2 : Enable PPI channel 2. */
N#define PPI_CHENSET_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENSET_CH2_Msk (0x1UL << PPI_CHENSET_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENSET_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH2_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 1 : Enable PPI channel 1. */
N#define PPI_CHENSET_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENSET_CH1_Msk (0x1UL << PPI_CHENSET_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENSET_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH1_Set (1UL) /*!< Enable channel on write. */
N
N/* Bit 0 : Enable PPI channel 0. */
N#define PPI_CHENSET_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENSET_CH0_Msk (0x1UL << PPI_CHENSET_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENSET_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENSET_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENSET_CH0_Set (1UL) /*!< Enable channel on write. */
N
N/* Register: PPI_CHENCLR */
N/* Description: Channel enable clear. */
N
N/* Bit 31 : Disable PPI channel 31. */
N#define PPI_CHENCLR_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHENCLR_CH31_Msk (0x1UL << PPI_CHENCLR_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHENCLR_CH31_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH31_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH31_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 30 : Disable PPI channel 30. */
N#define PPI_CHENCLR_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHENCLR_CH30_Msk (0x1UL << PPI_CHENCLR_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHENCLR_CH30_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH30_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH30_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 29 : Disable PPI channel 29. */
N#define PPI_CHENCLR_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHENCLR_CH29_Msk (0x1UL << PPI_CHENCLR_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHENCLR_CH29_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH29_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH29_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 28 : Disable PPI channel 28. */
N#define PPI_CHENCLR_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHENCLR_CH28_Msk (0x1UL << PPI_CHENCLR_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHENCLR_CH28_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH28_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH28_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 27 : Disable PPI channel 27. */
N#define PPI_CHENCLR_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHENCLR_CH27_Msk (0x1UL << PPI_CHENCLR_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHENCLR_CH27_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH27_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH27_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 26 : Disable PPI channel 26. */
N#define PPI_CHENCLR_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHENCLR_CH26_Msk (0x1UL << PPI_CHENCLR_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHENCLR_CH26_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH26_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH26_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 25 : Disable PPI channel 25. */
N#define PPI_CHENCLR_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHENCLR_CH25_Msk (0x1UL << PPI_CHENCLR_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHENCLR_CH25_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH25_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH25_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 24 : Disable PPI channel 24. */
N#define PPI_CHENCLR_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHENCLR_CH24_Msk (0x1UL << PPI_CHENCLR_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHENCLR_CH24_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH24_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH24_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 23 : Disable PPI channel 23. */
N#define PPI_CHENCLR_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHENCLR_CH23_Msk (0x1UL << PPI_CHENCLR_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHENCLR_CH23_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH23_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH23_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 22 : Disable PPI channel 22. */
N#define PPI_CHENCLR_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHENCLR_CH22_Msk (0x1UL << PPI_CHENCLR_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHENCLR_CH22_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH22_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH22_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 21 : Disable PPI channel 21. */
N#define PPI_CHENCLR_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHENCLR_CH21_Msk (0x1UL << PPI_CHENCLR_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHENCLR_CH21_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH21_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH21_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 20 : Disable PPI channel 20. */
N#define PPI_CHENCLR_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHENCLR_CH20_Msk (0x1UL << PPI_CHENCLR_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHENCLR_CH20_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH20_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH20_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 15 : Disable PPI channel 15. */
N#define PPI_CHENCLR_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHENCLR_CH15_Msk (0x1UL << PPI_CHENCLR_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHENCLR_CH15_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH15_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH15_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 14 : Disable PPI channel 14. */
N#define PPI_CHENCLR_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHENCLR_CH14_Msk (0x1UL << PPI_CHENCLR_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHENCLR_CH14_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH14_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH14_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 13 : Disable PPI channel 13. */
N#define PPI_CHENCLR_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHENCLR_CH13_Msk (0x1UL << PPI_CHENCLR_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHENCLR_CH13_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH13_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH13_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 12 : Disable PPI channel 12. */
N#define PPI_CHENCLR_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHENCLR_CH12_Msk (0x1UL << PPI_CHENCLR_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHENCLR_CH12_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH12_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH12_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 11 : Disable PPI channel 11. */
N#define PPI_CHENCLR_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHENCLR_CH11_Msk (0x1UL << PPI_CHENCLR_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHENCLR_CH11_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH11_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH11_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 10 : Disable PPI channel 10. */
N#define PPI_CHENCLR_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHENCLR_CH10_Msk (0x1UL << PPI_CHENCLR_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHENCLR_CH10_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH10_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH10_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 9 : Disable PPI channel 9. */
N#define PPI_CHENCLR_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHENCLR_CH9_Msk (0x1UL << PPI_CHENCLR_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHENCLR_CH9_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH9_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH9_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 8 : Disable PPI channel 8. */
N#define PPI_CHENCLR_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHENCLR_CH8_Msk (0x1UL << PPI_CHENCLR_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHENCLR_CH8_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH8_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH8_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 7 : Disable PPI channel 7. */
N#define PPI_CHENCLR_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHENCLR_CH7_Msk (0x1UL << PPI_CHENCLR_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHENCLR_CH7_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH7_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH7_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 6 : Disable PPI channel 6. */
N#define PPI_CHENCLR_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHENCLR_CH6_Msk (0x1UL << PPI_CHENCLR_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHENCLR_CH6_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH6_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH6_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 5 : Disable PPI channel 5. */
N#define PPI_CHENCLR_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHENCLR_CH5_Msk (0x1UL << PPI_CHENCLR_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHENCLR_CH5_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH5_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH5_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 4 : Disable PPI channel 4. */
N#define PPI_CHENCLR_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHENCLR_CH4_Msk (0x1UL << PPI_CHENCLR_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHENCLR_CH4_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH4_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH4_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 3 : Disable PPI channel 3. */
N#define PPI_CHENCLR_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHENCLR_CH3_Msk (0x1UL << PPI_CHENCLR_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHENCLR_CH3_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH3_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH3_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 2 : Disable PPI channel 2. */
N#define PPI_CHENCLR_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHENCLR_CH2_Msk (0x1UL << PPI_CHENCLR_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHENCLR_CH2_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH2_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH2_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 1 : Disable PPI channel 1. */
N#define PPI_CHENCLR_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHENCLR_CH1_Msk (0x1UL << PPI_CHENCLR_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHENCLR_CH1_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH1_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH1_Clear (1UL) /*!< Disable channel on write. */
N
N/* Bit 0 : Disable PPI channel 0. */
N#define PPI_CHENCLR_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHENCLR_CH0_Msk (0x1UL << PPI_CHENCLR_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHENCLR_CH0_Disabled (0UL) /*!< Channel disabled. */
N#define PPI_CHENCLR_CH0_Enabled (1UL) /*!< Channel enabled. */
N#define PPI_CHENCLR_CH0_Clear (1UL) /*!< Disable channel on write. */
N
N/* Register: PPI_CHG */
N/* Description: Channel group configuration. */
N
N/* Bit 31 : Include CH31 in channel group. */
N#define PPI_CHG_CH31_Pos (31UL) /*!< Position of CH31 field. */
N#define PPI_CHG_CH31_Msk (0x1UL << PPI_CHG_CH31_Pos) /*!< Bit mask of CH31 field. */
N#define PPI_CHG_CH31_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH31_Included (1UL) /*!< Channel included. */
N
N/* Bit 30 : Include CH30 in channel group. */
N#define PPI_CHG_CH30_Pos (30UL) /*!< Position of CH30 field. */
N#define PPI_CHG_CH30_Msk (0x1UL << PPI_CHG_CH30_Pos) /*!< Bit mask of CH30 field. */
N#define PPI_CHG_CH30_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH30_Included (1UL) /*!< Channel included. */
N
N/* Bit 29 : Include CH29 in channel group. */
N#define PPI_CHG_CH29_Pos (29UL) /*!< Position of CH29 field. */
N#define PPI_CHG_CH29_Msk (0x1UL << PPI_CHG_CH29_Pos) /*!< Bit mask of CH29 field. */
N#define PPI_CHG_CH29_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH29_Included (1UL) /*!< Channel included. */
N
N/* Bit 28 : Include CH28 in channel group. */
N#define PPI_CHG_CH28_Pos (28UL) /*!< Position of CH28 field. */
N#define PPI_CHG_CH28_Msk (0x1UL << PPI_CHG_CH28_Pos) /*!< Bit mask of CH28 field. */
N#define PPI_CHG_CH28_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH28_Included (1UL) /*!< Channel included. */
N
N/* Bit 27 : Include CH27 in channel group. */
N#define PPI_CHG_CH27_Pos (27UL) /*!< Position of CH27 field. */
N#define PPI_CHG_CH27_Msk (0x1UL << PPI_CHG_CH27_Pos) /*!< Bit mask of CH27 field. */
N#define PPI_CHG_CH27_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH27_Included (1UL) /*!< Channel included. */
N
N/* Bit 26 : Include CH26 in channel group. */
N#define PPI_CHG_CH26_Pos (26UL) /*!< Position of CH26 field. */
N#define PPI_CHG_CH26_Msk (0x1UL << PPI_CHG_CH26_Pos) /*!< Bit mask of CH26 field. */
N#define PPI_CHG_CH26_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH26_Included (1UL) /*!< Channel included. */
N
N/* Bit 25 : Include CH25 in channel group. */
N#define PPI_CHG_CH25_Pos (25UL) /*!< Position of CH25 field. */
N#define PPI_CHG_CH25_Msk (0x1UL << PPI_CHG_CH25_Pos) /*!< Bit mask of CH25 field. */
N#define PPI_CHG_CH25_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH25_Included (1UL) /*!< Channel included. */
N
N/* Bit 24 : Include CH24 in channel group. */
N#define PPI_CHG_CH24_Pos (24UL) /*!< Position of CH24 field. */
N#define PPI_CHG_CH24_Msk (0x1UL << PPI_CHG_CH24_Pos) /*!< Bit mask of CH24 field. */
N#define PPI_CHG_CH24_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH24_Included (1UL) /*!< Channel included. */
N
N/* Bit 23 : Include CH23 in channel group. */
N#define PPI_CHG_CH23_Pos (23UL) /*!< Position of CH23 field. */
N#define PPI_CHG_CH23_Msk (0x1UL << PPI_CHG_CH23_Pos) /*!< Bit mask of CH23 field. */
N#define PPI_CHG_CH23_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH23_Included (1UL) /*!< Channel included. */
N
N/* Bit 22 : Include CH22 in channel group. */
N#define PPI_CHG_CH22_Pos (22UL) /*!< Position of CH22 field. */
N#define PPI_CHG_CH22_Msk (0x1UL << PPI_CHG_CH22_Pos) /*!< Bit mask of CH22 field. */
N#define PPI_CHG_CH22_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH22_Included (1UL) /*!< Channel included. */
N
N/* Bit 21 : Include CH21 in channel group. */
N#define PPI_CHG_CH21_Pos (21UL) /*!< Position of CH21 field. */
N#define PPI_CHG_CH21_Msk (0x1UL << PPI_CHG_CH21_Pos) /*!< Bit mask of CH21 field. */
N#define PPI_CHG_CH21_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH21_Included (1UL) /*!< Channel included. */
N
N/* Bit 20 : Include CH20 in channel group. */
N#define PPI_CHG_CH20_Pos (20UL) /*!< Position of CH20 field. */
N#define PPI_CHG_CH20_Msk (0x1UL << PPI_CHG_CH20_Pos) /*!< Bit mask of CH20 field. */
N#define PPI_CHG_CH20_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH20_Included (1UL) /*!< Channel included. */
N
N/* Bit 15 : Include CH15 in channel group. */
N#define PPI_CHG_CH15_Pos (15UL) /*!< Position of CH15 field. */
N#define PPI_CHG_CH15_Msk (0x1UL << PPI_CHG_CH15_Pos) /*!< Bit mask of CH15 field. */
N#define PPI_CHG_CH15_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH15_Included (1UL) /*!< Channel included. */
N
N/* Bit 14 : Include CH14 in channel group. */
N#define PPI_CHG_CH14_Pos (14UL) /*!< Position of CH14 field. */
N#define PPI_CHG_CH14_Msk (0x1UL << PPI_CHG_CH14_Pos) /*!< Bit mask of CH14 field. */
N#define PPI_CHG_CH14_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH14_Included (1UL) /*!< Channel included. */
N
N/* Bit 13 : Include CH13 in channel group. */
N#define PPI_CHG_CH13_Pos (13UL) /*!< Position of CH13 field. */
N#define PPI_CHG_CH13_Msk (0x1UL << PPI_CHG_CH13_Pos) /*!< Bit mask of CH13 field. */
N#define PPI_CHG_CH13_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH13_Included (1UL) /*!< Channel included. */
N
N/* Bit 12 : Include CH12 in channel group. */
N#define PPI_CHG_CH12_Pos (12UL) /*!< Position of CH12 field. */
N#define PPI_CHG_CH12_Msk (0x1UL << PPI_CHG_CH12_Pos) /*!< Bit mask of CH12 field. */
N#define PPI_CHG_CH12_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH12_Included (1UL) /*!< Channel included. */
N
N/* Bit 11 : Include CH11 in channel group. */
N#define PPI_CHG_CH11_Pos (11UL) /*!< Position of CH11 field. */
N#define PPI_CHG_CH11_Msk (0x1UL << PPI_CHG_CH11_Pos) /*!< Bit mask of CH11 field. */
N#define PPI_CHG_CH11_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH11_Included (1UL) /*!< Channel included. */
N
N/* Bit 10 : Include CH10 in channel group. */
N#define PPI_CHG_CH10_Pos (10UL) /*!< Position of CH10 field. */
N#define PPI_CHG_CH10_Msk (0x1UL << PPI_CHG_CH10_Pos) /*!< Bit mask of CH10 field. */
N#define PPI_CHG_CH10_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH10_Included (1UL) /*!< Channel included. */
N
N/* Bit 9 : Include CH9 in channel group. */
N#define PPI_CHG_CH9_Pos (9UL) /*!< Position of CH9 field. */
N#define PPI_CHG_CH9_Msk (0x1UL << PPI_CHG_CH9_Pos) /*!< Bit mask of CH9 field. */
N#define PPI_CHG_CH9_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH9_Included (1UL) /*!< Channel included. */
N
N/* Bit 8 : Include CH8 in channel group. */
N#define PPI_CHG_CH8_Pos (8UL) /*!< Position of CH8 field. */
N#define PPI_CHG_CH8_Msk (0x1UL << PPI_CHG_CH8_Pos) /*!< Bit mask of CH8 field. */
N#define PPI_CHG_CH8_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH8_Included (1UL) /*!< Channel included. */
N
N/* Bit 7 : Include CH7 in channel group. */
N#define PPI_CHG_CH7_Pos (7UL) /*!< Position of CH7 field. */
N#define PPI_CHG_CH7_Msk (0x1UL << PPI_CHG_CH7_Pos) /*!< Bit mask of CH7 field. */
N#define PPI_CHG_CH7_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH7_Included (1UL) /*!< Channel included. */
N
N/* Bit 6 : Include CH6 in channel group. */
N#define PPI_CHG_CH6_Pos (6UL) /*!< Position of CH6 field. */
N#define PPI_CHG_CH6_Msk (0x1UL << PPI_CHG_CH6_Pos) /*!< Bit mask of CH6 field. */
N#define PPI_CHG_CH6_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH6_Included (1UL) /*!< Channel included. */
N
N/* Bit 5 : Include CH5 in channel group. */
N#define PPI_CHG_CH5_Pos (5UL) /*!< Position of CH5 field. */
N#define PPI_CHG_CH5_Msk (0x1UL << PPI_CHG_CH5_Pos) /*!< Bit mask of CH5 field. */
N#define PPI_CHG_CH5_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH5_Included (1UL) /*!< Channel included. */
N
N/* Bit 4 : Include CH4 in channel group. */
N#define PPI_CHG_CH4_Pos (4UL) /*!< Position of CH4 field. */
N#define PPI_CHG_CH4_Msk (0x1UL << PPI_CHG_CH4_Pos) /*!< Bit mask of CH4 field. */
N#define PPI_CHG_CH4_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH4_Included (1UL) /*!< Channel included. */
N
N/* Bit 3 : Include CH3 in channel group. */
N#define PPI_CHG_CH3_Pos (3UL) /*!< Position of CH3 field. */
N#define PPI_CHG_CH3_Msk (0x1UL << PPI_CHG_CH3_Pos) /*!< Bit mask of CH3 field. */
N#define PPI_CHG_CH3_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH3_Included (1UL) /*!< Channel included. */
N
N/* Bit 2 : Include CH2 in channel group. */
N#define PPI_CHG_CH2_Pos (2UL) /*!< Position of CH2 field. */
N#define PPI_CHG_CH2_Msk (0x1UL << PPI_CHG_CH2_Pos) /*!< Bit mask of CH2 field. */
N#define PPI_CHG_CH2_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH2_Included (1UL) /*!< Channel included. */
N
N/* Bit 1 : Include CH1 in channel group. */
N#define PPI_CHG_CH1_Pos (1UL) /*!< Position of CH1 field. */
N#define PPI_CHG_CH1_Msk (0x1UL << PPI_CHG_CH1_Pos) /*!< Bit mask of CH1 field. */
N#define PPI_CHG_CH1_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH1_Included (1UL) /*!< Channel included. */
N
N/* Bit 0 : Include CH0 in channel group. */
N#define PPI_CHG_CH0_Pos (0UL) /*!< Position of CH0 field. */
N#define PPI_CHG_CH0_Msk (0x1UL << PPI_CHG_CH0_Pos) /*!< Bit mask of CH0 field. */
N#define PPI_CHG_CH0_Excluded (0UL) /*!< Channel excluded. */
N#define PPI_CHG_CH0_Included (1UL) /*!< Channel included. */
N
N
N/* Peripheral: PU */
N/* Description: Patch unit. */
N
N/* Register: PU_PATCHADDR */
N/* Description: Relative address of patch instructions. */
N
N/* Bits 24..0 : Relative address of patch instructions. */
N#define PU_PATCHADDR_PATCHADDR_Pos (0UL) /*!< Position of PATCHADDR field. */
N#define PU_PATCHADDR_PATCHADDR_Msk (0x1FFFFFFUL << PU_PATCHADDR_PATCHADDR_Pos) /*!< Bit mask of PATCHADDR field. */
N
N/* Register: PU_PATCHEN */
N/* Description: Patch enable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHEN_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHEN_PATCH7_Msk (0x1UL << PU_PATCHEN_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHEN_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHEN_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHEN_PATCH6_Msk (0x1UL << PU_PATCHEN_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHEN_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHEN_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHEN_PATCH5_Msk (0x1UL << PU_PATCHEN_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHEN_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHEN_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHEN_PATCH4_Msk (0x1UL << PU_PATCHEN_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHEN_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHEN_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHEN_PATCH3_Msk (0x1UL << PU_PATCHEN_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHEN_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHEN_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHEN_PATCH2_Msk (0x1UL << PU_PATCHEN_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHEN_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHEN_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHEN_PATCH1_Msk (0x1UL << PU_PATCHEN_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHEN_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHEN_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHEN_PATCH0_Msk (0x1UL << PU_PATCHEN_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHEN_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHEN_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N
N/* Register: PU_PATCHENSET */
N/* Description: Patch enable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHENSET_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHENSET_PATCH7_Msk (0x1UL << PU_PATCHENSET_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHENSET_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH7_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHENSET_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHENSET_PATCH6_Msk (0x1UL << PU_PATCHENSET_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHENSET_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH6_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHENSET_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHENSET_PATCH5_Msk (0x1UL << PU_PATCHENSET_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHENSET_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH5_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHENSET_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHENSET_PATCH4_Msk (0x1UL << PU_PATCHENSET_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHENSET_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH4_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHENSET_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHENSET_PATCH3_Msk (0x1UL << PU_PATCHENSET_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHENSET_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH3_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHENSET_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHENSET_PATCH2_Msk (0x1UL << PU_PATCHENSET_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHENSET_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH2_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHENSET_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHENSET_PATCH1_Msk (0x1UL << PU_PATCHENSET_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHENSET_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH1_Set (1UL) /*!< Enable patch on write. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHENSET_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHENSET_PATCH0_Msk (0x1UL << PU_PATCHENSET_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHENSET_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENSET_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENSET_PATCH0_Set (1UL) /*!< Enable patch on write. */
N
N/* Register: PU_PATCHENCLR */
N/* Description: Patch disable register. */
N
N/* Bit 7 : Patch 7 enabled. */
N#define PU_PATCHENCLR_PATCH7_Pos (7UL) /*!< Position of PATCH7 field. */
N#define PU_PATCHENCLR_PATCH7_Msk (0x1UL << PU_PATCHENCLR_PATCH7_Pos) /*!< Bit mask of PATCH7 field. */
N#define PU_PATCHENCLR_PATCH7_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH7_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH7_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 6 : Patch 6 enabled. */
N#define PU_PATCHENCLR_PATCH6_Pos (6UL) /*!< Position of PATCH6 field. */
N#define PU_PATCHENCLR_PATCH6_Msk (0x1UL << PU_PATCHENCLR_PATCH6_Pos) /*!< Bit mask of PATCH6 field. */
N#define PU_PATCHENCLR_PATCH6_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH6_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH6_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 5 : Patch 5 enabled. */
N#define PU_PATCHENCLR_PATCH5_Pos (5UL) /*!< Position of PATCH5 field. */
N#define PU_PATCHENCLR_PATCH5_Msk (0x1UL << PU_PATCHENCLR_PATCH5_Pos) /*!< Bit mask of PATCH5 field. */
N#define PU_PATCHENCLR_PATCH5_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH5_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH5_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 4 : Patch 4 enabled. */
N#define PU_PATCHENCLR_PATCH4_Pos (4UL) /*!< Position of PATCH4 field. */
N#define PU_PATCHENCLR_PATCH4_Msk (0x1UL << PU_PATCHENCLR_PATCH4_Pos) /*!< Bit mask of PATCH4 field. */
N#define PU_PATCHENCLR_PATCH4_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH4_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH4_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 3 : Patch 3 enabled. */
N#define PU_PATCHENCLR_PATCH3_Pos (3UL) /*!< Position of PATCH3 field. */
N#define PU_PATCHENCLR_PATCH3_Msk (0x1UL << PU_PATCHENCLR_PATCH3_Pos) /*!< Bit mask of PATCH3 field. */
N#define PU_PATCHENCLR_PATCH3_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH3_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH3_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 2 : Patch 2 enabled. */
N#define PU_PATCHENCLR_PATCH2_Pos (2UL) /*!< Position of PATCH2 field. */
N#define PU_PATCHENCLR_PATCH2_Msk (0x1UL << PU_PATCHENCLR_PATCH2_Pos) /*!< Bit mask of PATCH2 field. */
N#define PU_PATCHENCLR_PATCH2_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH2_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH2_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 1 : Patch 1 enabled. */
N#define PU_PATCHENCLR_PATCH1_Pos (1UL) /*!< Position of PATCH1 field. */
N#define PU_PATCHENCLR_PATCH1_Msk (0x1UL << PU_PATCHENCLR_PATCH1_Pos) /*!< Bit mask of PATCH1 field. */
N#define PU_PATCHENCLR_PATCH1_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH1_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH1_Clear (1UL) /*!< Disable patch on write. */
N
N/* Bit 0 : Patch 0 enabled. */
N#define PU_PATCHENCLR_PATCH0_Pos (0UL) /*!< Position of PATCH0 field. */
N#define PU_PATCHENCLR_PATCH0_Msk (0x1UL << PU_PATCHENCLR_PATCH0_Pos) /*!< Bit mask of PATCH0 field. */
N#define PU_PATCHENCLR_PATCH0_Disabled (0UL) /*!< Patch disabled. */
N#define PU_PATCHENCLR_PATCH0_Enabled (1UL) /*!< Patch enabled. */
N#define PU_PATCHENCLR_PATCH0_Clear (1UL) /*!< Disable patch on write. */
N
N
N/* Peripheral: QDEC */
N/* Description: Rotary decoder. */
N
N/* Register: QDEC_SHORTS */
N/* Description: Shortcut for the QDEC. */
N
N/* Bit 1 : Short-cut between SAMPLERDY event and STOP task. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Pos (1UL) /*!< Position of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Msk (0x1UL << QDEC_SHORTS_SAMPLERDY_STOP_Pos) /*!< Bit mask of SAMPLERDY_STOP field. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_SAMPLERDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Short-cut between REPORTRDY event and READCLRACC task. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Pos (0UL) /*!< Position of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Msk (0x1UL << QDEC_SHORTS_REPORTRDY_READCLRACC_Pos) /*!< Bit mask of REPORTRDY_READCLRACC field. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Disabled (0UL) /*!< Shortcut disabled. */
N#define QDEC_SHORTS_REPORTRDY_READCLRACC_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: QDEC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on ACCOF event. */
N#define QDEC_INTENSET_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Msk (0x1UL << QDEC_INTENSET_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENSET_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_ACCOF_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on REPORTRDY event. */
N#define QDEC_INTENSET_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Msk (0x1UL << QDEC_INTENSET_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENSET_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_REPORTRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on SAMPLERDY event. */
N#define QDEC_INTENSET_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Msk (0x1UL << QDEC_INTENSET_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENSET_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENSET_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENSET_SAMPLERDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: QDEC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on ACCOF event. */
N#define QDEC_INTENCLR_ACCOF_Pos (2UL) /*!< Position of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Msk (0x1UL << QDEC_INTENCLR_ACCOF_Pos) /*!< Bit mask of ACCOF field. */
N#define QDEC_INTENCLR_ACCOF_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_ACCOF_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_ACCOF_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on REPORTRDY event. */
N#define QDEC_INTENCLR_REPORTRDY_Pos (1UL) /*!< Position of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Msk (0x1UL << QDEC_INTENCLR_REPORTRDY_Pos) /*!< Bit mask of REPORTRDY field. */
N#define QDEC_INTENCLR_REPORTRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_REPORTRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_REPORTRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on SAMPLERDY event. */
N#define QDEC_INTENCLR_SAMPLERDY_Pos (0UL) /*!< Position of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Msk (0x1UL << QDEC_INTENCLR_SAMPLERDY_Pos) /*!< Bit mask of SAMPLERDY field. */
N#define QDEC_INTENCLR_SAMPLERDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define QDEC_INTENCLR_SAMPLERDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: QDEC_ENABLE */
N/* Description: Enable the QDEC. */
N
N/* Bit 0 : Enable or disable QDEC. */
N#define QDEC_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Msk (0x1UL << QDEC_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define QDEC_ENABLE_ENABLE_Disabled (0UL) /*!< Disabled QDEC. */
N#define QDEC_ENABLE_ENABLE_Enabled (1UL) /*!< Enable QDEC. */
N
N/* Register: QDEC_LEDPOL */
N/* Description: LED output pin polarity. */
N
N/* Bit 0 : LED output pin polarity. */
N#define QDEC_LEDPOL_LEDPOL_Pos (0UL) /*!< Position of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_Msk (0x1UL << QDEC_LEDPOL_LEDPOL_Pos) /*!< Bit mask of LEDPOL field. */
N#define QDEC_LEDPOL_LEDPOL_ActiveLow (0UL) /*!< LED output is active low. */
N#define QDEC_LEDPOL_LEDPOL_ActiveHigh (1UL) /*!< LED output is active high. */
N
N/* Register: QDEC_SAMPLEPER */
N/* Description: Sample period. */
N
N/* Bits 2..0 : Sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Pos (0UL) /*!< Position of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_Msk (0x7UL << QDEC_SAMPLEPER_SAMPLEPER_Pos) /*!< Bit mask of SAMPLEPER field. */
N#define QDEC_SAMPLEPER_SAMPLEPER_128us (0x00UL) /*!< 128us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_256us (0x01UL) /*!< 256us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_512us (0x02UL) /*!< 512us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_1024us (0x03UL) /*!< 1024us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_2048us (0x04UL) /*!< 2048us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_4096us (0x05UL) /*!< 4096us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_8192us (0x06UL) /*!< 8192us sample period. */
N#define QDEC_SAMPLEPER_SAMPLEPER_16384us (0x07UL) /*!< 16384us sample period. */
N
N/* Register: QDEC_SAMPLE */
N/* Description: Motion sample value. */
N
N/* Bits 31..0 : Last sample taken in compliment to 2. */
N#define QDEC_SAMPLE_SAMPLE_Pos (0UL) /*!< Position of SAMPLE field. */
N#define QDEC_SAMPLE_SAMPLE_Msk (0xFFFFFFFFUL << QDEC_SAMPLE_SAMPLE_Pos) /*!< Bit mask of SAMPLE field. */
N
N/* Register: QDEC_REPORTPER */
N/* Description: Number of samples to generate an EVENT_REPORTRDY. */
N
N/* Bits 2..0 : Number of samples to generate an EVENT_REPORTRDY. */
N#define QDEC_REPORTPER_REPORTPER_Pos (0UL) /*!< Position of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_Msk (0x7UL << QDEC_REPORTPER_REPORTPER_Pos) /*!< Bit mask of REPORTPER field. */
N#define QDEC_REPORTPER_REPORTPER_10Smpl (0x00UL) /*!< 10 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_40Smpl (0x01UL) /*!< 40 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_80Smpl (0x02UL) /*!< 80 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_120Smpl (0x03UL) /*!< 120 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_160Smpl (0x04UL) /*!< 160 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_200Smpl (0x05UL) /*!< 200 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_240Smpl (0x06UL) /*!< 240 samples per report. */
N#define QDEC_REPORTPER_REPORTPER_280Smpl (0x07UL) /*!< 280 samples per report. */
N
N/* Register: QDEC_DBFEN */
N/* Description: Enable debouncer input filters. */
N
N/* Bit 0 : Enable debounce input filters. */
N#define QDEC_DBFEN_DBFEN_Pos (0UL) /*!< Position of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Msk (0x1UL << QDEC_DBFEN_DBFEN_Pos) /*!< Bit mask of DBFEN field. */
N#define QDEC_DBFEN_DBFEN_Disabled (0UL) /*!< Debounce input filters disabled. */
N#define QDEC_DBFEN_DBFEN_Enabled (1UL) /*!< Debounce input filters enabled. */
N
N/* Register: QDEC_LEDPRE */
N/* Description: Time LED is switched ON before the sample. */
N
N/* Bits 7..0 : Period in us the LED in switched on prior to sampling. */
N#define QDEC_LEDPRE_LEDPRE_Pos (0UL) /*!< Position of LEDPRE field. */
N#define QDEC_LEDPRE_LEDPRE_Msk (0xFFUL << QDEC_LEDPRE_LEDPRE_Pos) /*!< Bit mask of LEDPRE field. */
N
N/* Register: QDEC_ACCDBL */
N/* Description: Accumulated double (error) transitions register. */
N
N/* Bits 3..0 : Accumulated double (error) transitions. */
N#define QDEC_ACCDBL_ACCDBL_Pos (0UL) /*!< Position of ACCDBL field. */
N#define QDEC_ACCDBL_ACCDBL_Msk (0xFUL << QDEC_ACCDBL_ACCDBL_Pos) /*!< Bit mask of ACCDBL field. */
N
N/* Register: QDEC_ACCDBLREAD */
N/* Description: Snapshot of ACCDBL register. Value generated by the TASKS_READCLEACC task. */
N
N/* Bits 3..0 : Snapshot of accumulated double (error) transitions. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Pos (0UL) /*!< Position of ACCDBLREAD field. */
N#define QDEC_ACCDBLREAD_ACCDBLREAD_Msk (0xFUL << QDEC_ACCDBLREAD_ACCDBLREAD_Pos) /*!< Bit mask of ACCDBLREAD field. */
N
N/* Register: QDEC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define QDEC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define QDEC_POWER_POWER_Msk (0x1UL << QDEC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define QDEC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define QDEC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RADIO */
N/* Description: The radio. */
N
N/* Register: RADIO_SHORTS */
N/* Description: Shortcut for the radio. */
N
N/* Bit 8 : Shortcut between DISABLED event and RSSISTOP task. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Pos (8UL) /*!< Position of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Msk (0x1UL << RADIO_SHORTS_DISABLED_RSSISTOP_Pos) /*!< Bit mask of DISABLED_RSSISTOP field. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RSSISTOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 6 : Shortcut between ADDRESS event and BCSTART task. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Pos (6UL) /*!< Position of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_BCSTART_Pos) /*!< Bit mask of ADDRESS_BCSTART field. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_BCSTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 5 : Shortcut between END event and START task. */
N#define RADIO_SHORTS_END_START_Pos (5UL) /*!< Position of END_START field. */
N#define RADIO_SHORTS_END_START_Msk (0x1UL << RADIO_SHORTS_END_START_Pos) /*!< Bit mask of END_START field. */
N#define RADIO_SHORTS_END_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 4 : Shortcut between ADDRESS event and RSSISTART task. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Pos (4UL) /*!< Position of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Msk (0x1UL << RADIO_SHORTS_ADDRESS_RSSISTART_Pos) /*!< Bit mask of ADDRESS_RSSISTART field. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_ADDRESS_RSSISTART_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between DISABLED event and RXEN task. */
N#define RADIO_SHORTS_DISABLED_RXEN_Pos (3UL) /*!< Position of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_RXEN_Pos) /*!< Bit mask of DISABLED_RXEN field. */
N#define RADIO_SHORTS_DISABLED_RXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_RXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between DISABLED event and TXEN task.  */
N#define RADIO_SHORTS_DISABLED_TXEN_Pos (2UL) /*!< Position of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Msk (0x1UL << RADIO_SHORTS_DISABLED_TXEN_Pos) /*!< Bit mask of DISABLED_TXEN field. */
N#define RADIO_SHORTS_DISABLED_TXEN_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_DISABLED_TXEN_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between END event and DISABLE task. */
N#define RADIO_SHORTS_END_DISABLE_Pos (1UL) /*!< Position of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Msk (0x1UL << RADIO_SHORTS_END_DISABLE_Pos) /*!< Bit mask of END_DISABLE field. */
N#define RADIO_SHORTS_END_DISABLE_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_END_DISABLE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between READY event and START task. */
N#define RADIO_SHORTS_READY_START_Pos (0UL) /*!< Position of READY_START field. */
N#define RADIO_SHORTS_READY_START_Msk (0x1UL << RADIO_SHORTS_READY_START_Pos) /*!< Bit mask of READY_START field. */
N#define RADIO_SHORTS_READY_START_Disabled (0UL) /*!< Shortcut disabled. */
N#define RADIO_SHORTS_READY_START_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RADIO_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on BCMATCH event. */
N#define RADIO_INTENSET_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Msk (0x1UL << RADIO_INTENSET_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENSET_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_BCMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on RSSIEND event. */
N#define RADIO_INTENSET_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Msk (0x1UL << RADIO_INTENSET_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENSET_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_RSSIEND_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 6 : Enable interrupt on DEVMISS event. */
N#define RADIO_INTENSET_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Msk (0x1UL << RADIO_INTENSET_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENSET_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMISS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 5 : Enable interrupt on DEVMATCH event. */
N#define RADIO_INTENSET_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Msk (0x1UL << RADIO_INTENSET_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENSET_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DEVMATCH_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 4 : Enable interrupt on DISABLED event. */
N#define RADIO_INTENSET_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Msk (0x1UL << RADIO_INTENSET_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENSET_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_DISABLED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 3 : Enable interrupt on END event. */
N#define RADIO_INTENSET_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENSET_END_Msk (0x1UL << RADIO_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on PAYLOAD event. */
N#define RADIO_INTENSET_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Msk (0x1UL << RADIO_INTENSET_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENSET_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_PAYLOAD_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on ADDRESS event. */
N#define RADIO_INTENSET_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Msk (0x1UL << RADIO_INTENSET_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENSET_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_ADDRESS_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on READY event. */
N#define RADIO_INTENSET_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENSET_READY_Msk (0x1UL << RADIO_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RADIO_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on BCMATCH event. */
N#define RADIO_INTENCLR_BCMATCH_Pos (10UL) /*!< Position of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Msk (0x1UL << RADIO_INTENCLR_BCMATCH_Pos) /*!< Bit mask of BCMATCH field. */
N#define RADIO_INTENCLR_BCMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_BCMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_BCMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on RSSIEND event. */
N#define RADIO_INTENCLR_RSSIEND_Pos (7UL) /*!< Position of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Msk (0x1UL << RADIO_INTENCLR_RSSIEND_Pos) /*!< Bit mask of RSSIEND field. */
N#define RADIO_INTENCLR_RSSIEND_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_RSSIEND_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_RSSIEND_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 6 : Disable interrupt on DEVMISS event. */
N#define RADIO_INTENCLR_DEVMISS_Pos (6UL) /*!< Position of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Msk (0x1UL << RADIO_INTENCLR_DEVMISS_Pos) /*!< Bit mask of DEVMISS field. */
N#define RADIO_INTENCLR_DEVMISS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMISS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMISS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 5 : Disable interrupt on DEVMATCH event. */
N#define RADIO_INTENCLR_DEVMATCH_Pos (5UL) /*!< Position of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Msk (0x1UL << RADIO_INTENCLR_DEVMATCH_Pos) /*!< Bit mask of DEVMATCH field. */
N#define RADIO_INTENCLR_DEVMATCH_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DEVMATCH_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DEVMATCH_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 4 : Disable interrupt on DISABLED event. */
N#define RADIO_INTENCLR_DISABLED_Pos (4UL) /*!< Position of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Msk (0x1UL << RADIO_INTENCLR_DISABLED_Pos) /*!< Bit mask of DISABLED field. */
N#define RADIO_INTENCLR_DISABLED_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_DISABLED_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_DISABLED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 3 : Disable interrupt on END event. */
N#define RADIO_INTENCLR_END_Pos (3UL) /*!< Position of END field. */
N#define RADIO_INTENCLR_END_Msk (0x1UL << RADIO_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define RADIO_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on PAYLOAD event. */
N#define RADIO_INTENCLR_PAYLOAD_Pos (2UL) /*!< Position of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Msk (0x1UL << RADIO_INTENCLR_PAYLOAD_Pos) /*!< Bit mask of PAYLOAD field. */
N#define RADIO_INTENCLR_PAYLOAD_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_PAYLOAD_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_PAYLOAD_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on ADDRESS event. */
N#define RADIO_INTENCLR_ADDRESS_Pos (1UL) /*!< Position of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Msk (0x1UL << RADIO_INTENCLR_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N#define RADIO_INTENCLR_ADDRESS_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_ADDRESS_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_ADDRESS_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on READY event. */
N#define RADIO_INTENCLR_READY_Pos (0UL) /*!< Position of READY field. */
N#define RADIO_INTENCLR_READY_Msk (0x1UL << RADIO_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define RADIO_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RADIO_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RADIO_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RADIO_CRCSTATUS */
N/* Description: CRC status of received packet. */
N
N/* Bit 0 : CRC status of received packet. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Pos (0UL) /*!< Position of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_Msk (0x1UL << RADIO_CRCSTATUS_CRCSTATUS_Pos) /*!< Bit mask of CRCSTATUS field. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCError (0UL) /*!< Packet received with CRC error. */
N#define RADIO_CRCSTATUS_CRCSTATUS_CRCOk (1UL) /*!< Packet received with CRC ok. */
N
N/* Register: RADIO_RXMATCH */
N/* Description: Received address. */
N
N/* Bits 2..0 : Logical address in which previous packet was received. */
N#define RADIO_RXMATCH_RXMATCH_Pos (0UL) /*!< Position of RXMATCH field. */
N#define RADIO_RXMATCH_RXMATCH_Msk (0x7UL << RADIO_RXMATCH_RXMATCH_Pos) /*!< Bit mask of RXMATCH field. */
N
N/* Register: RADIO_RXCRC */
N/* Description: Received CRC. */
N
N/* Bits 23..0 : CRC field of previously received packet. */
N#define RADIO_RXCRC_RXCRC_Pos (0UL) /*!< Position of RXCRC field. */
N#define RADIO_RXCRC_RXCRC_Msk (0xFFFFFFUL << RADIO_RXCRC_RXCRC_Pos) /*!< Bit mask of RXCRC field. */
N
N/* Register: RADIO_DAI */
N/* Description: Device address match index. */
N
N/* Bits 2..0 : Index (n) of device address (see DAB[n] and DAP[n]) that got an address match. */
N#define RADIO_DAI_DAI_Pos (0UL) /*!< Position of DAI field. */
N#define RADIO_DAI_DAI_Msk (0x7UL << RADIO_DAI_DAI_Pos) /*!< Bit mask of DAI field. */
N
N/* Register: RADIO_FREQUENCY */
N/* Description: Frequency. */
N
N/* Bits 6..0 : Radio channel frequency offset in MHz: RF Frequency = 2400 + FREQUENCY (MHz). Decision point: TXEN or RXEN task.  */
N#define RADIO_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define RADIO_FREQUENCY_FREQUENCY_Msk (0x7FUL << RADIO_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N
N/* Register: RADIO_TXPOWER */
N/* Description: Output power. */
N
N/* Bits 7..0 : Radio output power. Decision point: TXEN task. */
N#define RADIO_TXPOWER_TXPOWER_Pos (0UL) /*!< Position of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Msk (0xFFUL << RADIO_TXPOWER_TXPOWER_Pos) /*!< Bit mask of TXPOWER field. */
N#define RADIO_TXPOWER_TXPOWER_Pos4dBm (0x04UL) /*!< +4dBm. */
N#define RADIO_TXPOWER_TXPOWER_0dBm (0x00UL) /*!< 0dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg4dBm (0xFCUL) /*!< -4dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg8dBm (0xF8UL) /*!< -8dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg12dBm (0xF4UL) /*!< -12dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg16dBm (0xF0UL) /*!< -16dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg20dBm (0xECUL) /*!< -20dBm. */
N#define RADIO_TXPOWER_TXPOWER_Neg30dBm (0xD8UL) /*!< -30dBm. */
N
N/* Register: RADIO_MODE */
N/* Description: Data rate and modulation. */
N
N/* Bits 1..0 : Radio data rate and modulation setting. Decision point: TXEN or RXEN task. */
N#define RADIO_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define RADIO_MODE_MODE_Msk (0x3UL << RADIO_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define RADIO_MODE_MODE_Nrf_1Mbit (0x00UL) /*!< 1Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_2Mbit (0x01UL) /*!< 2Mbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Nrf_250Kbit (0x02UL) /*!< 250kbit/s Nordic propietary radio mode. */
N#define RADIO_MODE_MODE_Ble_1Mbit (0x03UL) /*!< 1Mbit/s Bluetooth Low Energy */
N
N/* Register: RADIO_PCNF0 */
N/* Description: Packet configuration 0. */
N
N/* Bits 19..16 : Length of S1 field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_S1LEN_Pos (16UL) /*!< Position of S1LEN field. */
N#define RADIO_PCNF0_S1LEN_Msk (0xFUL << RADIO_PCNF0_S1LEN_Pos) /*!< Bit mask of S1LEN field. */
N
N/* Bit 8 : Length of S0 field in number of bytes. Decision point: START task. */
N#define RADIO_PCNF0_S0LEN_Pos (8UL) /*!< Position of S0LEN field. */
N#define RADIO_PCNF0_S0LEN_Msk (0x1UL << RADIO_PCNF0_S0LEN_Pos) /*!< Bit mask of S0LEN field. */
N
N/* Bits 3..0 : Length of length field in number of bits. Decision point: START task. */
N#define RADIO_PCNF0_LFLEN_Pos (0UL) /*!< Position of LFLEN field. */
N#define RADIO_PCNF0_LFLEN_Msk (0xFUL << RADIO_PCNF0_LFLEN_Pos) /*!< Bit mask of LFLEN field. */
N
N/* Register: RADIO_PCNF1 */
N/* Description: Packet configuration 1. */
N
N/* Bit 25 : Packet whitening enable. */
N#define RADIO_PCNF1_WHITEEN_Pos (25UL) /*!< Position of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Msk (0x1UL << RADIO_PCNF1_WHITEEN_Pos) /*!< Bit mask of WHITEEN field. */
N#define RADIO_PCNF1_WHITEEN_Disabled (0UL) /*!< Whitening disabled. */
N#define RADIO_PCNF1_WHITEEN_Enabled (1UL) /*!< Whitening enabled. */
N
N/* Bit 24 : On air endianness of packet length field. Decision point: START task. */
N#define RADIO_PCNF1_ENDIAN_Pos (24UL) /*!< Position of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Msk (0x1UL << RADIO_PCNF1_ENDIAN_Pos) /*!< Bit mask of ENDIAN field. */
N#define RADIO_PCNF1_ENDIAN_Little (0UL) /*!< Least significant bit on air first */
N#define RADIO_PCNF1_ENDIAN_Big (1UL) /*!< Most significant bit on air first */
N
N/* Bits 18..16 : Base address length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_BALEN_Pos (16UL) /*!< Position of BALEN field. */
N#define RADIO_PCNF1_BALEN_Msk (0x7UL << RADIO_PCNF1_BALEN_Pos) /*!< Bit mask of BALEN field. */
N
N/* Bits 15..8 : Static length in number of bytes. Decision point: START task. */
N#define RADIO_PCNF1_STATLEN_Pos (8UL) /*!< Position of STATLEN field. */
N#define RADIO_PCNF1_STATLEN_Msk (0xFFUL << RADIO_PCNF1_STATLEN_Pos) /*!< Bit mask of STATLEN field. */
N
N/* Bits 7..0 : Maximum length of packet payload in number of bytes. */
N#define RADIO_PCNF1_MAXLEN_Pos (0UL) /*!< Position of MAXLEN field. */
N#define RADIO_PCNF1_MAXLEN_Msk (0xFFUL << RADIO_PCNF1_MAXLEN_Pos) /*!< Bit mask of MAXLEN field. */
N
N/* Register: RADIO_PREFIX0 */
N/* Description: Prefixes bytes for logical addresses 0 to 3. */
N
N/* Bits 31..24 : Address prefix 3. Decision point: START task. */
N#define RADIO_PREFIX0_AP3_Pos (24UL) /*!< Position of AP3 field. */
N#define RADIO_PREFIX0_AP3_Msk (0xFFUL << RADIO_PREFIX0_AP3_Pos) /*!< Bit mask of AP3 field. */
N
N/* Bits 23..16 : Address prefix 2. Decision point: START task. */
N#define RADIO_PREFIX0_AP2_Pos (16UL) /*!< Position of AP2 field. */
N#define RADIO_PREFIX0_AP2_Msk (0xFFUL << RADIO_PREFIX0_AP2_Pos) /*!< Bit mask of AP2 field. */
N
N/* Bits 15..8 : Address prefix 1. Decision point: START task. */
N#define RADIO_PREFIX0_AP1_Pos (8UL) /*!< Position of AP1 field. */
N#define RADIO_PREFIX0_AP1_Msk (0xFFUL << RADIO_PREFIX0_AP1_Pos) /*!< Bit mask of AP1 field. */
N
N/* Bits 7..0 : Address prefix 0. Decision point: START task. */
N#define RADIO_PREFIX0_AP0_Pos (0UL) /*!< Position of AP0 field. */
N#define RADIO_PREFIX0_AP0_Msk (0xFFUL << RADIO_PREFIX0_AP0_Pos) /*!< Bit mask of AP0 field. */
N
N/* Register: RADIO_PREFIX1 */
N/* Description: Prefixes bytes for logical addresses 4 to 7. */
N
N/* Bits 31..24 : Address prefix 7. Decision point: START task. */
N#define RADIO_PREFIX1_AP7_Pos (24UL) /*!< Position of AP7 field. */
N#define RADIO_PREFIX1_AP7_Msk (0xFFUL << RADIO_PREFIX1_AP7_Pos) /*!< Bit mask of AP7 field. */
N
N/* Bits 23..16 : Address prefix 6. Decision point: START task. */
N#define RADIO_PREFIX1_AP6_Pos (16UL) /*!< Position of AP6 field. */
N#define RADIO_PREFIX1_AP6_Msk (0xFFUL << RADIO_PREFIX1_AP6_Pos) /*!< Bit mask of AP6 field. */
N
N/* Bits 15..8 : Address prefix 5. Decision point: START task. */
N#define RADIO_PREFIX1_AP5_Pos (8UL) /*!< Position of AP5 field. */
N#define RADIO_PREFIX1_AP5_Msk (0xFFUL << RADIO_PREFIX1_AP5_Pos) /*!< Bit mask of AP5 field. */
N
N/* Bits 7..0 : Address prefix 4. Decision point: START task. */
N#define RADIO_PREFIX1_AP4_Pos (0UL) /*!< Position of AP4 field. */
N#define RADIO_PREFIX1_AP4_Msk (0xFFUL << RADIO_PREFIX1_AP4_Pos) /*!< Bit mask of AP4 field. */
N
N/* Register: RADIO_TXADDRESS */
N/* Description: Transmit address select. */
N
N/* Bits 2..0 : Logical address to be used when transmitting a packet. Decision point: START task. */
N#define RADIO_TXADDRESS_TXADDRESS_Pos (0UL) /*!< Position of TXADDRESS field. */
N#define RADIO_TXADDRESS_TXADDRESS_Msk (0x7UL << RADIO_TXADDRESS_TXADDRESS_Pos) /*!< Bit mask of TXADDRESS field. */
N
N/* Register: RADIO_RXADDRESSES */
N/* Description: Receive address select. */
N
N/* Bit 7 : Enable reception on logical address 7. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR7_Pos (7UL) /*!< Position of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Msk (0x1UL << RADIO_RXADDRESSES_ADDR7_Pos) /*!< Bit mask of ADDR7 field. */
N#define RADIO_RXADDRESSES_ADDR7_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR7_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 6 : Enable reception on logical address 6. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR6_Pos (6UL) /*!< Position of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Msk (0x1UL << RADIO_RXADDRESSES_ADDR6_Pos) /*!< Bit mask of ADDR6 field. */
N#define RADIO_RXADDRESSES_ADDR6_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR6_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 5 : Enable reception on logical address 5. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR5_Pos (5UL) /*!< Position of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Msk (0x1UL << RADIO_RXADDRESSES_ADDR5_Pos) /*!< Bit mask of ADDR5 field. */
N#define RADIO_RXADDRESSES_ADDR5_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR5_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 4 : Enable reception on logical address 4. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR4_Pos (4UL) /*!< Position of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Msk (0x1UL << RADIO_RXADDRESSES_ADDR4_Pos) /*!< Bit mask of ADDR4 field. */
N#define RADIO_RXADDRESSES_ADDR4_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR4_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 3 : Enable reception on logical address 3. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR3_Pos (3UL) /*!< Position of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Msk (0x1UL << RADIO_RXADDRESSES_ADDR3_Pos) /*!< Bit mask of ADDR3 field. */
N#define RADIO_RXADDRESSES_ADDR3_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR3_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 2 : Enable reception on logical address 2. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR2_Pos (2UL) /*!< Position of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Msk (0x1UL << RADIO_RXADDRESSES_ADDR2_Pos) /*!< Bit mask of ADDR2 field. */
N#define RADIO_RXADDRESSES_ADDR2_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR2_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 1 : Enable reception on logical address 1. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR1_Pos (1UL) /*!< Position of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Msk (0x1UL << RADIO_RXADDRESSES_ADDR1_Pos) /*!< Bit mask of ADDR1 field. */
N#define RADIO_RXADDRESSES_ADDR1_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR1_Enabled (1UL) /*!< Reception enabled. */
N
N/* Bit 0 : Enable reception on logical address 0. Decision point: START task. */
N#define RADIO_RXADDRESSES_ADDR0_Pos (0UL) /*!< Position of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Msk (0x1UL << RADIO_RXADDRESSES_ADDR0_Pos) /*!< Bit mask of ADDR0 field. */
N#define RADIO_RXADDRESSES_ADDR0_Disabled (0UL) /*!< Reception disabled. */
N#define RADIO_RXADDRESSES_ADDR0_Enabled (1UL) /*!< Reception enabled. */
N
N/* Register: RADIO_CRCCNF */
N/* Description: CRC configuration. */
N
N/* Bit 8 : Leave packet address field out of the CRC calculation. Decision point: START task. */
N#define RADIO_CRCCNF_SKIP_ADDR_Pos (8UL) /*!< Position of SKIP_ADDR field. */
N#define RADIO_CRCCNF_SKIP_ADDR_Msk (0x1UL << RADIO_CRCCNF_SKIP_ADDR_Pos) /*!< Bit mask of SKIP_ADDR field. */
N#define RADIO_CRCCNF_SKIP_ADDR_Include (0UL) /*!< Include packet address in CRC calculation. */
N#define RADIO_CRCCNF_SKIP_ADDR_Skip (1UL) /*!< Packet address is skipped in CRC calculation. The CRC calculation will start at the first byte after the address. */
N
N/* Bits 1..0 : CRC length. Decision point: START task. */
N#define RADIO_CRCCNF_LEN_Pos (0UL) /*!< Position of LEN field. */
N#define RADIO_CRCCNF_LEN_Msk (0x3UL << RADIO_CRCCNF_LEN_Pos) /*!< Bit mask of LEN field. */
N#define RADIO_CRCCNF_LEN_Disabled (0UL) /*!< CRC calculation disabled. */
N#define RADIO_CRCCNF_LEN_One (1UL) /*!< One byte long CRC. */
N#define RADIO_CRCCNF_LEN_Two (2UL) /*!< Two bytes long CRC. */
N#define RADIO_CRCCNF_LEN_Three (3UL) /*!< Three bytes long CRC. */
N
N/* Register: RADIO_CRCPOLY */
N/* Description: CRC polynomial. */
N
N/* Bits 23..1 : CRC polynomial. Decision point: START task. */
N#define RADIO_CRCPOLY_CRCPOLY_Pos (1UL) /*!< Position of CRCPOLY field. */
N#define RADIO_CRCPOLY_CRCPOLY_Msk (0x7FFFFFUL << RADIO_CRCPOLY_CRCPOLY_Pos) /*!< Bit mask of CRCPOLY field. */
N
N/* Register: RADIO_CRCINIT */
N/* Description: CRC initial value. */
N
N/* Bits 23..0 : Initial value for CRC calculation. Decision point: START task. */
N#define RADIO_CRCINIT_CRCINIT_Pos (0UL) /*!< Position of CRCINIT field. */
N#define RADIO_CRCINIT_CRCINIT_Msk (0xFFFFFFUL << RADIO_CRCINIT_CRCINIT_Pos) /*!< Bit mask of CRCINIT field. */
N
N/* Register: RADIO_TEST */
N/* Description: Test features enable register. */
N
N/* Bit 1 : PLL lock. Decision point: TXEN or RXEN task. */
N#define RADIO_TEST_PLL_LOCK_Pos (1UL) /*!< Position of PLL_LOCK field. */
N#define RADIO_TEST_PLL_LOCK_Msk (0x1UL << RADIO_TEST_PLL_LOCK_Pos) /*!< Bit mask of PLL_LOCK field. */
N#define RADIO_TEST_PLL_LOCK_Disabled (0UL) /*!< PLL lock disabled. */
N#define RADIO_TEST_PLL_LOCK_Enabled (1UL) /*!< PLL lock enabled. */
N
N/* Bit 0 : Constant carrier. Decision point: TXEN task. */
N#define RADIO_TEST_CONST_CARRIER_Pos (0UL) /*!< Position of CONST_CARRIER field. */
N#define RADIO_TEST_CONST_CARRIER_Msk (0x1UL << RADIO_TEST_CONST_CARRIER_Pos) /*!< Bit mask of CONST_CARRIER field. */
N#define RADIO_TEST_CONST_CARRIER_Disabled (0UL) /*!< Constant carrier disabled. */
N#define RADIO_TEST_CONST_CARRIER_Enabled (1UL) /*!< Constant carrier enabled. */
N
N/* Register: RADIO_TIFS */
N/* Description: Inter Frame Spacing in microseconds. */
N
N/* Bits 7..0 : Inter frame spacing in microseconds. Decision point: START rask */
N#define RADIO_TIFS_TIFS_Pos (0UL) /*!< Position of TIFS field. */
N#define RADIO_TIFS_TIFS_Msk (0xFFUL << RADIO_TIFS_TIFS_Pos) /*!< Bit mask of TIFS field. */
N
N/* Register: RADIO_RSSISAMPLE */
N/* Description: RSSI sample. */
N
N/* Bits 6..0 : RSSI sample result. The result is read as a positive value so that ReceivedSignalStrength = -RSSISAMPLE dBm */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Pos (0UL) /*!< Position of RSSISAMPLE field. */
N#define RADIO_RSSISAMPLE_RSSISAMPLE_Msk (0x7FUL << RADIO_RSSISAMPLE_RSSISAMPLE_Pos) /*!< Bit mask of RSSISAMPLE field. */
N
N/* Register: RADIO_STATE */
N/* Description: Current radio state. */
N
N/* Bits 3..0 : Current radio state. */
N#define RADIO_STATE_STATE_Pos (0UL) /*!< Position of STATE field. */
N#define RADIO_STATE_STATE_Msk (0xFUL << RADIO_STATE_STATE_Pos) /*!< Bit mask of STATE field. */
N#define RADIO_STATE_STATE_Disabled (0x00UL) /*!< Radio is in the Disabled state. */
N#define RADIO_STATE_STATE_RxRu (0x01UL) /*!< Radio is in the Rx Ramp Up state. */
N#define RADIO_STATE_STATE_RxIdle (0x02UL) /*!< Radio is in the Rx Idle state. */
N#define RADIO_STATE_STATE_Rx (0x03UL) /*!< Radio is in the Rx state. */
N#define RADIO_STATE_STATE_RxDisable (0x04UL) /*!< Radio is in the Rx Disable state. */
N#define RADIO_STATE_STATE_TxRu (0x09UL) /*!< Radio is in the Tx Ramp Up state. */
N#define RADIO_STATE_STATE_TxIdle (0x0AUL) /*!< Radio is in the Tx Idle state. */
N#define RADIO_STATE_STATE_Tx (0x0BUL) /*!< Radio is in the Tx state. */
N#define RADIO_STATE_STATE_TxDisable (0x0CUL) /*!< Radio is in the Tx Disable state. */
N
N/* Register: RADIO_DATAWHITEIV */
N/* Description: Data whitening initial value. */
N
N/* Bits 5..0 : Data whitening initial value. Bit 0 corresponds to Position 0 of the LSFR, Bit 1 to position 5... Decision point: TXEN or RXEN task. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Pos (0UL) /*!< Position of DATAWHITEIV field. */
N#define RADIO_DATAWHITEIV_DATAWHITEIV_Msk (0x3FUL << RADIO_DATAWHITEIV_DATAWHITEIV_Pos) /*!< Bit mask of DATAWHITEIV field. */
N
N/* Register: RADIO_DAP */
N/* Description: Device address prefix. */
N
N/* Bits 15..0 : Device address prefix. */
N#define RADIO_DAP_DAP_Pos (0UL) /*!< Position of DAP field. */
N#define RADIO_DAP_DAP_Msk (0xFFFFUL << RADIO_DAP_DAP_Pos) /*!< Bit mask of DAP field. */
N
N/* Register: RADIO_DACNF */
N/* Description: Device address match configuration. */
N
N/* Bit 15 : TxAdd for device address 7. */
N#define RADIO_DACNF_TXADD7_Pos (15UL) /*!< Position of TXADD7 field. */
N#define RADIO_DACNF_TXADD7_Msk (0x1UL << RADIO_DACNF_TXADD7_Pos) /*!< Bit mask of TXADD7 field. */
N
N/* Bit 14 : TxAdd for device address 6. */
N#define RADIO_DACNF_TXADD6_Pos (14UL) /*!< Position of TXADD6 field. */
N#define RADIO_DACNF_TXADD6_Msk (0x1UL << RADIO_DACNF_TXADD6_Pos) /*!< Bit mask of TXADD6 field. */
N
N/* Bit 13 : TxAdd for device address 5. */
N#define RADIO_DACNF_TXADD5_Pos (13UL) /*!< Position of TXADD5 field. */
N#define RADIO_DACNF_TXADD5_Msk (0x1UL << RADIO_DACNF_TXADD5_Pos) /*!< Bit mask of TXADD5 field. */
N
N/* Bit 12 : TxAdd for device address 4. */
N#define RADIO_DACNF_TXADD4_Pos (12UL) /*!< Position of TXADD4 field. */
N#define RADIO_DACNF_TXADD4_Msk (0x1UL << RADIO_DACNF_TXADD4_Pos) /*!< Bit mask of TXADD4 field. */
N
N/* Bit 11 : TxAdd for device address 3. */
N#define RADIO_DACNF_TXADD3_Pos (11UL) /*!< Position of TXADD3 field. */
N#define RADIO_DACNF_TXADD3_Msk (0x1UL << RADIO_DACNF_TXADD3_Pos) /*!< Bit mask of TXADD3 field. */
N
N/* Bit 10 : TxAdd for device address 2. */
N#define RADIO_DACNF_TXADD2_Pos (10UL) /*!< Position of TXADD2 field. */
N#define RADIO_DACNF_TXADD2_Msk (0x1UL << RADIO_DACNF_TXADD2_Pos) /*!< Bit mask of TXADD2 field. */
N
N/* Bit 9 : TxAdd for device address 1. */
N#define RADIO_DACNF_TXADD1_Pos (9UL) /*!< Position of TXADD1 field. */
N#define RADIO_DACNF_TXADD1_Msk (0x1UL << RADIO_DACNF_TXADD1_Pos) /*!< Bit mask of TXADD1 field. */
N
N/* Bit 8 : TxAdd for device address 0. */
N#define RADIO_DACNF_TXADD0_Pos (8UL) /*!< Position of TXADD0 field. */
N#define RADIO_DACNF_TXADD0_Msk (0x1UL << RADIO_DACNF_TXADD0_Pos) /*!< Bit mask of TXADD0 field. */
N
N/* Bit 7 : Enable or disable device address matching using device address 7. */
N#define RADIO_DACNF_ENA7_Pos (7UL) /*!< Position of ENA7 field. */
N#define RADIO_DACNF_ENA7_Msk (0x1UL << RADIO_DACNF_ENA7_Pos) /*!< Bit mask of ENA7 field. */
N#define RADIO_DACNF_ENA7_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA7_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 6 : Enable or disable device address matching using device address 6. */
N#define RADIO_DACNF_ENA6_Pos (6UL) /*!< Position of ENA6 field. */
N#define RADIO_DACNF_ENA6_Msk (0x1UL << RADIO_DACNF_ENA6_Pos) /*!< Bit mask of ENA6 field. */
N#define RADIO_DACNF_ENA6_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA6_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 5 : Enable or disable device address matching using device address 5. */
N#define RADIO_DACNF_ENA5_Pos (5UL) /*!< Position of ENA5 field. */
N#define RADIO_DACNF_ENA5_Msk (0x1UL << RADIO_DACNF_ENA5_Pos) /*!< Bit mask of ENA5 field. */
N#define RADIO_DACNF_ENA5_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA5_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 4 : Enable or disable device address matching using device address 4. */
N#define RADIO_DACNF_ENA4_Pos (4UL) /*!< Position of ENA4 field. */
N#define RADIO_DACNF_ENA4_Msk (0x1UL << RADIO_DACNF_ENA4_Pos) /*!< Bit mask of ENA4 field. */
N#define RADIO_DACNF_ENA4_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA4_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 3 : Enable or disable device address matching using device address 3. */
N#define RADIO_DACNF_ENA3_Pos (3UL) /*!< Position of ENA3 field. */
N#define RADIO_DACNF_ENA3_Msk (0x1UL << RADIO_DACNF_ENA3_Pos) /*!< Bit mask of ENA3 field. */
N#define RADIO_DACNF_ENA3_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA3_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 2 : Enable or disable device address matching using device address 2. */
N#define RADIO_DACNF_ENA2_Pos (2UL) /*!< Position of ENA2 field. */
N#define RADIO_DACNF_ENA2_Msk (0x1UL << RADIO_DACNF_ENA2_Pos) /*!< Bit mask of ENA2 field. */
N#define RADIO_DACNF_ENA2_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA2_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 1 : Enable or disable device address matching using device address 1. */
N#define RADIO_DACNF_ENA1_Pos (1UL) /*!< Position of ENA1 field. */
N#define RADIO_DACNF_ENA1_Msk (0x1UL << RADIO_DACNF_ENA1_Pos) /*!< Bit mask of ENA1 field. */
N#define RADIO_DACNF_ENA1_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA1_Enabled (1UL) /*!< Enabled. */
N
N/* Bit 0 : Enable or disable device address matching using device address 0. */
N#define RADIO_DACNF_ENA0_Pos (0UL) /*!< Position of ENA0 field. */
N#define RADIO_DACNF_ENA0_Msk (0x1UL << RADIO_DACNF_ENA0_Pos) /*!< Bit mask of ENA0 field. */
N#define RADIO_DACNF_ENA0_Disabled (0UL) /*!< Disabled. */
N#define RADIO_DACNF_ENA0_Enabled (1UL) /*!< Enabled. */
N
N/* Register: RADIO_OVERRIDE0 */
N/* Description: Trim value override register 0. */
N
N/* Bits 31..0 : Trim value override register 0. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Pos (0UL) /*!< Position of OVERRIDE0 field. */
N#define RADIO_OVERRIDE0_OVERRIDE0_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE0_OVERRIDE0_Pos) /*!< Bit mask of OVERRIDE0 field. */
N
N/* Register: RADIO_OVERRIDE1 */
N/* Description: Trim value override register 1. */
N
N/* Bits 31..0 : Trim value override register 1. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Pos (0UL) /*!< Position of OVERRIDE1 field. */
N#define RADIO_OVERRIDE1_OVERRIDE1_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE1_OVERRIDE1_Pos) /*!< Bit mask of OVERRIDE1 field. */
N
N/* Register: RADIO_OVERRIDE2 */
N/* Description: Trim value override register 2. */
N
N/* Bits 31..0 : Trim value override register 2. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Pos (0UL) /*!< Position of OVERRIDE2 field. */
N#define RADIO_OVERRIDE2_OVERRIDE2_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE2_OVERRIDE2_Pos) /*!< Bit mask of OVERRIDE2 field. */
N
N/* Register: RADIO_OVERRIDE3 */
N/* Description: Trim value override register 3. */
N
N/* Bits 31..0 : Trim value override register 3. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Pos (0UL) /*!< Position of OVERRIDE3 field. */
N#define RADIO_OVERRIDE3_OVERRIDE3_Msk (0xFFFFFFFFUL << RADIO_OVERRIDE3_OVERRIDE3_Pos) /*!< Bit mask of OVERRIDE3 field. */
N
N/* Register: RADIO_OVERRIDE4 */
N/* Description: Trim value override register 4. */
N
N/* Bit 31 : Enable or disable override of default trim values. */
N#define RADIO_OVERRIDE4_ENABLE_Pos (31UL) /*!< Position of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Msk (0x1UL << RADIO_OVERRIDE4_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define RADIO_OVERRIDE4_ENABLE_Disabled (0UL) /*!< Override trim values disabled. */
N#define RADIO_OVERRIDE4_ENABLE_Enabled (1UL) /*!< Override trim values enabled. */
N
N/* Bits 27..0 : Trim value override register 4. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Pos (0UL) /*!< Position of OVERRIDE4 field. */
N#define RADIO_OVERRIDE4_OVERRIDE4_Msk (0xFFFFFFFUL << RADIO_OVERRIDE4_OVERRIDE4_Pos) /*!< Bit mask of OVERRIDE4 field. */
N
N/* Register: RADIO_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RADIO_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RADIO_POWER_POWER_Msk (0x1UL << RADIO_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RADIO_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RADIO_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RNG */
N/* Description: Random Number Generator. */
N
N/* Register: RNG_SHORTS */
N/* Description: Shortcut for the RNG. */
N
N/* Bit 0 : Short-cut between VALRDY event and STOP task. */
N#define RNG_SHORTS_VALRDY_STOP_Pos (0UL) /*!< Position of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Msk (0x1UL << RNG_SHORTS_VALRDY_STOP_Pos) /*!< Bit mask of VALRDY_STOP field. */
N#define RNG_SHORTS_VALRDY_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define RNG_SHORTS_VALRDY_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: RNG_INTENSET */
N/* Description: Interrupt enable set register */
N
N/* Bit 0 : Enable interrupt on VALRDY event. */
N#define RNG_INTENSET_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Msk (0x1UL << RNG_INTENSET_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENSET_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENSET_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENSET_VALRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RNG_INTENCLR */
N/* Description: Interrupt enable clear register */
N
N/* Bit 0 : Disable interrupt on VALRDY event. */
N#define RNG_INTENCLR_VALRDY_Pos (0UL) /*!< Position of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Msk (0x1UL << RNG_INTENCLR_VALRDY_Pos) /*!< Bit mask of VALRDY field. */
N#define RNG_INTENCLR_VALRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define RNG_INTENCLR_VALRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define RNG_INTENCLR_VALRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RNG_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 0 : Digital error correction enable. */
N#define RNG_CONFIG_DERCEN_Pos (0UL) /*!< Position of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Msk (0x1UL << RNG_CONFIG_DERCEN_Pos) /*!< Bit mask of DERCEN field. */
N#define RNG_CONFIG_DERCEN_Disabled (0UL) /*!< Digital error correction disabled. */
N#define RNG_CONFIG_DERCEN_Enabled (1UL) /*!< Digital error correction enabled. */
N
N/* Register: RNG_VALUE */
N/* Description: RNG random number. */
N
N/* Bits 7..0 : Generated random number. */
N#define RNG_VALUE_VALUE_Pos (0UL) /*!< Position of VALUE field. */
N#define RNG_VALUE_VALUE_Msk (0xFFUL << RNG_VALUE_VALUE_Pos) /*!< Bit mask of VALUE field. */
N
N/* Register: RNG_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RNG_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RNG_POWER_POWER_Msk (0x1UL << RNG_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RNG_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RNG_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: RTC */
N/* Description: Real time counter 0. */
N
N/* Register: RTC_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] event. */
N#define RTC_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Msk (0x1UL << RTC_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] event. */
N#define RTC_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Msk (0x1UL << RTC_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] event. */
N#define RTC_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Msk (0x1UL << RTC_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] event. */
N#define RTC_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Msk (0x1UL << RTC_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on OVRFLW event. */
N#define RTC_INTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Msk (0x1UL << RTC_INTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENSET_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_OVRFLW_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 0 : Enable interrupt on TICK event. */
N#define RTC_INTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENSET_TICK_Msk (0x1UL << RTC_INTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENSET_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENSET_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENSET_TICK_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: RTC_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] event. */
N#define RTC_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Msk (0x1UL << RTC_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] event. */
N#define RTC_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Msk (0x1UL << RTC_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] event. */
N#define RTC_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Msk (0x1UL << RTC_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] event. */
N#define RTC_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Msk (0x1UL << RTC_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on OVRFLW event. */
N#define RTC_INTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Msk (0x1UL << RTC_INTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_INTENCLR_OVRFLW_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_OVRFLW_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_OVRFLW_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 0 : Disable interrupt on TICK event. */
N#define RTC_INTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_INTENCLR_TICK_Msk (0x1UL << RTC_INTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_INTENCLR_TICK_Disabled (0UL) /*!< Interrupt disabled. */
N#define RTC_INTENCLR_TICK_Enabled (1UL) /*!< Interrupt enabled. */
N#define RTC_INTENCLR_TICK_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: RTC_EVTEN */
N/* Description: Configures event enable routing to PPI for each RTC event. */
N
N/* Bit 19 : COMPARE[3] event enable. */
N#define RTC_EVTEN_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Msk (0x1UL << RTC_EVTEN_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTEN_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 18 : COMPARE[2] event enable. */
N#define RTC_EVTEN_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Msk (0x1UL << RTC_EVTEN_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTEN_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 17 : COMPARE[1] event enable. */
N#define RTC_EVTEN_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Msk (0x1UL << RTC_EVTEN_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTEN_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 16 : COMPARE[0] event enable. */
N#define RTC_EVTEN_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Msk (0x1UL << RTC_EVTEN_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTEN_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 1 : OVRFLW event enable. */
N#define RTC_EVTEN_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Msk (0x1UL << RTC_EVTEN_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTEN_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N
N/* Bit 0 : TICK event enable. */
N#define RTC_EVTEN_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTEN_TICK_Msk (0x1UL << RTC_EVTEN_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTEN_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTEN_TICK_Enabled (1UL) /*!< Event enabled. */
N
N/* Register: RTC_EVTENSET */
N/* Description: Enable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Enable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Msk (0x1UL << RTC_EVTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENSET_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE3_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 18 : Enable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Msk (0x1UL << RTC_EVTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENSET_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE2_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 17 : Enable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Msk (0x1UL << RTC_EVTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENSET_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE1_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 16 : Enable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Msk (0x1UL << RTC_EVTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENSET_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_COMPARE0_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 1 : Enable routing to PPI of OVRFLW event. */
N#define RTC_EVTENSET_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Msk (0x1UL << RTC_EVTENSET_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENSET_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_OVRFLW_Set (1UL) /*!< Enable event on write. */
N
N/* Bit 0 : Enable routing to PPI of TICK event. */
N#define RTC_EVTENSET_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENSET_TICK_Msk (0x1UL << RTC_EVTENSET_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENSET_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENSET_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENSET_TICK_Set (1UL) /*!< Enable event on write. */
N
N/* Register: RTC_EVTENCLR */
N/* Description: Disable events routing to PPI. The reading of this register gives the value of EVTEN. */
N
N/* Bit 19 : Disable routing to PPI of COMPARE[3] event. */
N#define RTC_EVTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Msk (0x1UL << RTC_EVTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define RTC_EVTENCLR_COMPARE3_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE3_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE3_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 18 : Disable routing to PPI of COMPARE[2] event. */
N#define RTC_EVTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Msk (0x1UL << RTC_EVTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define RTC_EVTENCLR_COMPARE2_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE2_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE2_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 17 : Disable routing to PPI of COMPARE[1] event. */
N#define RTC_EVTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Msk (0x1UL << RTC_EVTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define RTC_EVTENCLR_COMPARE1_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE1_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE1_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 16 : Disable routing to PPI of COMPARE[0] event. */
N#define RTC_EVTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Msk (0x1UL << RTC_EVTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define RTC_EVTENCLR_COMPARE0_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_COMPARE0_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_COMPARE0_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 1 : Disable routing to PPI of OVRFLW event. */
N#define RTC_EVTENCLR_OVRFLW_Pos (1UL) /*!< Position of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Msk (0x1UL << RTC_EVTENCLR_OVRFLW_Pos) /*!< Bit mask of OVRFLW field. */
N#define RTC_EVTENCLR_OVRFLW_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_OVRFLW_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_OVRFLW_Clear (1UL) /*!< Disable event on write. */
N
N/* Bit 0 : Disable routing to PPI of TICK event. */
N#define RTC_EVTENCLR_TICK_Pos (0UL) /*!< Position of TICK field. */
N#define RTC_EVTENCLR_TICK_Msk (0x1UL << RTC_EVTENCLR_TICK_Pos) /*!< Bit mask of TICK field. */
N#define RTC_EVTENCLR_TICK_Disabled (0UL) /*!< Event disabled. */
N#define RTC_EVTENCLR_TICK_Enabled (1UL) /*!< Event enabled. */
N#define RTC_EVTENCLR_TICK_Clear (1UL) /*!< Disable event on write. */
N
N/* Register: RTC_COUNTER */
N/* Description: Current COUNTER value. */
N
N/* Bits 23..0 : Counter value. */
N#define RTC_COUNTER_COUNTER_Pos (0UL) /*!< Position of COUNTER field. */
N#define RTC_COUNTER_COUNTER_Msk (0xFFFFFFUL << RTC_COUNTER_COUNTER_Pos) /*!< Bit mask of COUNTER field. */
N
N/* Register: RTC_PRESCALER */
N/* Description: 12-bit prescaler for COUNTER frequency (32768/(PRESCALER+1)). Must be written when RTC is STOPed. */
N
N/* Bits 11..0 : RTC PRESCALER value. */
N#define RTC_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define RTC_PRESCALER_PRESCALER_Msk (0xFFFUL << RTC_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: RTC_CC */
N/* Description: Capture/compare registers. */
N
N/* Bits 23..0 : Compare value. */
N#define RTC_CC_COMPARE_Pos (0UL) /*!< Position of COMPARE field. */
N#define RTC_CC_COMPARE_Msk (0xFFFFFFUL << RTC_CC_COMPARE_Pos) /*!< Bit mask of COMPARE field. */
N
N/* Register: RTC_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define RTC_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define RTC_POWER_POWER_Msk (0x1UL << RTC_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define RTC_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define RTC_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPI */
N/* Description: SPI master 0. */
N
N/* Register: SPI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define SPI_INTENSET_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENSET_READY_Msk (0x1UL << SPI_INTENSET_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENSET_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENSET_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENSET_READY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 2 : Disable interrupt on READY event. */
N#define SPI_INTENCLR_READY_Pos (2UL) /*!< Position of READY field. */
N#define SPI_INTENCLR_READY_Msk (0x1UL << SPI_INTENCLR_READY_Pos) /*!< Bit mask of READY field. */
N#define SPI_INTENCLR_READY_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPI_INTENCLR_READY_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPI_INTENCLR_READY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPI_ENABLE */
N/* Description: Enable SPI. */
N
N/* Bits 2..0 : Enable or disable SPI. */
N#define SPI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Msk (0x7UL << SPI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPI. */
N#define SPI_ENABLE_ENABLE_Enabled (0x01UL) /*!< Enable SPI. */
N
N/* Register: SPI_RXD */
N/* Description: RX data. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define SPI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define SPI_RXD_RXD_Msk (0xFFUL << SPI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: SPI_TXD */
N/* Description: TX data. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define SPI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define SPI_TXD_TXD_Msk (0xFFUL << SPI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: SPI_FREQUENCY */
N/* Description: SPI frequency */
N
N/* Bits 31..0 : SPI data rate. */
N#define SPI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << SPI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define SPI_FREQUENCY_FREQUENCY_K125 (0x02000000UL) /*!< 125kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250kbps. */
N#define SPI_FREQUENCY_FREQUENCY_K500 (0x08000000UL) /*!< 500kbps. */
N#define SPI_FREQUENCY_FREQUENCY_M1 (0x10000000UL) /*!< 1Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M2 (0x20000000UL) /*!< 2Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M4 (0x40000000UL) /*!< 4Mbps. */
N#define SPI_FREQUENCY_FREQUENCY_M8 (0x80000000UL) /*!< 8Mbps. */
N
N/* Register: SPI_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPI_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPI_CONFIG_CPOL_Msk (0x1UL << SPI_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPI_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPI_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPI_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPI_CONFIG_CPHA_Msk (0x1UL << SPI_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPI_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPI_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPI_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPI_CONFIG_ORDER_Msk (0x1UL << SPI_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPI_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPI_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPI_POWER_POWER_Msk (0x1UL << SPI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: SPIS */
N/* Description: SPI slave 1. */
N
N/* Register: SPIS_SHORTS */
N/* Description: Shortcuts for SPIS. */
N
N/* Bit 2 : Shortcut between END event and the ACQUIRE task. */
N#define SPIS_SHORTS_END_ACQUIRE_Pos (2UL) /*!< Position of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Msk (0x1UL << SPIS_SHORTS_END_ACQUIRE_Pos) /*!< Bit mask of END_ACQUIRE field. */
N#define SPIS_SHORTS_END_ACQUIRE_Disabled (0UL) /*!< Shortcut disabled. */
N#define SPIS_SHORTS_END_ACQUIRE_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: SPIS_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 10 : Enable interrupt on ACQUIRED event. */
N#define SPIS_INTENSET_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Msk (0x1UL << SPIS_INTENSET_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENSET_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_ACQUIRED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on END event. */
N#define SPIS_INTENSET_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENSET_END_Msk (0x1UL << SPIS_INTENSET_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENSET_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENSET_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENSET_END_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: SPIS_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 10 : Disable interrupt on ACQUIRED event. */
N#define SPIS_INTENCLR_ACQUIRED_Pos (10UL) /*!< Position of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Msk (0x1UL << SPIS_INTENCLR_ACQUIRED_Pos) /*!< Bit mask of ACQUIRED field. */
N#define SPIS_INTENCLR_ACQUIRED_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_ACQUIRED_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_ACQUIRED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on END event. */
N#define SPIS_INTENCLR_END_Pos (1UL) /*!< Position of END field. */
N#define SPIS_INTENCLR_END_Msk (0x1UL << SPIS_INTENCLR_END_Pos) /*!< Bit mask of END field. */
N#define SPIS_INTENCLR_END_Disabled (0UL) /*!< Interrupt disabled. */
N#define SPIS_INTENCLR_END_Enabled (1UL) /*!< Interrupt enabled. */
N#define SPIS_INTENCLR_END_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: SPIS_SEMSTAT */
N/* Description: Semaphore status. */
N
N/* Bits 1..0 : Semaphore status. */
N#define SPIS_SEMSTAT_SEMSTAT_Pos (0UL) /*!< Position of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Msk (0x3UL << SPIS_SEMSTAT_SEMSTAT_Pos) /*!< Bit mask of SEMSTAT field. */
N#define SPIS_SEMSTAT_SEMSTAT_Free (0x00UL) /*!< Semaphore is free. */
N#define SPIS_SEMSTAT_SEMSTAT_CPU (0x01UL) /*!< Semaphore is assigned to the CPU. */
N#define SPIS_SEMSTAT_SEMSTAT_SPIS (0x02UL) /*!< Semaphore is assigned to the SPIS. */
N#define SPIS_SEMSTAT_SEMSTAT_CPUPending (0x03UL) /*!< Semaphore is assigned to the SPIS, but a handover to the CPU is pending. */
N
N/* Register: SPIS_STATUS */
N/* Description: Status from last transaction. */
N
N/* Bit 1 : RX buffer overflow detected, and prevented. */
N#define SPIS_STATUS_OVERFLOW_Pos (1UL) /*!< Position of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_Msk (0x1UL << SPIS_STATUS_OVERFLOW_Pos) /*!< Bit mask of OVERFLOW field. */
N#define SPIS_STATUS_OVERFLOW_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERFLOW_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERFLOW_Clear (1UL) /*!< Clear on write. */
N
N/* Bit 0 : TX buffer overread detected, and prevented. */
N#define SPIS_STATUS_OVERREAD_Pos (0UL) /*!< Position of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_Msk (0x1UL << SPIS_STATUS_OVERREAD_Pos) /*!< Bit mask of OVERREAD field. */
N#define SPIS_STATUS_OVERREAD_NotPresent (0UL) /*!< Error not present. */
N#define SPIS_STATUS_OVERREAD_Present (1UL) /*!< Error present. */
N#define SPIS_STATUS_OVERREAD_Clear (1UL) /*!< Clear on write. */
N
N/* Register: SPIS_ENABLE */
N/* Description: Enable SPIS. */
N
N/* Bits 2..0 : Enable or disable SPIS. */
N#define SPIS_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Msk (0x7UL << SPIS_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define SPIS_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled SPIS. */
N#define SPIS_ENABLE_ENABLE_Enabled (0x02UL) /*!< Enable SPIS. */
N
N/* Register: SPIS_MAXRX */
N/* Description: Maximum number of bytes in the receive buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the receive buffer. */
N#define SPIS_MAXRX_MAXRX_Pos (0UL) /*!< Position of MAXRX field. */
N#define SPIS_MAXRX_MAXRX_Msk (0xFFUL << SPIS_MAXRX_MAXRX_Pos) /*!< Bit mask of MAXRX field. */
N
N/* Register: SPIS_AMOUNTRX */
N/* Description: Number of bytes received in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes received in last granted transaction. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Pos (0UL) /*!< Position of AMOUNTRX field. */
N#define SPIS_AMOUNTRX_AMOUNTRX_Msk (0xFFUL << SPIS_AMOUNTRX_AMOUNTRX_Pos) /*!< Bit mask of AMOUNTRX field. */
N
N/* Register: SPIS_MAXTX */
N/* Description: Maximum number of bytes in the transmit buffer. */
N
N/* Bits 7..0 : Maximum number of bytes in the transmit buffer. */
N#define SPIS_MAXTX_MAXTX_Pos (0UL) /*!< Position of MAXTX field. */
N#define SPIS_MAXTX_MAXTX_Msk (0xFFUL << SPIS_MAXTX_MAXTX_Pos) /*!< Bit mask of MAXTX field. */
N
N/* Register: SPIS_AMOUNTTX */
N/* Description: Number of bytes transmitted in last granted transaction. */
N
N/* Bits 7..0 : Number of bytes transmitted in last granted transaction. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Pos (0UL) /*!< Position of AMOUNTTX field. */
N#define SPIS_AMOUNTTX_AMOUNTTX_Msk (0xFFUL << SPIS_AMOUNTTX_AMOUNTTX_Pos) /*!< Bit mask of AMOUNTTX field. */
N
N/* Register: SPIS_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 2 : Serial clock (SCK) polarity. */
N#define SPIS_CONFIG_CPOL_Pos (2UL) /*!< Position of CPOL field. */
N#define SPIS_CONFIG_CPOL_Msk (0x1UL << SPIS_CONFIG_CPOL_Pos) /*!< Bit mask of CPOL field. */
N#define SPIS_CONFIG_CPOL_ActiveHigh (0UL) /*!< Active high. */
N#define SPIS_CONFIG_CPOL_ActiveLow (1UL) /*!< Active low. */
N
N/* Bit 1 : Serial clock (SCK) phase. */
N#define SPIS_CONFIG_CPHA_Pos (1UL) /*!< Position of CPHA field. */
N#define SPIS_CONFIG_CPHA_Msk (0x1UL << SPIS_CONFIG_CPHA_Pos) /*!< Bit mask of CPHA field. */
N#define SPIS_CONFIG_CPHA_Leading (0UL) /*!< Sample on leading edge of the clock. Shift serial data on trailing edge. */
N#define SPIS_CONFIG_CPHA_Trailing (1UL) /*!< Sample on trailing edge of the clock. Shift serial data on leading edge. */
N
N/* Bit 0 : Bit order. */
N#define SPIS_CONFIG_ORDER_Pos (0UL) /*!< Position of ORDER field. */
N#define SPIS_CONFIG_ORDER_Msk (0x1UL << SPIS_CONFIG_ORDER_Pos) /*!< Bit mask of ORDER field. */
N#define SPIS_CONFIG_ORDER_MsbFirst (0UL) /*!< Most significant bit transmitted out first. */
N#define SPIS_CONFIG_ORDER_LsbFirst (1UL) /*!< Least significant bit transmitted out first. */
N
N/* Register: SPIS_DEF */
N/* Description: Default character. */
N
N/* Bits 7..0 : Default character. */
N#define SPIS_DEF_DEF_Pos (0UL) /*!< Position of DEF field. */
N#define SPIS_DEF_DEF_Msk (0xFFUL << SPIS_DEF_DEF_Pos) /*!< Bit mask of DEF field. */
N
N/* Register: SPIS_ORC */
N/* Description: Over-read character. */
N
N/* Bits 7..0 : Over-read character. */
N#define SPIS_ORC_ORC_Pos (0UL) /*!< Position of ORC field. */
N#define SPIS_ORC_ORC_Msk (0xFFUL << SPIS_ORC_ORC_Pos) /*!< Bit mask of ORC field. */
N
N/* Register: SPIS_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define SPIS_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define SPIS_POWER_POWER_Msk (0x1UL << SPIS_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define SPIS_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define SPIS_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TEMP */
N/* Description: Temperature Sensor. */
N
N/* Register: TEMP_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on DATARDY event. */
N#define TEMP_INTENSET_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Msk (0x1UL << TEMP_INTENSET_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENSET_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENSET_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENSET_DATARDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TEMP_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on DATARDY event. */
N#define TEMP_INTENCLR_DATARDY_Pos (0UL) /*!< Position of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Msk (0x1UL << TEMP_INTENCLR_DATARDY_Pos) /*!< Bit mask of DATARDY field. */
N#define TEMP_INTENCLR_DATARDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TEMP_INTENCLR_DATARDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TEMP_INTENCLR_DATARDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TEMP_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TEMP_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TEMP_POWER_POWER_Msk (0x1UL << TEMP_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TEMP_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TEMP_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TIMER */
N/* Description: Timer 0. */
N
N/* Register: TIMER_SHORTS */
N/* Description: Shortcuts for Timer. */
N
N/* Bit 11 : Shortcut between CC[3] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE3_STOP_Pos (11UL) /*!< Position of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE3_STOP_Pos) /*!< Bit mask of COMPARE3_STOP field. */
N#define TIMER_SHORTS_COMPARE3_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 10 : Shortcut between CC[2] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE2_STOP_Pos (10UL) /*!< Position of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE2_STOP_Pos) /*!< Bit mask of COMPARE2_STOP field. */
N#define TIMER_SHORTS_COMPARE2_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 9 : Shortcut between CC[1] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE1_STOP_Pos (9UL) /*!< Position of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE1_STOP_Pos) /*!< Bit mask of COMPARE1_STOP field. */
N#define TIMER_SHORTS_COMPARE1_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 8 : Shortcut between CC[0] event and the STOP task. */
N#define TIMER_SHORTS_COMPARE0_STOP_Pos (8UL) /*!< Position of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Msk (0x1UL << TIMER_SHORTS_COMPARE0_STOP_Pos) /*!< Bit mask of COMPARE0_STOP field. */
N#define TIMER_SHORTS_COMPARE0_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 3 : Shortcut between CC[3] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Pos (3UL) /*!< Position of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE3_CLEAR_Pos) /*!< Bit mask of COMPARE3_CLEAR field. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE3_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 2 : Shortcut between CC[2] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Pos (2UL) /*!< Position of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE2_CLEAR_Pos) /*!< Bit mask of COMPARE2_CLEAR field. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE2_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 1 : Shortcut between CC[1] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Pos (1UL) /*!< Position of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE1_CLEAR_Pos) /*!< Bit mask of COMPARE1_CLEAR field. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE1_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between CC[0] event and the CLEAR task. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Pos (0UL) /*!< Position of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Msk (0x1UL << TIMER_SHORTS_COMPARE0_CLEAR_Pos) /*!< Bit mask of COMPARE0_CLEAR field. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Disabled (0UL) /*!< Shortcut disabled. */
N#define TIMER_SHORTS_COMPARE0_CLEAR_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TIMER_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 19 : Enable interrupt on COMPARE[3] */
N#define TIMER_INTENSET_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Msk (0x1UL << TIMER_INTENSET_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENSET_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE3_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 18 : Enable interrupt on COMPARE[2] */
N#define TIMER_INTENSET_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Msk (0x1UL << TIMER_INTENSET_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENSET_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE2_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 17 : Enable interrupt on COMPARE[1] */
N#define TIMER_INTENSET_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Msk (0x1UL << TIMER_INTENSET_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENSET_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE1_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 16 : Enable interrupt on COMPARE[0] */
N#define TIMER_INTENSET_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Msk (0x1UL << TIMER_INTENSET_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENSET_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENSET_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENSET_COMPARE0_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TIMER_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 19 : Disable interrupt on COMPARE[3] */
N#define TIMER_INTENCLR_COMPARE3_Pos (19UL) /*!< Position of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Msk (0x1UL << TIMER_INTENCLR_COMPARE3_Pos) /*!< Bit mask of COMPARE3 field. */
N#define TIMER_INTENCLR_COMPARE3_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE3_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE3_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 18 : Disable interrupt on COMPARE[2] */
N#define TIMER_INTENCLR_COMPARE2_Pos (18UL) /*!< Position of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Msk (0x1UL << TIMER_INTENCLR_COMPARE2_Pos) /*!< Bit mask of COMPARE2 field. */
N#define TIMER_INTENCLR_COMPARE2_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE2_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE2_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 17 : Disable interrupt on COMPARE[1] */
N#define TIMER_INTENCLR_COMPARE1_Pos (17UL) /*!< Position of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Msk (0x1UL << TIMER_INTENCLR_COMPARE1_Pos) /*!< Bit mask of COMPARE1 field. */
N#define TIMER_INTENCLR_COMPARE1_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE1_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE1_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 16 : Disable interrupt on COMPARE[0] */
N#define TIMER_INTENCLR_COMPARE0_Pos (16UL) /*!< Position of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Msk (0x1UL << TIMER_INTENCLR_COMPARE0_Pos) /*!< Bit mask of COMPARE0 field. */
N#define TIMER_INTENCLR_COMPARE0_Disabled (0UL) /*!< Interrupt disabled. */
N#define TIMER_INTENCLR_COMPARE0_Enabled (1UL) /*!< Interrupt enabled. */
N#define TIMER_INTENCLR_COMPARE0_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TIMER_MODE */
N/* Description: Timer Mode selection. */
N
N/* Bit 0 : Select Normal or Counter mode. */
N#define TIMER_MODE_MODE_Pos (0UL) /*!< Position of MODE field. */
N#define TIMER_MODE_MODE_Msk (0x1UL << TIMER_MODE_MODE_Pos) /*!< Bit mask of MODE field. */
N#define TIMER_MODE_MODE_Timer (0UL) /*!< Timer in Normal mode. */
N#define TIMER_MODE_MODE_Counter (1UL) /*!< Timer in Counter mode. */
N
N/* Register: TIMER_BITMODE */
N/* Description: Sets timer behaviour. */
N
N/* Bits 1..0 : Sets timer behaviour ro be like the implementation of a timer with width as indicated. */
N#define TIMER_BITMODE_BITMODE_Pos (0UL) /*!< Position of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_Msk (0x3UL << TIMER_BITMODE_BITMODE_Pos) /*!< Bit mask of BITMODE field. */
N#define TIMER_BITMODE_BITMODE_16Bit (0x00UL) /*!< 16-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_08Bit (0x01UL) /*!< 8-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_24Bit (0x02UL) /*!< 24-bit timer behaviour. */
N#define TIMER_BITMODE_BITMODE_32Bit (0x03UL) /*!< 32-bit timer behaviour. */
N
N/* Register: TIMER_PRESCALER */
N/* Description: 4-bit prescaler to source clock frequency (max value 9). Source clock frequency is divided by 2^SCALE. */
N
N/* Bits 3..0 : Timer PRESCALER value. Max value is 9. */
N#define TIMER_PRESCALER_PRESCALER_Pos (0UL) /*!< Position of PRESCALER field. */
N#define TIMER_PRESCALER_PRESCALER_Msk (0xFUL << TIMER_PRESCALER_PRESCALER_Pos) /*!< Bit mask of PRESCALER field. */
N
N/* Register: TIMER_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TIMER_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TIMER_POWER_POWER_Msk (0x1UL << TIMER_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TIMER_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TIMER_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: TWI */
N/* Description: Two-wire interface master 0. */
N
N/* Register: TWI_SHORTS */
N/* Description: Shortcuts for TWI. */
N
N/* Bit 1 : Shortcut between BB event and the STOP task. */
N#define TWI_SHORTS_BB_STOP_Pos (1UL) /*!< Position of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Msk (0x1UL << TWI_SHORTS_BB_STOP_Pos) /*!< Bit mask of BB_STOP field. */
N#define TWI_SHORTS_BB_STOP_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_STOP_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Bit 0 : Shortcut between BB event and the SUSPEND task. */
N#define TWI_SHORTS_BB_SUSPEND_Pos (0UL) /*!< Position of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Msk (0x1UL << TWI_SHORTS_BB_SUSPEND_Pos) /*!< Bit mask of BB_SUSPEND field. */
N#define TWI_SHORTS_BB_SUSPEND_Disabled (0UL) /*!< Shortcut disabled. */
N#define TWI_SHORTS_BB_SUSPEND_Enabled (1UL) /*!< Shortcut enabled. */
N
N/* Register: TWI_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 14 : Enable interrupt on BB event. */
N#define TWI_INTENSET_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENSET_BB_Msk (0x1UL << TWI_INTENSET_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENSET_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_BB_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define TWI_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENSET_ERROR_Msk (0x1UL << TWI_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXDSENT event. */
N#define TWI_INTENSET_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Msk (0x1UL << TWI_INTENSET_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENSET_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_TXDSENT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on READY event. */
N#define TWI_INTENSET_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Msk (0x1UL << TWI_INTENSET_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENSET_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_RXDREADY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 1 : Enable interrupt on STOPPED event. */
N#define TWI_INTENSET_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Msk (0x1UL << TWI_INTENSET_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENSET_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENSET_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENSET_STOPPED_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: TWI_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 14 : Disable interrupt on BB event. */
N#define TWI_INTENCLR_BB_Pos (14UL) /*!< Position of BB field. */
N#define TWI_INTENCLR_BB_Msk (0x1UL << TWI_INTENCLR_BB_Pos) /*!< Bit mask of BB field. */
N#define TWI_INTENCLR_BB_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_BB_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_BB_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define TWI_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define TWI_INTENCLR_ERROR_Msk (0x1UL << TWI_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define TWI_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXDSENT event. */
N#define TWI_INTENCLR_TXDSENT_Pos (7UL) /*!< Position of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Msk (0x1UL << TWI_INTENCLR_TXDSENT_Pos) /*!< Bit mask of TXDSENT field. */
N#define TWI_INTENCLR_TXDSENT_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_TXDSENT_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_TXDSENT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXDREADY event. */
N#define TWI_INTENCLR_RXDREADY_Pos (2UL) /*!< Position of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Msk (0x1UL << TWI_INTENCLR_RXDREADY_Pos) /*!< Bit mask of RXDREADY field. */
N#define TWI_INTENCLR_RXDREADY_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_RXDREADY_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_RXDREADY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 1 : Disable interrupt on STOPPED event. */
N#define TWI_INTENCLR_STOPPED_Pos (1UL) /*!< Position of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Msk (0x1UL << TWI_INTENCLR_STOPPED_Pos) /*!< Bit mask of STOPPED field. */
N#define TWI_INTENCLR_STOPPED_Disabled (0UL) /*!< Interrupt disabled. */
N#define TWI_INTENCLR_STOPPED_Enabled (1UL) /*!< Interrupt enabled. */
N#define TWI_INTENCLR_STOPPED_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: TWI_ERRORSRC */
N/* Description: Two-wire error source. Write error field to 1 to clear error. */
N
N/* Bit 2 : NACK received after sending a data byte. */
N#define TWI_ERRORSRC_DNACK_Pos (2UL) /*!< Position of DNACK field. */
N#define TWI_ERRORSRC_DNACK_Msk (0x1UL << TWI_ERRORSRC_DNACK_Pos) /*!< Bit mask of DNACK field. */
N#define TWI_ERRORSRC_DNACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_DNACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_DNACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : NACK received after sending the address. */
N#define TWI_ERRORSRC_ANACK_Pos (1UL) /*!< Position of ANACK field. */
N#define TWI_ERRORSRC_ANACK_Msk (0x1UL << TWI_ERRORSRC_ANACK_Pos) /*!< Bit mask of ANACK field. */
N#define TWI_ERRORSRC_ANACK_NotPresent (0UL) /*!< Error not present. */
N#define TWI_ERRORSRC_ANACK_Present (1UL) /*!< Error present. */
N#define TWI_ERRORSRC_ANACK_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: TWI_ENABLE */
N/* Description: Enable two-wire master. */
N
N/* Bits 2..0 : Enable or disable W2M */
N#define TWI_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Msk (0x7UL << TWI_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define TWI_ENABLE_ENABLE_Disabled (0x00UL) /*!< Disabled. */
N#define TWI_ENABLE_ENABLE_Enabled (0x05UL) /*!< Enabled. */
N
N/* Register: TWI_RXD */
N/* Description: RX data register. */
N
N/* Bits 7..0 : RX data from last transfer. */
N#define TWI_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define TWI_RXD_RXD_Msk (0xFFUL << TWI_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: TWI_TXD */
N/* Description: TX data register. */
N
N/* Bits 7..0 : TX data for next transfer. */
N#define TWI_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define TWI_TXD_TXD_Msk (0xFFUL << TWI_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: TWI_FREQUENCY */
N/* Description: Two-wire frequency. */
N
N/* Bits 31..0 : Two-wire master clock frequency. */
N#define TWI_FREQUENCY_FREQUENCY_Pos (0UL) /*!< Position of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_Msk (0xFFFFFFFFUL << TWI_FREQUENCY_FREQUENCY_Pos) /*!< Bit mask of FREQUENCY field. */
N#define TWI_FREQUENCY_FREQUENCY_K100 (0x01980000UL) /*!< 100 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K250 (0x04000000UL) /*!< 250 kbps. */
N#define TWI_FREQUENCY_FREQUENCY_K400 (0x06680000UL) /*!< 400 kbps. */
N
N/* Register: TWI_ADDRESS */
N/* Description: Address used in the two-wire transfer. */
N
N/* Bits 6..0 : Two-wire address. */
N#define TWI_ADDRESS_ADDRESS_Pos (0UL) /*!< Position of ADDRESS field. */
N#define TWI_ADDRESS_ADDRESS_Msk (0x7FUL << TWI_ADDRESS_ADDRESS_Pos) /*!< Bit mask of ADDRESS field. */
N
N/* Register: TWI_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define TWI_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define TWI_POWER_POWER_Msk (0x1UL << TWI_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define TWI_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define TWI_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UART */
N/* Description: Universal Asynchronous Receiver/Transmitter, version 1.0. */
N
N/* Register: UART_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 17 : Enable interrupt on RXTO event. */
N#define UART_INTENSET_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENSET_RXTO_Msk (0x1UL << UART_INTENSET_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENSET_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXTO_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 9 : Enable interrupt on ERROR event. */
N#define UART_INTENSET_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENSET_ERROR_Msk (0x1UL << UART_INTENSET_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENSET_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_ERROR_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 7 : Enable interrupt on TXRDY event. */
N#define UART_INTENSET_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Msk (0x1UL << UART_INTENSET_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENSET_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_TXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Bit 2 : Enable interrupt on RXRDY event. */
N#define UART_INTENSET_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Msk (0x1UL << UART_INTENSET_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENSET_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENSET_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENSET_RXDRDY_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: UART_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 17 : Disable interrupt on RXTO event. */
N#define UART_INTENCLR_RXTO_Pos (17UL) /*!< Position of RXTO field. */
N#define UART_INTENCLR_RXTO_Msk (0x1UL << UART_INTENCLR_RXTO_Pos) /*!< Bit mask of RXTO field. */
N#define UART_INTENCLR_RXTO_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXTO_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXTO_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 9 : Disable interrupt on ERROR event. */
N#define UART_INTENCLR_ERROR_Pos (9UL) /*!< Position of ERROR field. */
N#define UART_INTENCLR_ERROR_Msk (0x1UL << UART_INTENCLR_ERROR_Pos) /*!< Bit mask of ERROR field. */
N#define UART_INTENCLR_ERROR_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_ERROR_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_ERROR_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 7 : Disable interrupt on TXRDY event. */
N#define UART_INTENCLR_TXDRDY_Pos (7UL) /*!< Position of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Msk (0x1UL << UART_INTENCLR_TXDRDY_Pos) /*!< Bit mask of TXDRDY field. */
N#define UART_INTENCLR_TXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_TXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_TXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Bit 2 : Disable interrupt on RXRDY event. */
N#define UART_INTENCLR_RXDRDY_Pos (2UL) /*!< Position of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Msk (0x1UL << UART_INTENCLR_RXDRDY_Pos) /*!< Bit mask of RXDRDY field. */
N#define UART_INTENCLR_RXDRDY_Disabled (0UL) /*!< Interrupt disabled. */
N#define UART_INTENCLR_RXDRDY_Enabled (1UL) /*!< Interrupt enabled. */
N#define UART_INTENCLR_RXDRDY_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: UART_ERRORSRC */
N/* Description: Error source. Write error field to 1 to clear error. */
N
N/* Bit 3 : The serial data input is '0' for longer than the length of a data frame. */
N#define UART_ERRORSRC_BREAK_Pos (3UL) /*!< Position of BREAK field. */
N#define UART_ERRORSRC_BREAK_Msk (0x1UL << UART_ERRORSRC_BREAK_Pos) /*!< Bit mask of BREAK field. */
N#define UART_ERRORSRC_BREAK_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_BREAK_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_BREAK_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 2 : A valid stop bit is not detected on the serial data input after all bits in a character have been received. */
N#define UART_ERRORSRC_FRAMING_Pos (2UL) /*!< Position of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_Msk (0x1UL << UART_ERRORSRC_FRAMING_Pos) /*!< Bit mask of FRAMING field. */
N#define UART_ERRORSRC_FRAMING_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_FRAMING_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_FRAMING_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 1 : A character with bad parity is received. Only checked if HW parity control is enabled. */
N#define UART_ERRORSRC_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_ERRORSRC_PARITY_Msk (0x1UL << UART_ERRORSRC_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_ERRORSRC_PARITY_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_PARITY_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_PARITY_Clear (1UL) /*!< Clear error on write. */
N
N/* Bit 0 : A start bit is received while the previous data still lies in RXD. (Data loss). */
N#define UART_ERRORSRC_OVERRUN_Pos (0UL) /*!< Position of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_Msk (0x1UL << UART_ERRORSRC_OVERRUN_Pos) /*!< Bit mask of OVERRUN field. */
N#define UART_ERRORSRC_OVERRUN_NotPresent (0UL) /*!< Error not present. */
N#define UART_ERRORSRC_OVERRUN_Present (1UL) /*!< Error present. */
N#define UART_ERRORSRC_OVERRUN_Clear (1UL) /*!< Clear error on write. */
N
N/* Register: UART_ENABLE */
N/* Description: Enable UART and acquire IOs. */
N
N/* Bits 2..0 : Enable or disable UART and acquire IOs. */
N#define UART_ENABLE_ENABLE_Pos (0UL) /*!< Position of ENABLE field. */
N#define UART_ENABLE_ENABLE_Msk (0x7UL << UART_ENABLE_ENABLE_Pos) /*!< Bit mask of ENABLE field. */
N#define UART_ENABLE_ENABLE_Disabled (0x00UL) /*!< UART disabled. */
N#define UART_ENABLE_ENABLE_Enabled (0x04UL) /*!< UART enabled. */
N
N/* Register: UART_RXD */
N/* Description: RXD register. On read action the buffer pointer is displaced. Once read the character is consummed. If read when no character available, the UART will stop working. */
N
N/* Bits 7..0 : RX data from previous transfer. Double buffered. */
N#define UART_RXD_RXD_Pos (0UL) /*!< Position of RXD field. */
N#define UART_RXD_RXD_Msk (0xFFUL << UART_RXD_RXD_Pos) /*!< Bit mask of RXD field. */
N
N/* Register: UART_TXD */
N/* Description: TXD register. */
N
N/* Bits 7..0 : TX data for transfer. */
N#define UART_TXD_TXD_Pos (0UL) /*!< Position of TXD field. */
N#define UART_TXD_TXD_Msk (0xFFUL << UART_TXD_TXD_Pos) /*!< Bit mask of TXD field. */
N
N/* Register: UART_BAUDRATE */
N/* Description: UART Baudrate. */
N
N/* Bits 31..0 : UART baudrate. */
N#define UART_BAUDRATE_BAUDRATE_Pos (0UL) /*!< Position of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Msk (0xFFFFFFFFUL << UART_BAUDRATE_BAUDRATE_Pos) /*!< Bit mask of BAUDRATE field. */
N#define UART_BAUDRATE_BAUDRATE_Baud1200 (0x0004F000UL) /*!< 1200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud2400 (0x0009D000UL) /*!< 2400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud4800 (0x0013B000UL) /*!< 4800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud9600 (0x00275000UL) /*!< 9600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud14400 (0x003B0000UL) /*!< 14400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud19200 (0x004EA000UL) /*!< 19200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud28800 (0x0075F000UL) /*!< 28800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud38400 (0x009D5000UL) /*!< 38400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud57600 (0x00EBF000UL) /*!< 57600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud76800 (0x013A9000UL) /*!< 76800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud115200 (0x01D7E000UL) /*!< 115200 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud230400 (0x03AFB000UL) /*!< 230400 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud250000 (0x04000000UL) /*!< 250000 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud460800 (0x075F7000UL) /*!< 460800 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud921600 (0x0EBEDFA4UL) /*!< 921600 baud. */
N#define UART_BAUDRATE_BAUDRATE_Baud1M (0x10000000UL) /*!< 1M baud. */
N
N/* Register: UART_CONFIG */
N/* Description: Configuration of parity and hardware flow control register. */
N
N/* Bits 3..1 : Include parity bit. */
N#define UART_CONFIG_PARITY_Pos (1UL) /*!< Position of PARITY field. */
N#define UART_CONFIG_PARITY_Msk (0x7UL << UART_CONFIG_PARITY_Pos) /*!< Bit mask of PARITY field. */
N#define UART_CONFIG_PARITY_Excluded (0UL) /*!< Parity bit excluded. */
N#define UART_CONFIG_PARITY_Included (7UL) /*!< Parity bit included. */
N
N/* Bit 0 : Hardware flow control. */
N#define UART_CONFIG_HWFC_Pos (0UL) /*!< Position of HWFC field. */
N#define UART_CONFIG_HWFC_Msk (0x1UL << UART_CONFIG_HWFC_Pos) /*!< Bit mask of HWFC field. */
N#define UART_CONFIG_HWFC_Disabled (0UL) /*!< Hardware flow control disabled. */
N#define UART_CONFIG_HWFC_Enabled (1UL) /*!< Hardware flow control enabled. */
N
N/* Register: UART_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define UART_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define UART_POWER_POWER_Msk (0x1UL << UART_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define UART_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define UART_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/* Peripheral: UICR */
N/* Description: User Information Configuration. */
N
N/* Register: UICR_RBPCONF */
N/* Description: Readback protection configuration. */
N
N/* Bits 15..8 : Readback protect all code in the device. */
N#define UICR_RBPCONF_PALL_Pos (8UL) /*!< Position of PALL field. */
N#define UICR_RBPCONF_PALL_Msk (0xFFUL << UICR_RBPCONF_PALL_Pos) /*!< Bit mask of PALL field. */
N#define UICR_RBPCONF_PALL_Disabled (0xFFUL) /*!< Disabled. */
N#define UICR_RBPCONF_PALL_Enabled (0x00UL) /*!< Enabled. */
N
N/* Bits 7..0 : Readback protect region 0. Will be ignored if pre-programmed factory code is present on the chip. */
N#define UICR_RBPCONF_PR0_Pos (0UL) /*!< Position of PR0 field. */
N#define UICR_RBPCONF_PR0_Msk (0xFFUL << UICR_RBPCONF_PR0_Pos) /*!< Bit mask of PR0 field. */
N#define UICR_RBPCONF_PR0_Disabled (0xFFUL) /*!< Disabled. */
N#define UICR_RBPCONF_PR0_Enabled (0x00UL) /*!< Enabled. */
N
N/* Register: UICR_XTALFREQ */
N/* Description: Reset value for CLOCK XTALFREQ register. */
N
N/* Bits 7..0 : Reset value for CLOCK XTALFREQ register. */
N#define UICR_XTALFREQ_XTALFREQ_Pos (0UL) /*!< Position of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_Msk (0xFFUL << UICR_XTALFREQ_XTALFREQ_Pos) /*!< Bit mask of XTALFREQ field. */
N#define UICR_XTALFREQ_XTALFREQ_16MHz (0xFFUL) /*!< 16MHz Xtal is used. */
N#define UICR_XTALFREQ_XTALFREQ_32MHz (0x00UL) /*!< 32MHz Xtal is used. */
N
N/* Register: UICR_FWID */
N/* Description: Firmware ID. */
N
N/* Bits 15..0 : Identification number for the firmware loaded into the chip. */
N#define UICR_FWID_FWID_Pos (0UL) /*!< Position of FWID field. */
N#define UICR_FWID_FWID_Msk (0xFFFFUL << UICR_FWID_FWID_Pos) /*!< Bit mask of FWID field. */
N
N
N/* Peripheral: WDT */
N/* Description: Watchdog Timer. */
N
N/* Register: WDT_INTENSET */
N/* Description: Interrupt enable set register. */
N
N/* Bit 0 : Enable interrupt on TIMEOUT event. */
N#define WDT_INTENSET_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Msk (0x1UL << WDT_INTENSET_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENSET_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENSET_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENSET_TIMEOUT_Set (1UL) /*!< Enable interrupt on write. */
N
N/* Register: WDT_INTENCLR */
N/* Description: Interrupt enable clear register. */
N
N/* Bit 0 : Disable interrupt on TIMEOUT event. */
N#define WDT_INTENCLR_TIMEOUT_Pos (0UL) /*!< Position of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Msk (0x1UL << WDT_INTENCLR_TIMEOUT_Pos) /*!< Bit mask of TIMEOUT field. */
N#define WDT_INTENCLR_TIMEOUT_Disabled (0UL) /*!< Interrupt disabled. */
N#define WDT_INTENCLR_TIMEOUT_Enabled (1UL) /*!< Interrupt enabled. */
N#define WDT_INTENCLR_TIMEOUT_Clear (1UL) /*!< Disable interrupt on write. */
N
N/* Register: WDT_RUNSTATUS */
N/* Description: Watchdog running status. */
N
N/* Bit 0 : Watchdog running status. */
N#define WDT_RUNSTATUS_RUNSTATUS_Pos (0UL) /*!< Position of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_Msk (0x1UL << WDT_RUNSTATUS_RUNSTATUS_Pos) /*!< Bit mask of RUNSTATUS field. */
N#define WDT_RUNSTATUS_RUNSTATUS_NotRunning (0UL) /*!< Watchdog timer is not running. */
N#define WDT_RUNSTATUS_RUNSTATUS_Running (1UL) /*!< Watchdog timer is running. */
N
N/* Register: WDT_REQSTATUS */
N/* Description: Request status. */
N
N/* Bit 7 : Request status for RR[7]. */
N#define WDT_REQSTATUS_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_REQSTATUS_RR7_Msk (0x1UL << WDT_REQSTATUS_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_REQSTATUS_RR7_DisabledOrRequested (0UL) /*!< RR[7] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR7_EnabledAndUnrequested (1UL) /*!< RR[7] register is enabled and has not jet requested. */
N
N/* Bit 6 : Request status for RR[6]. */
N#define WDT_REQSTATUS_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_REQSTATUS_RR6_Msk (0x1UL << WDT_REQSTATUS_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_REQSTATUS_RR6_DisabledOrRequested (0UL) /*!< RR[6] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR6_EnabledAndUnrequested (1UL) /*!< RR[6] register is enabled and has not jet requested. */
N
N/* Bit 5 : Request status for RR[5]. */
N#define WDT_REQSTATUS_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_REQSTATUS_RR5_Msk (0x1UL << WDT_REQSTATUS_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_REQSTATUS_RR5_DisabledOrRequested (0UL) /*!< RR[5] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR5_EnabledAndUnrequested (1UL) /*!< RR[5] register is enabled and has not jet requested. */
N
N/* Bit 4 : Request status for RR[4]. */
N#define WDT_REQSTATUS_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_REQSTATUS_RR4_Msk (0x1UL << WDT_REQSTATUS_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_REQSTATUS_RR4_DisabledOrRequested (0UL) /*!< RR[4] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR4_EnabledAndUnrequested (1UL) /*!< RR[4] register is enabled and has not jet requested. */
N
N/* Bit 3 : Request status for RR[3]. */
N#define WDT_REQSTATUS_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_REQSTATUS_RR3_Msk (0x1UL << WDT_REQSTATUS_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_REQSTATUS_RR3_DisabledOrRequested (0UL) /*!< RR[3] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR3_EnabledAndUnrequested (1UL) /*!< RR[3] register is enabled and has not jet requested. */
N
N/* Bit 2 : Request status for RR[2]. */
N#define WDT_REQSTATUS_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_REQSTATUS_RR2_Msk (0x1UL << WDT_REQSTATUS_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_REQSTATUS_RR2_DisabledOrRequested (0UL) /*!< RR[2] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR2_EnabledAndUnrequested (1UL) /*!< RR[2] register is enabled and has not jet requested. */
N
N/* Bit 1 : Request status for RR[1]. */
N#define WDT_REQSTATUS_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_REQSTATUS_RR1_Msk (0x1UL << WDT_REQSTATUS_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_REQSTATUS_RR1_DisabledOrRequested (0UL) /*!< RR[1] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR1_EnabledAndUnrequested (1UL) /*!< RR[1] register is enabled and has not jet requested. */
N
N/* Bit 0 : Request status for RR[0]. */
N#define WDT_REQSTATUS_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_REQSTATUS_RR0_Msk (0x1UL << WDT_REQSTATUS_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_REQSTATUS_RR0_DisabledOrRequested (0UL) /*!< RR[0] register is not enabled or has already requested reload. */
N#define WDT_REQSTATUS_RR0_EnabledAndUnrequested (1UL) /*!< RR[0] register is enabled and has not jet requested. */
N
N/* Register: WDT_RREN */
N/* Description: Reload request enable. */
N
N/* Bit 7 : Enable or disable RR[7] register. */
N#define WDT_RREN_RR7_Pos (7UL) /*!< Position of RR7 field. */
N#define WDT_RREN_RR7_Msk (0x1UL << WDT_RREN_RR7_Pos) /*!< Bit mask of RR7 field. */
N#define WDT_RREN_RR7_Disabled (0UL) /*!< RR[7] register is disabled. */
N#define WDT_RREN_RR7_Enabled (1UL) /*!< RR[7] register is enabled. */
N
N/* Bit 6 : Enable or disable RR[6] register. */
N#define WDT_RREN_RR6_Pos (6UL) /*!< Position of RR6 field. */
N#define WDT_RREN_RR6_Msk (0x1UL << WDT_RREN_RR6_Pos) /*!< Bit mask of RR6 field. */
N#define WDT_RREN_RR6_Disabled (0UL) /*!< RR[6] register is disabled. */
N#define WDT_RREN_RR6_Enabled (1UL) /*!< RR[6] register is enabled. */
N
N/* Bit 5 : Enable or disable RR[5] register. */
N#define WDT_RREN_RR5_Pos (5UL) /*!< Position of RR5 field. */
N#define WDT_RREN_RR5_Msk (0x1UL << WDT_RREN_RR5_Pos) /*!< Bit mask of RR5 field. */
N#define WDT_RREN_RR5_Disabled (0UL) /*!< RR[5] register is disabled. */
N#define WDT_RREN_RR5_Enabled (1UL) /*!< RR[5] register is enabled. */
N
N/* Bit 4 : Enable or disable RR[4] register. */
N#define WDT_RREN_RR4_Pos (4UL) /*!< Position of RR4 field. */
N#define WDT_RREN_RR4_Msk (0x1UL << WDT_RREN_RR4_Pos) /*!< Bit mask of RR4 field. */
N#define WDT_RREN_RR4_Disabled (0UL) /*!< RR[4] register is disabled. */
N#define WDT_RREN_RR4_Enabled (1UL) /*!< RR[4] register is enabled. */
N
N/* Bit 3 : Enable or disable RR[3] register. */
N#define WDT_RREN_RR3_Pos (3UL) /*!< Position of RR3 field. */
N#define WDT_RREN_RR3_Msk (0x1UL << WDT_RREN_RR3_Pos) /*!< Bit mask of RR3 field. */
N#define WDT_RREN_RR3_Disabled (0UL) /*!< RR[3] register is disabled. */
N#define WDT_RREN_RR3_Enabled (1UL) /*!< RR[3] register is enabled. */
N
N/* Bit 2 : Enable or disable RR[2] register. */
N#define WDT_RREN_RR2_Pos (2UL) /*!< Position of RR2 field. */
N#define WDT_RREN_RR2_Msk (0x1UL << WDT_RREN_RR2_Pos) /*!< Bit mask of RR2 field. */
N#define WDT_RREN_RR2_Disabled (0UL) /*!< RR[2] register is disabled. */
N#define WDT_RREN_RR2_Enabled (1UL) /*!< RR[2] register is enabled. */
N
N/* Bit 1 : Enable or disable RR[1] register. */
N#define WDT_RREN_RR1_Pos (1UL) /*!< Position of RR1 field. */
N#define WDT_RREN_RR1_Msk (0x1UL << WDT_RREN_RR1_Pos) /*!< Bit mask of RR1 field. */
N#define WDT_RREN_RR1_Disabled (0UL) /*!< RR[1] register is disabled. */
N#define WDT_RREN_RR1_Enabled (1UL) /*!< RR[1] register is enabled. */
N
N/* Bit 0 : Enable or disable RR[0] register. */
N#define WDT_RREN_RR0_Pos (0UL) /*!< Position of RR0 field. */
N#define WDT_RREN_RR0_Msk (0x1UL << WDT_RREN_RR0_Pos) /*!< Bit mask of RR0 field. */
N#define WDT_RREN_RR0_Disabled (0UL) /*!< RR[0] register is disabled. */
N#define WDT_RREN_RR0_Enabled (1UL) /*!< RR[0] register is enabled. */
N
N/* Register: WDT_CONFIG */
N/* Description: Configuration register. */
N
N/* Bit 3 : Configure the watchdog to pause or not while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Pos (3UL) /*!< Position of HALT field. */
N#define WDT_CONFIG_HALT_Msk (0x1UL << WDT_CONFIG_HALT_Pos) /*!< Bit mask of HALT field. */
N#define WDT_CONFIG_HALT_Pause (0UL) /*!< Pause watchdog while the CPU is halted by the debugger. */
N#define WDT_CONFIG_HALT_Run (1UL) /*!< Do not pause watchdog while the CPU is halted by the debugger. */
N
N/* Bit 0 : Configure the watchdog to pause or not while the CPU is sleeping. */
N#define WDT_CONFIG_SLEEP_Pos (0UL) /*!< Position of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Msk (0x1UL << WDT_CONFIG_SLEEP_Pos) /*!< Bit mask of SLEEP field. */
N#define WDT_CONFIG_SLEEP_Pause (0UL) /*!< Pause watchdog while the CPU is asleep. */
N#define WDT_CONFIG_SLEEP_Run (1UL) /*!< Do not pause watchdog while the CPU is asleep. */
N
N/* Register: WDT_RR */
N/* Description: Reload requests registers. */
N
N/* Bits 31..0 : Reload register. */
N#define WDT_RR_RR_Pos (0UL) /*!< Position of RR field. */
N#define WDT_RR_RR_Msk (0xFFFFFFFFUL << WDT_RR_RR_Pos) /*!< Bit mask of RR field. */
N#define WDT_RR_RR_Reload (0x6E524635UL) /*!< Value to request a reload of the watchdog timer. */
N
N/* Register: WDT_POWER */
N/* Description: Peripheral power control. */
N
N/* Bit 0 : Peripheral power control. */
N#define WDT_POWER_POWER_Pos (0UL) /*!< Position of POWER field. */
N#define WDT_POWER_POWER_Msk (0x1UL << WDT_POWER_POWER_Pos) /*!< Bit mask of POWER field. */
N#define WDT_POWER_POWER_Disabled (0UL) /*!< Module power disabled. */
N#define WDT_POWER_POWER_Enabled (1UL) /*!< Module power enabled. */
N
N
N/*lint --flb "Leave library region" */
N#endif
L 25 "..\..\..\Software\Include\nrf_soc.h" 2
N#include "nrf_error_soc.h"
L 1 "..\..\..\Software\Include\nrf_error_soc.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup nrf_soc_api
N  @{
N  @defgroup nrf_soc_error SoC Library Error Codes
N  @{
N     
N  @brief Error definitions for the SoC library
N
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_SOC_H__
N#define NRF_ERROR_SOC_H__
N
N#include "nrf_error.h"
N
N/* Mutex Errors */
N#define NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN                 (NRF_ERROR_SOC_BASE_NUM + 0)  ///< Mutex already taken
N
N/* NVIC errors */
N#define NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE        (NRF_ERROR_SOC_BASE_NUM + 1)  ///< NVIC interrupt not available
N#define NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED (NRF_ERROR_SOC_BASE_NUM + 2)  ///< NVIC interrupt priority not allowed
N#define NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN              (NRF_ERROR_SOC_BASE_NUM + 3)  ///< NVIC should not return
N
N/* Power errors */
N#define NRF_ERROR_SOC_POWER_MODE_UNKNOWN                  (NRF_ERROR_SOC_BASE_NUM + 4)  ///< Power mode unknown
N#define NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN         (NRF_ERROR_SOC_BASE_NUM + 5)  ///< Power POF threshold unknown
N#define NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN         (NRF_ERROR_SOC_BASE_NUM + 6)  ///< Power off should not return
N
N/* Rand errors */
N#define NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES              (NRF_ERROR_SOC_BASE_NUM + 7)  ///< RAND not enough values
N
N/* PPI errors */
N#define NRF_ERROR_SOC_PPI_INVALID_CHANNEL                 (NRF_ERROR_SOC_BASE_NUM + 8)  ///< Invalid PPI Channel
N#define NRF_ERROR_SOC_PPI_INVALID_GROUP                   (NRF_ERROR_SOC_BASE_NUM + 9)  ///< Invalid PPI Group
N
N#endif // NRF_ERROR_SOC_H__
N/**
N  @}
N  @}
N*/
L 26 "..\..\..\Software\Include\nrf_soc.h" 2
N
N/** @addtogroup NRF_SOC_DEFINES Defines
N * @{ */
N
N/**@brief The number of the lowest SVC number reserved for the SoC library. */
N#define SOC_SVC_BASE 0x20
N
N/**@brief Guranteed time for application to process radio inactive notification. */
N#define NRF_RADIO_NOTIFICATION_INACTIVE_GUARANTEED_TIME_US   (62)
N
N#define SOC_ECB_KEY_LENGTH                   (16)                       /**< ECB key length. */
N#define SOC_ECB_CLEARTEXT_LENGTH             (16)                       /**< ECB cleartext length. */
N#define SOC_ECB_CIPHERTEXT_LENGTH            (SOC_ECB_CLEARTEXT_LENGTH) /**< ECB ciphertext length. */
N
N#define SD_EVENT_IRQn                 (SWI2_IRQn)       /**< SoftDevice Event IRQ number. Used for both protocol events and SoC events. */
N#define SD_EVENT_IRQHandler           (SWI2_IRQHandler) /**< SoftDevice Event IRQ handler. Used for both protocol events and SoC events. */
N#define RADIO_NOTIFICATION_IRQn       (SWI1_IRQn)       /**< The radio notification IRQ number. */
N#define RADIO_NOTIFICATION_IRQHandler (SWI1_IRQHandler) /**< The radio notification IRQ handler. */
N
N/** @} */
N
N/** @addtogroup NRF_SOC_TYPES Types
N * @{ */
N
N/**@brief The SVC numbers used by the SVC functions in the SoC library. */
Nenum NRF_SOC_SVCS
N{
N  SD_MUTEX_NEW = SOC_SVC_BASE,
X  SD_MUTEX_NEW = 0x20,
N  SD_MUTEX_ACQUIRE,
N  SD_MUTEX_RELEASE,
N  SD_NVIC_ENABLEIRQ,
N  SD_NVIC_DISABLEIRQ,
N  SD_NVIC_GETPENDINGIRQ,
N  SD_NVIC_SETPENDINGIRQ,
N  SD_NVIC_CLEARPENDINGIRQ,
N  SD_NVIC_SETPRIORITY,
N  SD_NVIC_GETPRIORITY,
N  SD_NVIC_SYSTEMRESET,
N  SD_NVIC_CRITICAL_REGION_ENTER,
N  SD_NVIC_CRITICAL_REGION_EXIT,
N  SD_RAND_APPLICATION_POOL_CAPACITY,
N  SD_RAND_APPLICATION_BYTES_AVAILABLE,
N  SD_RAND_APPLICATION_GET_VECTOR,
N  SD_POWER_MODE_SET,
N  SD_POWER_SYSTEM_OFF,
N  SD_POWER_RESET_REASON_GET,
N  SD_POWER_RESET_REASON_CLR,
N  SD_POWER_POF_ENABLE,
N  SD_POWER_POF_THRESHOLD_SET,
N  SD_POWER_RAMON_SET,
N  SD_POWER_RAMON_CLR,
N  SD_POWER_RAMON_GET,
N  SD_POWER_GPREGRET_SET,
N  SD_POWER_GPREGRET_CLR,
N  SD_POWER_GPREGRET_GET,
N  SD_POWER_DCDC_MODE_SET,
N  SD_APP_EVENT_WAIT,
N  SD_CLOCK_HFCLK_REQUEST,
N  SD_CLOCK_HFCLK_RELEASE,
N  SD_CLOCK_HFCLK_IS_RUNNING,
N  SD_PPI_CHANNEL_ENABLE_GET,
N  SD_PPI_CHANNEL_ENABLE_SET,
N  SD_PPI_CHANNEL_ENABLE_CLR,
N  SD_PPI_CHANNEL_ASSIGN,
N  SD_PPI_GROUP_TASK_ENABLE,
N  SD_PPI_GROUP_TASK_DISABLE,
N  SD_PPI_GROUP_ASSIGN,
N  SD_PPI_GROUP_GET,
N  SD_RADIO_NOTIFICATION_CFG_SET,
N  SD_ECB_BLOCK_ENCRYPT,
N  SD_EVENT_GET,
N
N  SVC_SOC_LAST
N};
N
N/**@brief Possible values of a ::nrf_mutex_t. */
Nenum NRF_MUTEX_VALUES
N{
N  NRF_MUTEX_FREE,
N  NRF_MUTEX_TAKEN
N};
N
N/**@brief Possible values of ::nrf_app_irq_priority_t. */
Nenum NRF_APP_PRIORITIES
N{
N  NRF_APP_PRIORITY_HIGH = 1,
N  NRF_APP_PRIORITY_LOW = 3
N};
N
N/**@brief Possible values of ::nrf_power_mode_t. */
Nenum NRF_POWER_MODES
N{
N  NRF_POWER_MODE_CONSTLAT,  /**< Constant latency mode. See power management in the reference manual. */
N  NRF_POWER_MODE_LOWPWR     /**< Low power mode. See power management in the reference manual. */
N};
N
N
N/**@brief Possible values of ::nrf_power_failure_threshold_t */
Nenum NRF_POWER_THRESHOLDS
N{
N  NRF_POWER_THRESHOLD_V21,  /**< 2.1 Volts power failure threshold. */
N  NRF_POWER_THRESHOLD_V23,  /**< 2.3 Volts power failure threshold. */
N  NRF_POWER_THRESHOLD_V25,  /**< 2.5 Volts power failure threshold. */ 
N  NRF_POWER_THRESHOLD_V27   /**< 2.7 Volts power failure threshold. */
N};
N
N
N/**@brief Possible values of ::nrf_power_dcdc_mode_t. */
Nenum NRF_POWER_DCDC_MODES
N{
N  NRF_POWER_DCDC_MODE_OFF,          /**< The DCDC is always off. */
N  NRF_POWER_DCDC_MODE_ON,           /**< The DCDC is always on. */
N  NRF_POWER_DCDC_MODE_AUTOMATIC     /**< The DCDC is automatically managed. */
N};
N
N/**@brief Possible values of ::nrf_radio_notification_distance_t. */
Nenum NRF_RADIO_NOTIFICATION_DISTANCES
N{
N  NRF_RADIO_NOTIFICATION_DISTANCE_NONE = 0, /**< The event does not have a notification. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_800US,    /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_1740US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_2680US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_3620US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_4560US,   /**< The distance from the active notification to start of radio activity. */
N  NRF_RADIO_NOTIFICATION_DISTANCE_5500US    /**< The distance from the active notification to start of radio activity. */
N};
N
N
N/**@brief Possible values of ::nrf_radio_notification_type_t. */
Nenum NRF_RADIO_NOTIFICATION_TYPES
N{
N  NRF_RADIO_NOTIFICATION_TYPE_NONE = 0,        /**< The event does not have a radio notification signal. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_ACTIVE,   /**< Using interrupt for notification when the radio will be enabled. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE, /**< Using interrupt for notification when the radio has been disabled. */
N  NRF_RADIO_NOTIFICATION_TYPE_INT_ON_BOTH,     /**< Using interrupt for notification both when the radio will be enabled and disabled. */
N};
N
N/**@brief SoC Events. */
Nenum NRF_SOC_EVENTS
N{
N  NRF_EVENT_HFCLKSTARTED,                       /**< Event indicating that the HFCLK has started. */
N  NRF_EVENT_POWER_FAILURE_WARNING,              /**< Event indicating that a power failure warning has occurred. */
N  NRF_EVENT_NUMBER_OF_EVENTS
N};
N
N/** @} */
N
N/** @addtogroup NRF_SOC_TYPES Types
N * @{ */
N
N/**@brief Represents a mutex for use with the nrf_mutex functions.
N * @note Accessing the value directly is not safe, use the mutex functions!
N */
Ntypedef volatile uint8_t nrf_mutex_t;
N
N/**@brief The interrupt priorities available to the application while the softdevice is active. */
Ntypedef uint8_t nrf_app_irq_priority_t;
N
N/**@brief Represents a power mode, used in power mode functions */
Ntypedef uint8_t nrf_power_mode_t;
N
N/**@brief Represents a power failure threshold value. */
Ntypedef uint8_t nrf_power_failure_threshold_t;
N
N/**@brief Represents a DCDC mode value. */
Ntypedef uint32_t nrf_power_dcdc_mode_t;
N
N/**@brief Radio notification distances. */
Ntypedef uint8_t nrf_radio_notification_distance_t;
N
N/**@brief Radio notification types. */
Ntypedef uint8_t nrf_radio_notification_type_t;
N
N
N/**@brief AES ECB data structure */
Ntypedef struct
N{
N  uint8_t key[SOC_ECB_KEY_LENGTH];                /**< Encryption key. */
X  uint8_t key[(16)];                 
N  uint8_t cleartext[SOC_ECB_CLEARTEXT_LENGTH];    /**< Clear Text data. */
X  uint8_t cleartext[(16)];     
N  uint8_t ciphertext[SOC_ECB_CIPHERTEXT_LENGTH];  /**< Cipher Text data. */
X  uint8_t ciphertext[((16))];   
N} nrf_ecb_hal_data_t;
N
N/** @} */
N
N/** @addtogroup NRF_SOC_FUNCTIONS Functions
N * @{ */
N
N/**@brief Initialize a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to initialize.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_MUTEX_NEW, uint32_t, sd_mutex_new(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_NEW) sd_mutex_new(nrf_mutex_t * p_mutex);
N
N/**@brief Attempt to acquire a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to acquire.
N *
N * @retval ::NRF_SUCCESS The mutex was successfully acquired.
N * @retval ::NRF_ERROR_SOC_MUTEX_ALREADY_TAKEN The mutex could not be acquired.
N */
NSVCALL(SD_MUTEX_ACQUIRE, uint32_t, sd_mutex_acquire(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_ACQUIRE) sd_mutex_acquire(nrf_mutex_t * p_mutex);
N
N/**@brief Release a mutex.
N *
N * @param[in] p_mutex Pointer to the mutex to release.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_MUTEX_RELEASE, uint32_t, sd_mutex_release(nrf_mutex_t * p_mutex));
Xuint32_t __svc(SD_MUTEX_RELEASE) sd_mutex_release(nrf_mutex_t * p_mutex);
N
N/**@brief Enable External Interrupt.
N * @note Corresponds to NVIC_EnableIRQ in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in] IRQn See the NVIC_EnableIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt was enabled.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt has a priority not available for the application.
N */
NSVCALL(SD_NVIC_ENABLEIRQ, uint32_t, sd_nvic_EnableIRQ(IRQn_Type IRQn));
Xuint32_t __svc(SD_NVIC_ENABLEIRQ) sd_nvic_EnableIRQ(IRQn_Type IRQn);
N
N/**@brief  Disable External Interrupt.
N * @note Corresponds to NVIC_DisableIRQ in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in] IRQn See the NVIC_DisableIRQ documentation in CMSIS
N *
N * @retval ::NRF_SUCCESS The interrupt was disabled.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE The interrupt is not available for the application.
N */
NSVCALL(SD_NVIC_DISABLEIRQ, uint32_t, sd_nvic_DisableIRQ(IRQn_Type IRQn));
Xuint32_t __svc(SD_NVIC_DISABLEIRQ) sd_nvic_DisableIRQ(IRQn_Type IRQn);
N
N/**@brief  Get Pending Interrupt.
N * @note Corresponds to NVIC_GetPendingIRQ in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in]   IRQn          See the NVIC_GetPendingIRQ documentation in CMSIS.
N * @param[out]  p_pending_irq Return value from NVIC_GetPendingIRQ.
N *
N * @retval ::NRF_SUCCESS The interrupt is available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
NSVCALL(SD_NVIC_GETPENDINGIRQ, uint32_t, sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq));
Xuint32_t __svc(SD_NVIC_GETPENDINGIRQ) sd_nvic_GetPendingIRQ(IRQn_Type IRQn, uint32_t * p_pending_irq);
N
N/**@brief  Set Pending Interrupt.
N * @note Corresponds to NVIC_SetPendingIRQ in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in] IRQn See the NVIC_SetPendingIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt is set pending.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
NSVCALL(SD_NVIC_SETPENDINGIRQ, uint32_t, sd_nvic_SetPendingIRQ(IRQn_Type IRQn));
Xuint32_t __svc(SD_NVIC_SETPENDINGIRQ) sd_nvic_SetPendingIRQ(IRQn_Type IRQn);
N
N/**@brief  Clear Pending Interrupt.
N * @note Corresponds to NVIC_ClearPendingIRQ in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in] IRQn See the NVIC_ClearPendingIRQ documentation in CMSIS.
N *
N * @retval ::NRF_SUCCESS The interrupt pending flag is cleared.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N */
NSVCALL(SD_NVIC_CLEARPENDINGIRQ, uint32_t, sd_nvic_ClearPendingIRQ(IRQn_Type IRQn));
Xuint32_t __svc(SD_NVIC_CLEARPENDINGIRQ) sd_nvic_ClearPendingIRQ(IRQn_Type IRQn);
N
N/**@brief Set Interrupt Priority.
N * @note Corresponds to NVIC_SetPriority in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N * @pre{priority is valid and not reserved by the stack}
N *
N * @param[in] IRQn      See the NVIC_SetPriority documentation in CMSIS.
N * @param[in] priority  A valid IRQ priority for use by the application.
N *
N * @retval ::NRF_SUCCESS The interrupt and priority level is available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE IRQn is not available for the application.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_PRIORITY_NOT_ALLOWED The interrupt priority is not available for the application.
N */
NSVCALL(SD_NVIC_SETPRIORITY, uint32_t, sd_nvic_SetPriority(IRQn_Type IRQn, nrf_app_irq_priority_t priority));
Xuint32_t __svc(SD_NVIC_SETPRIORITY) sd_nvic_SetPriority(IRQn_Type IRQn, nrf_app_irq_priority_t priority);
N
N/**@brief Get Interrupt Priority.
N * @note Corresponds to NVIC_GetPriority in CMSIS.
N *
N * @pre{IRQn is valid and not reserved by the stack}
N *
N * @param[in]  IRQn         See the NVIC_GetPriority documentation in CMSIS.
N * @param[out] p_priority   Return value from NVIC_GetPriority.
N *
N * @retval ::NRF_SUCCESS The interrupt priority is returned in p_priority.
N * @retval ::NRF_ERROR_SOC_NVIC_INTERRUPT_NOT_AVAILABLE - IRQn is not available for the application.
N */
NSVCALL(SD_NVIC_GETPRIORITY, uint32_t, sd_nvic_GetPriority(IRQn_Type IRQn, nrf_app_irq_priority_t * p_priority));
Xuint32_t __svc(SD_NVIC_GETPRIORITY) sd_nvic_GetPriority(IRQn_Type IRQn, nrf_app_irq_priority_t * p_priority);
N
N/**@brief System Reset.
N * @note Corresponds to NVIC_SystemReset in CMSIS.
N *
N * @retval ::NRF_ERROR_SOC_NVIC_SHOULD_NOT_RETURN
N */
NSVCALL(SD_NVIC_SYSTEMRESET, uint32_t, sd_nvic_SystemReset(void));
Xuint32_t __svc(SD_NVIC_SYSTEMRESET) sd_nvic_SystemReset(void);
N
N/**@brief Enters critical region.
N *
N * @post Application interrupts will be disabled.
N * @sa sd_nvic_critical_region_exit
N *
N * @param[out]  p_is_nested_critical_region  1: If in a nested critical region.
N *                                           0: Otherwise.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_NVIC_CRITICAL_REGION_ENTER, uint32_t, sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region));
Xuint32_t __svc(SD_NVIC_CRITICAL_REGION_ENTER) sd_nvic_critical_region_enter(uint8_t * p_is_nested_critical_region);
N
N/**@brief Exit critical region.
N *
N * @pre Application has entered a critical region using ::sd_nvic_critical_region_enter.
N * @post If not in a nested critical region, the application interrupts will restored to the state before ::sd_nvic_critical_region_enter was called. 
N *
N * @param[in] is_nested_critical_region If this is set to 1, the critical region won't be exited. @sa sd_nvic_critical_region_enter.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_NVIC_CRITICAL_REGION_EXIT, uint32_t, sd_nvic_critical_region_exit(uint8_t is_nested_critical_region));
Xuint32_t __svc(SD_NVIC_CRITICAL_REGION_EXIT) sd_nvic_critical_region_exit(uint8_t is_nested_critical_region);
N
N/**@brief Query the capacity of the application random pool.
N *
N * @param[out] p_pool_capacity The capacity of the pool.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RAND_APPLICATION_POOL_CAPACITY, uint32_t, sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity));
Xuint32_t __svc(SD_RAND_APPLICATION_POOL_CAPACITY) sd_rand_application_pool_capacity_get(uint8_t * p_pool_capacity);
N
N/**@brief Get number of random bytes available to the application.
N *
N * @param[out] p_bytes_available The number of bytes currently available in the pool.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RAND_APPLICATION_BYTES_AVAILABLE, uint32_t, sd_rand_application_bytes_available_get(uint8_t * p_bytes_available));
Xuint32_t __svc(SD_RAND_APPLICATION_BYTES_AVAILABLE) sd_rand_application_bytes_available_get(uint8_t * p_bytes_available);
N
N/**@brief Get random bytes from the application pool.
N
N  @param[out]  p_buff  Pointer to unit8_t buffer for storing the bytes.
N  @param[in]   length  Number of bytes to take from pool and place in p_buff.
N
N  @retval ::NRF_SUCCESS The requested bytes were written to p_buff.
N  @retval ::NRF_ERROR_SOC_RAND_NOT_ENOUGH_VALUES No bytes were written to the buffer, because there were not enough bytes available.
N*/
NSVCALL(SD_RAND_APPLICATION_GET_VECTOR, uint32_t, sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length));
Xuint32_t __svc(SD_RAND_APPLICATION_GET_VECTOR) sd_rand_application_vector_get(uint8_t * p_buff, uint8_t length);
N
N/**@brief Gets the reset reason register. 
N *
N * @param[out]  p_reset_reason  Contents of the NRF_POWER->RESETREAS register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RESET_REASON_GET, uint32_t, sd_power_reset_reason_get(uint32_t * p_reset_reason));
Xuint32_t __svc(SD_POWER_RESET_REASON_GET) sd_power_reset_reason_get(uint32_t * p_reset_reason);
N
N/**@brief Clears the bits of the reset reason register. 
N *
N * @param[in] reset_reason_clr_msk Contains the bits to clear from the reset reason register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RESET_REASON_CLR, uint32_t, sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk));
Xuint32_t __svc(SD_POWER_RESET_REASON_CLR) sd_power_reset_reason_clr(uint32_t reset_reason_clr_msk);
N
N/**@brief Sets the power mode when in CPU sleep.
N *
N * @param[in] power_mode The power mode to use when in CPU sleep. @sa sd_app_event_wait
N *
N * @retval ::NRF_SUCCESS The power mode was set.
N * @retval ::NRF_ERROR_SOC_POWER_MODE_UNKNOWN The power mode was unknown.
N */
NSVCALL(SD_POWER_MODE_SET, uint32_t, sd_power_mode_set(nrf_power_mode_t power_mode));
Xuint32_t __svc(SD_POWER_MODE_SET) sd_power_mode_set(nrf_power_mode_t power_mode);
N
N/**@brief Puts the chip in System OFF mode. 
N *
N * @retval ::NRF_ERROR_SOC_POWER_OFF_SHOULD_NOT_RETURN
N */
NSVCALL(SD_POWER_SYSTEM_OFF, uint32_t, sd_power_system_off(void));
Xuint32_t __svc(SD_POWER_SYSTEM_OFF) sd_power_system_off(void);
N
N/**@brief Enables or disables the power-fail comparator.
N *
N * Enabling this will give a softdevice event (NRF_EVENT_POWER_FAILURE_WARNING) when the power failure warning occurs.
N * The event can be retrived with sd_event_get();
N *
N * @param[in] pof_enable    True if the power-fail comparator should be enabled, false if it should be disabled.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_POF_ENABLE, uint32_t, sd_power_pof_enable(uint8_t pof_enable));
Xuint32_t __svc(SD_POWER_POF_ENABLE) sd_power_pof_enable(uint8_t pof_enable);
N
N/**@brief Sets the power-fail threshold value.
N *
N * @param[in] threshold The power-fail threshold value to use.
N *
N * @retval ::NRF_SUCCESS The power failure threshold was set.
N * @retval ::NRF_ERROR_SOC_POWER_POF_THRESHOLD_UNKNOWN The power failure threshold is unknown.
N */
NSVCALL(SD_POWER_POF_THRESHOLD_SET, uint32_t, sd_power_pof_threshold_set(nrf_power_failure_threshold_t threshold));
Xuint32_t __svc(SD_POWER_POF_THRESHOLD_SET) sd_power_pof_threshold_set(nrf_power_failure_threshold_t threshold);
N
N/**@brief Sets bits in the NRF_POWER->RAMON register.
N *
N * @param[in] ramon Contains the bits needed to be set in the NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_SET, uint32_t, sd_power_ramon_set(uint32_t ramon));
Xuint32_t __svc(SD_POWER_RAMON_SET) sd_power_ramon_set(uint32_t ramon);
N
N/** @brief Clears bits in the NRF_POWER->RAMON register.
N *
N * @param ramon Contains the bits needed to be cleared in the NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_CLR, uint32_t, sd_power_ramon_clr(uint32_t ramon));
Xuint32_t __svc(SD_POWER_RAMON_CLR) sd_power_ramon_clr(uint32_t ramon);
N
N/**@brief Get contents of NRF_POWER->RAMON register, indicates power status of ram blocks.
N *
N * @param[out] p_ramon Content of NRF_POWER->RAMON register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_RAMON_GET, uint32_t, sd_power_ramon_get(uint32_t * p_ramon));
Xuint32_t __svc(SD_POWER_RAMON_GET) sd_power_ramon_get(uint32_t * p_ramon);
N
N/**@brief Set bits in the NRF_POWER->GPREGRET register.
N *
N * @param[in] gpregret_msk Bits to be set in the GPREGRET register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_SET, uint32_t, sd_power_gpregret_set(uint32_t gpregret_msk));
Xuint32_t __svc(SD_POWER_GPREGRET_SET) sd_power_gpregret_set(uint32_t gpregret_msk);
N
N/**@brief Clear bits in the NRF_POWER->GPREGRET register.
N *
N * @param[in] gpregret_msk Bits to be clear in the GPREGRET register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_CLR, uint32_t, sd_power_gpregret_clr(uint32_t gpregret_msk));
Xuint32_t __svc(SD_POWER_GPREGRET_CLR) sd_power_gpregret_clr(uint32_t gpregret_msk);
N
N/**@brief Get contents of the NRF_POWER->GPREGRET register.
N *
N * @param[out] p_gpregret Contents of the GPREGRET register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_POWER_GPREGRET_GET, uint32_t, sd_power_gpregret_get(uint32_t *p_gpregret));
Xuint32_t __svc(SD_POWER_GPREGRET_GET) sd_power_gpregret_get(uint32_t *p_gpregret);
N
N/**@brief Sets the DCDC mode.
N *
N * Depending on the internal state of the SoftDevice, the mode change may not happen immediately.
N * The DCDC mode switch will be blocked when occuring in close proximity to radio transmissions. When
N * the radio transmission is done, the last mode will be used.
N *
N * @param[in] dcdc_mode The mode of the DCDC.
N *
N * @retval ::NRF_SUCCESS
N * @retval ::NRF_ERROR_INVALID_PARAM The DCDC mode is invalid.
N */
NSVCALL(SD_POWER_DCDC_MODE_SET, uint32_t, sd_power_dcdc_mode_set(nrf_power_dcdc_mode_t dcdc_mode));
Xuint32_t __svc(SD_POWER_DCDC_MODE_SET) sd_power_dcdc_mode_set(nrf_power_dcdc_mode_t dcdc_mode);
N
N/**@brief Request the high frequency crystal oscillator.
N *
N * Will start the high frequency crystal oscillator, the startup time of the crystal varies
N * and the ::sd_clock_hfclk_is_running function can be polled to check if it has started.
N *
N * @see sd_clock_hfclk_is_running
N * @see sd_clock_hfclk_release
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_REQUEST, uint32_t, sd_clock_hfclk_request(void));
Xuint32_t __svc(SD_CLOCK_HFCLK_REQUEST) sd_clock_hfclk_request(void);
N
N/**@brief Releases the high frequency crystal oscillator.
N *
N * Will stop the high frequency crystal oscillator, this happens immediately.
N *
N * @see sd_clock_hfclk_is_running
N * @see sd_clock_hfclk_request
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_RELEASE, uint32_t, sd_clock_hfclk_release(void));
Xuint32_t __svc(SD_CLOCK_HFCLK_RELEASE) sd_clock_hfclk_release(void);
N
N/**@brief Checks if the high frequency crystal oscillator is running.
N *
N * @see sd_clock_hfclk_request
N * @see sd_clock_hfclk_release
N *
N * @param[out] p_is_running 1 if the external crystal oscillator is running, 0 if not.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_CLOCK_HFCLK_IS_RUNNING, uint32_t, sd_clock_hfclk_is_running(uint32_t * p_is_running));
Xuint32_t __svc(SD_CLOCK_HFCLK_IS_RUNNING) sd_clock_hfclk_is_running(uint32_t * p_is_running);
N
N/**@brief Waits for an application event.
N * 
N * An application event is either an application interrupt or a pended interrupt when the
N * interrupt is disabled. When the interrupt is enabled it will be taken immediately since
N * this function will wait in thread mode, then the execution will return in the application's
N * main thread. When an interrupt is disabled and gets pended it will return to the application's 
N * thread main. The application must ensure that the pended flag is cleared using 
N * ::sd_nvic_ClearPendingIRQ in order to sleep using this function. This is only necessary for
N * disabled interrupts, as the interrupt handler will clear the pending flag automatically for
N * enabled interrupts.
N *
N * In order to wake up from disabled interrupts, the SEVONPEND flag has to be set in the Cortex-M0
N * System Control Register (SCR). @sa CMSIS_SCB
N *
N * @note If an application interrupt has happened since the last time sd_app_event_wait was
N *       called this function will return immediately and not go to sleep. This is to avoid race
N *       conditions that can occur when a flag is updated in the interrupt handler and processed
N *       in the main loop.
N *
N * @post An application interrupt has happened or a interrupt pending flag is set.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_APP_EVENT_WAIT, uint32_t, sd_app_event_wait(void));
Xuint32_t __svc(SD_APP_EVENT_WAIT) sd_app_event_wait(void);
N
N/**@brief Get PPI channel enable register contents.
N *
N * @param[out] p_channel_enable The contents of the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_GET, uint32_t, sd_ppi_channel_enable_get(uint32_t * p_channel_enable));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_GET) sd_ppi_channel_enable_get(uint32_t * p_channel_enable);
N
N/**@brief Set PPI channel enable register.
N *
N * @param[in] channel_enable_set_msk Mask containing the bits to set in the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_SET, uint32_t, sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_SET) sd_ppi_channel_enable_set(uint32_t channel_enable_set_msk);
N
N/**@brief Clear PPI channel enable register.
N *
N * @param[in] channel_enable_clr_msk Mask containing the bits to clear in the PPI CHEN register.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ENABLE_CLR, uint32_t, sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk));
Xuint32_t __svc(SD_PPI_CHANNEL_ENABLE_CLR) sd_ppi_channel_enable_clr(uint32_t channel_enable_clr_msk);
N
N/**@brief Assign endpoints to a PPI channel.
N *
N * @param[in] channel_num Number of the PPI channel to assign.
N * @param[in] event_endpoint Event endpoint of the PPI channel.
N * @param[in] task_endpoint Task endpoint of the PPI channel.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_CHANNEL The channel number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_CHANNEL_ASSIGN, uint32_t, sd_ppi_channel_assign(uint8_t channel_num, const volatile void * event_endpoint, const volatile void * task_endpoint));
Xuint32_t __svc(SD_PPI_CHANNEL_ASSIGN) sd_ppi_channel_assign(uint8_t channel_num, const volatile void * event_endpoint, const volatile void * task_endpoint);
N
N/**@brief Task to enable a channel group.
N *
N * @param[in] group_num Number of the channel group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_TASK_ENABLE, uint32_t, sd_ppi_group_task_enable(uint8_t group_num));
Xuint32_t __svc(SD_PPI_GROUP_TASK_ENABLE) sd_ppi_group_task_enable(uint8_t group_num);
N
N/**@brief Task to disable a channel group.
N *
N * @param[in] group_num Number of the PPI group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_TASK_DISABLE, uint32_t, sd_ppi_group_task_disable(uint8_t group_num));
Xuint32_t __svc(SD_PPI_GROUP_TASK_DISABLE) sd_ppi_group_task_disable(uint8_t group_num);
N
N/**@brief Assign PPI channels to a channel group.
N *
N * @param[in] group_num Number of the channel group.
N * @param[in] channel_msk Mask of the channels to assign to the group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_ASSIGN, uint32_t, sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk));
Xuint32_t __svc(SD_PPI_GROUP_ASSIGN) sd_ppi_group_assign(uint8_t group_num, uint32_t channel_msk);
N
N/**@brief Gets the PPI channels of a channel group.
N *
N * @param[in]   group_num Number of the channel group.
N * @param[out]  p_channel_msk Mask of the channels assigned to the group.
N *
N * @retval ::NRF_ERROR_SOC_PPI_INVALID_GROUP The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_PPI_GROUP_GET, uint32_t, sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk));
Xuint32_t __svc(SD_PPI_GROUP_GET) sd_ppi_group_get(uint8_t group_num, uint32_t * p_channel_msk);
N
N/**@brief Configures the Radio Notification signal.
N *
N * @note
N *      - The notification signal latency depends on the interrupt priority settings of SWI used
N *        for notification signal.
N *      - In the period between the ACTIVE signal and the start of the Radio Event, the SoftDevice
N *        will interrupt the application to do Radio Event preparation.
N *      - Using the Radio Notification feature may limit the bandwidth, as the SoftDevice may have
N *        to shorten the connection events to have time for the Radio Notification signals.
N *
N * @param[in]  type      Type of notification signal.
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE shall be used to turn off radio
N *                       notification. Using @ref NRF_RADIO_NOTIFICATION_DISTANCE_NONE is
N *                       recommended (but not required) to be used with
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_NONE.
N *
N * @param[in]  distance  Distance between the notification signal and start of radio activity.
N *                       This parameter is ignored when @ref NRF_RADIO_NOTIFICATION_TYPE_NONE or 
N *                       @ref NRF_RADIO_NOTIFICATION_TYPE_INT_ON_INACTIVE is used.
N *
N * @retval ::NRF_ERROR_INVALID_PARAM The group number is invalid.
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_RADIO_NOTIFICATION_CFG_SET, uint32_t, sd_radio_notification_cfg_set(nrf_radio_notification_type_t type, nrf_radio_notification_distance_t distance));
Xuint32_t __svc(SD_RADIO_NOTIFICATION_CFG_SET) sd_radio_notification_cfg_set(nrf_radio_notification_type_t type, nrf_radio_notification_distance_t distance);
N
N/**@brief Encrypts a block according to the specified parameters.
N *
N * 128-bit AES encryption.
N *
N * @param[in, out] p_ecb_data Pointer to the ECB paramters' struct (two input
N *                            parameters and one output parameter).
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_ECB_BLOCK_ENCRYPT, uint32_t, sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data));
Xuint32_t __svc(SD_ECB_BLOCK_ENCRYPT) sd_ecb_block_encrypt(nrf_ecb_hal_data_t * p_ecb_data);
N
N/**@brief Gets any pending events generated by the SoC API.
N *
N * The application should keep calling this function to get events, until ::NRF_ERROR_NOT_FOUND is returned.
N *
N * @param[out] p_event Set to the event number, if any events are pending.
N *
N * @retval ::NRF_SUCCESS An event was pending. The event number is written in the p_event paramer.
N * @retval ::NRF_ERROR_NOT_FOUND No pending events. 
N */
NSVCALL(SD_EVENT_GET, uint32_t, sd_event_get(uint32_t *p_event));
Xuint32_t __svc(SD_EVENT_GET) sd_event_get(uint32_t *p_event);
N
N/** @} */
N
N#endif // NRF_SOC_H__
N
N/**
N  @}
N */
L 24 "..\..\..\Software\Include\nrf_sdm.h" 2
N#include "nrf_error_sdm.h"
L 1 "..\..\..\Software\Include\nrf_error_sdm.h" 1
N/*
N * Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N /**
N  @addtogroup nrf_sdm_api
N  @{
N  @defgroup nrf_sdm_error SoftDevice Manager Error Codes
N  @{
N     
N  @brief Error definitions for the SDM API
N*/
N
N/* Header guard */
N#ifndef NRF_ERROR_SDM_H__
N#define NRF_ERROR_SDM_H__
N
N#include "nrf_error.h"
N
N#define NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN              (NRF_ERROR_SDM_BASE_NUM + 0)  ///< Unknown lfclk source
N#define NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION (NRF_ERROR_SDM_BASE_NUM + 1)  ///< Incorrect interrupt configuration (can be caused by using illegal priority levels, or having enabled SoftDevice interrupts)
N#define NRF_ERROR_SDM_INCORRECT_CLENR0                  (NRF_ERROR_SDM_BASE_NUM + 2)  ///< Incorrect CLENR0 (can be caused by erronous SoftDevice flashing)
N
N#endif // NRF_ERROR_SDM_H__
N
N/**
N  @}
N  @}
N*/
L 25 "..\..\..\Software\Include\nrf_sdm.h" 2
N
N/** @addtogroup NRF_SDM_DEFINES Defines
N * @{ */
N
N/**@brief SoftDevice Manager SVC Base number. */
N#define SDM_SVC_BASE 0x10   
N
N/** @} */
N
N/** @addtogroup NRF_SDM_ENUMS Enumerations
N * @{ */
N
N/**@brief nRF SoftDevice Manager API SVC numbers. */
Nenum NRF_SD_SVCS
N{
N  SD_SOFTDEVICE_ENABLE = SDM_SVC_BASE, /**< ::sd_softdevice_enable */
X  SD_SOFTDEVICE_ENABLE = 0x10,  
N  SD_SOFTDEVICE_DISABLE,               /**< ::sd_softdevice_disable */
N  SD_SOFTDEVICE_IS_ENABLED,            /**< ::sd_softdevice_is_enabled */
N  SD_SOFTDEVICE_FORWARD_TO_APPLICATION,/**< ::sd_softdevice_forward_to_application */
N  SVC_SDM_LAST                         /**< Placeholder for last SDM SVC */
N};
N
N/**@brief Possible lfclk oscillator sources. */
Nenum NRF_CLOCK_LFCLKSRCS
N{
N  NRF_CLOCK_LFCLKSRC_RC_250_PPM_500MS_CALIBRATION,  /**< LFCLK RC oscillator, 500ms  calibration interval.*/
N  NRF_CLOCK_LFCLKSRC_RC_250_PPM_1000MS_CALIBRATION, /**< LFCLK RC oscillator, 1000ms calibration interval.*/
N  NRF_CLOCK_LFCLKSRC_RC_250_PPM_2000MS_CALIBRATION, /**< LFCLK RC oscillator, 2000ms calibration interval.*/
N  NRF_CLOCK_LFCLKSRC_RC_250_PPM_4000MS_CALIBRATION, /**< LFCLK RC oscillator, 4000ms calibration interval.*/
N  NRF_CLOCK_LFCLKSRC_RC_250_PPM_8000MS_CALIBRATION, /**< LFCLK RC oscillator, 8000ms calibration interval.*/
N  NRF_CLOCK_LFCLKSRC_SYNTH_250_PPM,                 /**< LFCLK Synthesized from HFCLK.                    */
N  NRF_CLOCK_LFCLKSRC_XTAL_500_PPM,                  /**< LFCLK crystal oscillator 500 PPM accuracy.       */
N  NRF_CLOCK_LFCLKSRC_XTAL_250_PPM,                  /**< LFCLK crystal oscillator 250 PPM accuracy.       */
N  NRF_CLOCK_LFCLKSRC_XTAL_150_PPM,                  /**< LFCLK crystal oscillator 150 PPM accuracy.       */
N  NRF_CLOCK_LFCLKSRC_XTAL_100_PPM,                  /**< LFCLK crystal oscillator 100 PPM accuracy.       */
N  NRF_CLOCK_LFCLKSRC_XTAL_75_PPM,                   /**< LFCLK crystal oscillator 75 PPM accuracy.        */
N  NRF_CLOCK_LFCLKSRC_XTAL_50_PPM,                   /**< LFCLK crystal oscillator 50 PPM accuracy.        */
N  NRF_CLOCK_LFCLKSRC_XTAL_30_PPM,                   /**< LFCLK crystal oscillator 30 PPM accuracy.        */
N  NRF_CLOCK_LFCLKSRC_XTAL_20_PPM,                   /**< LFCLK crystal oscillator 20 PPM accuracy.        */
N};
N
N/** @} */
N
N/** @addtogroup NRF_SDM_TYPES Types
N * @{ */
N
N/**@brief Type representing lfclk oscillator source. */
Ntypedef uint32_t nrf_clock_lfclksrc_t;
N
N
N/**@brief SoftDevice Assertion Handler type.
N *
N * When an unexpected error occurs within the SoftDevice it will call the SoftDevice assertion handler callback.
N * The protocol stack will be in an undefined state when this happens and the only way to recover will be to
N * perform a reset, using e.g. CMSIS NVIC_SystemReset().
N *
N * @note This callback is executed in HardFault context, thus SVC functions cannot be called from the SoftDevice assert callback.
N *       
N * @param[in] pc The program counter of the failed assert.
N * @param[in] line_number Line number where the assert failed.
N * @param[in] file_name File name where the assert failed.
N */
Ntypedef void (*softdevice_assertion_handler_t)(uint32_t pc, uint16_t line_number, const uint8_t * p_file_name);
N
N/** @} */
N
N/** @addtogroup NRF_SDM_FUNCTIONS Functions
N * @{ */
N
N/**@brief Enables the SoftDevice and by extension the protocol stack.
N *
N * Idempotent function to enable the SoftDevice.
N *
N * @note Some care must be taken if a low frequency clock source is already running when calling this function:
N *       If the LF clock has a different source then the one currently running, it will be stopped. Then, the new
N *       clock source will be started.
N *
N * @note This function has no effect when returning with an error.
N *
N * @post If return code is ::NRF_SUCCESS 
N *       - SoC library and protocol stack APIs are made available
N *       - A portion of RAM will be unavailable (see relevant SDS documentation)
N *       - Some peripherals will be unavailable or available only through the SoC API (see relevant SDS documentation)
N *       - Interrupts will not arrive from protected peripherals or interrupts
N *       - nrf_nvic_ functions must be used instead of CMSIS NVIC_ functions for reliable usage of the softdevice.
N *       - Interrupt latency may be affected by the SoftDevice  (see relevant SDS documentation)
N *       - Chosen low frequency clock source will be running
N *
N * @param clock_source Low frequency clock source and accuracy. (Note: In the case of XTAL source, the PPM accuracy of the chosen clock source must be greater than or equal to the actual characteristics of your XTAL clock).
N * @param assertion_handler Callback for SoftDevice assertions.
N *
N * @retval ::NRF_SUCCESS
N * @retval ::NRF_ERROR_SDM_INCORRECT_INTERRUPT_CONFIGURATION SoftDeviceinterrupt is already enabled, or an enabled interrupt has an illegal priority level
N * @retval ::NRF_ERROR_SDM_LFCLK_SOURCE_UNKNOWN Unknown low frequency clock source selected
N */
NSVCALL(SD_SOFTDEVICE_ENABLE, uint32_t, sd_softdevice_enable(nrf_clock_lfclksrc_t clock_source, softdevice_assertion_handler_t assertion_handler));
Xuint32_t __svc(SD_SOFTDEVICE_ENABLE) sd_softdevice_enable(nrf_clock_lfclksrc_t clock_source, softdevice_assertion_handler_t assertion_handler);
N
N/**@brief Disables the SoftDevice and by extension the protocol stack.
N * 
N * Idempotent function to disable the SoftDevice.
N *
N * @post SoC library and protocol stack APIs are made unavailable.
N * @post All interrupts that was protected by the SoftDevice will be disabled and initialized to priority 0 (highest).
N * @post All peripherals used by the SoftDevice will be reset to default values.
N * @post All of RAM become available.
N * @post All interrupts are forwarded to the application.
N * @post LFCLK source chosen in ::sd_softdevice_enable will be left running.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_DISABLE, uint32_t, sd_softdevice_disable(void));
Xuint32_t __svc(SD_SOFTDEVICE_DISABLE) sd_softdevice_disable(void);
N
N/**@brief Check if the SoftDevice is enabled.
N *
N * @param[out]  p_softdevice_enabled If the SoftDevice is enabled: 1 else 0.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_IS_ENABLED, uint32_t, sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled));
Xuint32_t __svc(SD_SOFTDEVICE_IS_ENABLED) sd_softdevice_is_enabled(uint8_t * p_softdevice_enabled);
N
N/**@brief Start forwarding interrupts to application.
N * 
N * This function is only intended to be called when a bootloader is enabled is used.
N * The bootloader should call this right before it starts the application. 
N * It is recommended that all interrupt sources are off when this is called, 
N * or you could end up having interrupts in the application being executed before main() of the application.
N *
N * @retval ::NRF_SUCCESS
N */
NSVCALL(SD_SOFTDEVICE_FORWARD_TO_APPLICATION, uint32_t, sd_softdevice_forward_to_application(void)); 
Xuint32_t __svc(SD_SOFTDEVICE_FORWARD_TO_APPLICATION) sd_softdevice_forward_to_application(void); 
N
N/** @} */
N
N#endif // NRF_SDM_H__
N
N/**
N  @}
N*/
L 35 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "app_error.h"
L 1 "..\..\..\Software\Include\app_error.h" 1
N/* Copyright (c) 2013 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N 
N/** @file
N *
N * @defgroup app_error Common application error handler
N * @{
N * @ingroup app_common
N *
N * @brief Common application error handler and macros for utilizing a common error handler.
N */
N
N#ifndef APP_ERROR_H__
N#define APP_ERROR_H__
N
N#include <stdint.h>
N#include <stdbool.h>
N#include "nrf_error.h"
N
N/**@brief Function for error handling, which is called when an error has occurred. 
N *
N * @param[in] error_code  Error code supplied to the handler.
N * @param[in] line_num    Line number where the handler is called.
N * @param[in] p_file_name Pointer to the file name. 
N */
Nvoid app_error_handler(uint32_t error_code, uint32_t line_num, const uint8_t * p_file_name);
N
N/**@brief Macro for calling error handler function. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */
N#define APP_ERROR_HANDLER(ERR_CODE)                         \
N    do                                                      \
N    {                                                       \
N        app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);  \
N    } while (0)
X#define APP_ERROR_HANDLER(ERR_CODE)                             do                                                          {                                                               app_error_handler((ERR_CODE), __LINE__, (uint8_t*) __FILE__);      } while (0)
N
N/**@brief Macro for calling error handler function if supplied error code any other than NRF_SUCCESS. 
N *
N * @param[in] ERR_CODE Error code supplied to the error handler.
N */    
N#define APP_ERROR_CHECK(ERR_CODE)                           \
N    do                                                      \
N    {                                                       \
N        const uint32_t LOCAL_ERR_CODE = (ERR_CODE);         \
N        if (LOCAL_ERR_CODE != NRF_SUCCESS)                  \
N        {                                                   \
N            APP_ERROR_HANDLER(LOCAL_ERR_CODE);              \
N        }                                                   \
N    } while (0)    
X#define APP_ERROR_CHECK(ERR_CODE)                               do                                                          {                                                               const uint32_t LOCAL_ERR_CODE = (ERR_CODE);                 if (LOCAL_ERR_CODE != NRF_SUCCESS)                          {                                                               APP_ERROR_HANDLER(LOCAL_ERR_CODE);                      }                                                       } while (0)    
N    
N/**@brief Macro for calling error handler function if supplied boolean value is false. 
N *
N * @param[in] BOOLEAN_VALUE Boolean value to be evaluated.
N */    
N#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                 \
N    do                                                      \
N    {                                                       \
N        const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);   \
N        if (!LOCAL_BOOLEAN_VALUE)                           \
N        {                                                   \
N            APP_ERROR_HANDLER(0);                           \
N        }                                                   \
N    } while (0)        
X#define APP_ERROR_CHECK_BOOL(BOOLEAN_VALUE)                     do                                                          {                                                               const bool LOCAL_BOOLEAN_VALUE = (BOOLEAN_VALUE);           if (!LOCAL_BOOLEAN_VALUE)                                   {                                                               APP_ERROR_HANDLER(0);                                   }                                                       } while (0)        
N
N#endif // APP_ERROR_H__
N
N/** @} */
L 36 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "app_scheduler.h"
L 1 "..\..\..\Software\Include\app_scheduler.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_scheduler Scheduler
N * @{
N * @ingroup app_common
N *
N * @brief The scheduler is used for transferring execution from the interrupt context to the main
N *        context.
N *
N * @details See @ref ble_sdk_apps_seq_diagrams for sequence diagrams illustrating the flow of events
N *          when using the Scheduler.
N *
N * @section app_scheduler_req Requirements:
N *
N * @subsection main_context_logic Logic in main context:
N *
N *   - Define an event handler for each type of event expected.
N *   - Initialize the scheduler by calling the APP_SCHED_INIT() macro before entering the
N *     application main loop.
N *   - Call app_sched_execute() from the main loop each time the application wakes up because of an
N *     event (typically when sd_app_event_wait() returns).
N *
N * @subsection int_context_logic Logic in interrupt context:
N *
N *   - In the interrupt handler, call app_sched_event_put()
N *     with the appropriate data and event handler. This will insert an event into the
N *     scheduler's queue. The app_sched_execute() function will pull this event and call its
N *     handler in the main context.
N *
N * For an example usage of the scheduler, please see the implementations of
N * @ref ble_sdk_app_hids_mouse and @ref ble_sdk_app_hids_keyboard.
N *
N * @image html scheduler_working.jpg The high level design of the scheduler
N */
N
N#ifndef APP_SCHEDULER_H__
N#define APP_SCHEDULER_H__
N
N#include <stdint.h>
N#include "app_error.h"
N
N#define APP_SCHED_EVENT_HEADER_SIZE 8       /**< Size of app_scheduler.event_header_t (only for use inside APP_SCHED_BUF_SIZE()). */
N
N/**@brief Compute number of bytes required to hold the scheduler buffer.
N *
N * @param[in] EVENT_SIZE   Maximum size of events to be passed through the scheduler.
N * @param[in] QUEUE_SIZE   Number of entries in scheduler queue (i.e. the maximum number of events
N *                         that can be scheduled for execution).
N *
N * @return    Required scheduler buffer size (in bytes).
N */
N#define APP_SCHED_BUF_SIZE(EVENT_SIZE, QUEUE_SIZE)                                                 \
N            (((EVENT_SIZE) + APP_SCHED_EVENT_HEADER_SIZE) * ((QUEUE_SIZE) + 1))
X#define APP_SCHED_BUF_SIZE(EVENT_SIZE, QUEUE_SIZE)                                                             (((EVENT_SIZE) + APP_SCHED_EVENT_HEADER_SIZE) * ((QUEUE_SIZE) + 1))
N            
N/**@brief Scheduler event handler type. */
Ntypedef void (*app_sched_event_handler_t)(void * p_event_data, uint16_t event_size);
N
N/**@brief Macro for initializing the event scheduler.
N *
N * @details It will also handle dimensioning and allocation of the memory buffer required by the
N *          scheduler, making sure the buffer is correctly aligned.
N *
N * @param[in] EVENT_SIZE   Maximum size of events to be passed through the scheduler.
N * @param[in] QUEUE_SIZE   Number of entries in scheduler queue (i.e. the maximum number of events
N *                         that can be scheduled for execution).
N *
N * @note Since this macro allocates a buffer, it must only be called once (it is OK to call it
N *       several times as long as it is from the same location, e.g. to do a reinitialization).
N */
N#define APP_SCHED_INIT(EVENT_SIZE, QUEUE_SIZE)                                                     \
N    do                                                                                             \
N    {                                                                                              \
N        static uint32_t APP_SCHED_BUF[CEIL_DIV(APP_SCHED_BUF_SIZE((EVENT_SIZE), (QUEUE_SIZE)),     \
N                                               sizeof(uint32_t))];                                 \
N        uint32_t ERR_CODE = app_sched_init((EVENT_SIZE), (QUEUE_SIZE), APP_SCHED_BUF);             \
N        APP_ERROR_CHECK(ERR_CODE);                                                                 \
N    } while (0)
X#define APP_SCHED_INIT(EVENT_SIZE, QUEUE_SIZE)                                                         do                                                                                                 {                                                                                                      static uint32_t APP_SCHED_BUF[CEIL_DIV(APP_SCHED_BUF_SIZE((EVENT_SIZE), (QUEUE_SIZE)),                                                    sizeof(uint32_t))];                                         uint32_t ERR_CODE = app_sched_init((EVENT_SIZE), (QUEUE_SIZE), APP_SCHED_BUF);                     APP_ERROR_CHECK(ERR_CODE);                                                                     } while (0)
N
N/**@brief Function for initializing the Scheduler.
N *
N * @details It must be called before entering the main loop.
N *
N * @param[in]   max_event_size   Maximum size of events to be passed through the scheduler.
N * @param[in]   queue_size       Number of entries in scheduler queue (i.e. the maximum number of
N *                               events that can be scheduled for execution).
N * @param[in]   p_event_buffer   Pointer to memory buffer for holding the scheduler queue. It must
N *                               be dimensioned using the APP_SCHED_BUFFER_SIZE() macro. The buffer
N *                               must be aligned to a 4 byte boundary.
N *
N * @note Normally initialization should be done using the APP_SCHED_INIT() macro, as that will both
N *       allocate the scheduler buffer, and also align the buffer correctly.
N *
N * @retval      NRF_SUCCESS               Successful initialization.
N * @retval      NRF_ERROR_INVALID_PARAM   Invalid parameter (buffer not aligned to a 4 byte
N *                                        boundary).
N */
Nuint32_t app_sched_init(uint16_t max_event_size, uint16_t queue_size, void * p_evt_buffer);
N
N/**@brief Function for executing all scheduled events.
N *
N * @details This function must be called from within the main loop. It will execute all events
N *          scheduled since the last time it was called.
N */
Nvoid app_sched_execute(void);
N
N/**@brief Function for scheduling an event.
N *
N * @details Puts an event into the event queue.
N *
N * @param[in]   p_event_data   Pointer to event data to be scheduled.
N * @param[in]   p_event_size   Size of event data to be scheduled.
N * @param[in]   handler        Event handler to receive the event.
N *
N * @return      NRF_SUCCESS on success, otherwise an error code.
N */
Nuint32_t app_sched_event_put(void *                    p_event_data,
N                             uint16_t                  event_size,
N                             app_sched_event_handler_t handler);
N
N#endif // APP_SCHEDULER_H__
N
N/** @} */
L 37 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "app_util.h"
L 1 "..\..\..\Software\Include\app_util.h" 1
N/* Copyright (c) 2012 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N/** @file
N *
N * @defgroup app_util Utility Functions and Definitions
N * @{
N * @ingroup app_common
N *
N * @brief Various types and definitions available to all applications.
N */
N
N#ifndef APP_UTIL_H__
N#define APP_UTIL_H__
N
N#include <stdint.h>
N#include "compiler_abstraction.h"
L 1 "..\..\..\Software\Include\compiler_abstraction.h" 1
N/* Copyright (c) 2009 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic
N * Semiconductor ASA.Terms and conditions of usage are described in detail
N * in NORDIC SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT.
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N *
N */
N
N#ifndef _COMPILER_ABSTRACTION_H
N#define _COMPILER_ABSTRACTION_H
N
N/*lint ++flb "Enter library region" */
N
N#if defined ( __CC_ARM )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S  #define __current_sp() __get_SP()
S  
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
Sstatic __INLINE unsigned int __current_sp(void)
S  {
S      register unsigned sp asm("sp");
S      return sp;
S  }
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/*lint --flb "Leave library region" */
N
N#endif
L 27 "..\..\..\Software\Include\app_util.h" 2
N#include "nrf51.h"
N#include "app_error.h"
N
N/**@brief The interrupt priorities available to the application while the softdevice is active. */
Ntypedef enum
N{
N    APP_IRQ_PRIORITY_HIGH = 1,
N    APP_IRQ_PRIORITY_LOW  = 3
N} app_irq_priority_t;
N
Nenum
N{
N    UNIT_0_625_MS = 625,                                /**< Number of microseconds in 0.625 milliseconds. */
N    UNIT_1_25_MS  = 1250,                               /**< Number of microseconds in 1.25 milliseconds. */
N    UNIT_10_MS    = 10000                               /**< Number of microseconds in 10 milliseconds. */
N};
N
N#define NRF_APP_PRIORITY_THREAD    4                    /**< "Interrupt level" when running in Thread Mode. */
N
N/**@cond NO_DOXYGEN */
N#define EXTERNAL_INT_VECTOR_OFFSET 16
N/**@endcond */
N
N#define PACKED(TYPE) __packed TYPE
N
N/**@brief Macro for doing static (i.e. compile time) assertion.
N *
N * @note If the assertion fails when compiling using Keil, the compiler will report error message
N *       "error: #94: the size of an array must be greater than zero" (while gcc will list the
N *       symbol static_assert_failed, making the error message more readable).
N *       If the supplied expression can not be evaluated at compile time, Keil will report
N *       "error: #28: expression must have a constant value".
N *
N * @note The macro is intentionally implemented not using do while(0), allowing it to be used
N *       outside function blocks (e.g. close to global type- and variable declarations).
N *       If used in a code block, it must be used before any executable code in this block.
N *
N * @param[in]   EXPR   Constant expression to be verified.
N */
N
N#define STATIC_ASSERT(EXPR) typedef char static_assert_failed[(EXPR) ? 1 : -1]
N
N/**@brief type for holding an encoded (i.e. little endian) 16 bit unsigned integer. */
Ntypedef uint8_t uint16_le_t[2];
N
N/**@brief type for holding an encoded (i.e. little endian) 32 bit unsigned integer. */
Ntypedef uint8_t uint32_le_t[4];
N
N/**@brief Byte array type. */
Ntypedef struct
N{
N    uint16_t  size;                 /**< Number of array entries. */
N    uint8_t * p_data;               /**< Pointer to array entries. */
N} uint8_array_t;
N
N/**@cond NO_DOXYGEN */
N#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N    do{                                                                               \
N        NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                 \
N            ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                  \
N            ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                  \
N            ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                  \
N            ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                  \
N            ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                   \
N    } while (0)
X#define INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)     do{                                                                                       NRF_GPIO->PIN_CNF[(PIN_NO)] =                                                             ((IO_DIR)   << GPIO_PIN_CNF_DIR_Pos)   |                                              ((IO_INPUT) << GPIO_PIN_CNF_INPUT_Pos) |                                              ((IO_PULL)  << GPIO_PIN_CNF_PULL_Pos)  |                                              ((IO_DRIVE) << GPIO_PIN_CNF_DRIVE_Pos) |                                              ((IO_SENSE) << GPIO_PIN_CNF_SENSE_Pos);                                       } while (0)
N/**@endcond */
N
N/**@brief Macro to configure an I/O.
N *
N * @details This macro configures a given I/O to input or output with pullup/buffer configuration.
N *
N * @param[in]  PIN_NO     I/O pin to configure.
N * @param[in]  IO_DIR     I/O pin direction.
N * @param[in]  IO_INPUT   Connect or disconnect input path.
N * @param[in]  IO_PULL    Pull-up or -down configuration.
N * @param[in]  IO_DRIVE   Drive configuration.
N * @param[in]  IO_SENSE   Pin sensing mechanism.
N */
N#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE) \
N            INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
X#define GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)             INTERN_GPIO_PIN_CONFIG(PIN_NO, IO_DIR, IO_INPUT, IO_PULL, IO_DRIVE, IO_SENSE)
N
N/**@brief Configure a PIN to be used as a LED.
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_LED_CONFIG(PIN_NO)                       \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_LED_CONFIG(PIN_NO)                           do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a debug pin (e.g. to be monitored using a logic analyzer).
N *
N * @param[in]  PIN_NO  Input pin to configure.
N */
N#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                 \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Output,      \
N                        GPIO_PIN_CNF_INPUT_Disconnect,\
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_DEBUG_PIN_CONFIG(PIN_NO)                     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Output,                              GPIO_PIN_CNF_INPUT_Disconnect,                        GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_CONFIG(PIN_NO)                    \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_CONFIG(PIN_NO)                        do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)             \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Disabled,   \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_CONFIG(PIN_NO)                 do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Disabled,                           GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Configure a PIN to be used as a Button, with a pullup resistor enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)        \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Disabled); \
N    } while (0)
X#define GPIO_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)            do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Disabled);     } while (0)
N
N/**@brief Configure a PIN to be used as a Button and a Wakeup source, with a pullup resistor
N *        enabled.
N *
N * @param[in]  PIN_NO  Pin to configure.
N */
N#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO) \
N    do                                                \
N    {                                                 \
N        GPIO_PIN_CONFIG(PIN_NO,                       \
N                        GPIO_PIN_CNF_DIR_Input,       \
N                        GPIO_PIN_CNF_INPUT_Connect,   \
N                        GPIO_PIN_CNF_PULL_Pullup,     \
N                        GPIO_PIN_CNF_DRIVE_S0S1,      \
N                        GPIO_PIN_CNF_SENSE_Low);      \
N    } while (0)
X#define GPIO_WAKEUP_BUTTON_WITH_PULLUP_CONFIG(PIN_NO)     do                                                    {                                                         GPIO_PIN_CONFIG(PIN_NO,                                               GPIO_PIN_CNF_DIR_Input,                               GPIO_PIN_CNF_INPUT_Connect,                           GPIO_PIN_CNF_PULL_Pullup,                             GPIO_PIN_CNF_DRIVE_S0S1,                              GPIO_PIN_CNF_SENSE_Low);          } while (0)
N
N/**@brief Macro for entering a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_ENTER()                                                             \
N    {                                                                                       \
N        uint8_t IS_NESTED_CRITICAL_REGION = 0;                                              \
N        uint32_t CURRENT_INT_PRI = current_int_priority_get();                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);  \
N            if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                __disable_irq();                                                            \
N            }                                                                               \
N            else                                                                            \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }        
X#define CRITICAL_REGION_ENTER()                                                                 {                                                                                               uint8_t IS_NESTED_CRITICAL_REGION = 0;                                                      uint32_t CURRENT_INT_PRI = current_int_priority_get();                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE = sd_nvic_critical_region_enter(&IS_NESTED_CRITICAL_REGION);              if (ERR_CODE == NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               __disable_irq();                                                                        }                                                                                           else                                                                                        {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }        
N    
N/**@brief Macro for leaving a critical region.
N *
N * @note Due to implementation details, there must exist one and only one call to
N *       CRITICAL_REGION_EXIT() for each call to CRITICAL_REGION_ENTER(), and they must be located
N *       in the same scope.
N */
N#define CRITICAL_REGION_EXIT()                                                              \
N        if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                       \
N        {                                                                                   \
N            uint32_t ERR_CODE;                                                              \
N            __enable_irq();                                                                 \
N            ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);             \
N            if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                               \
N            {                                                                               \
N                APP_ERROR_CHECK(ERR_CODE);                                                  \
N            }                                                                               \
N        }                                                                                   \
N    }
X#define CRITICAL_REGION_EXIT()                                                                      if (CURRENT_INT_PRI != APP_IRQ_PRIORITY_HIGH)                                               {                                                                                               uint32_t ERR_CODE;                                                                          __enable_irq();                                                                             ERR_CODE = sd_nvic_critical_region_exit(IS_NESTED_CRITICAL_REGION);                         if (ERR_CODE != NRF_ERROR_SOFTDEVICE_NOT_ENABLED)                                           {                                                                                               APP_ERROR_CHECK(ERR_CODE);                                                              }                                                                                       }                                                                                       }
N    
N/**@brief Perform rounded integer division (as opposed to truncating the result).
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Rounded (integer) result of dividing A by B.
N */
N#define ROUNDED_DIV(A, B) (((A) + ((B) / 2)) / (B))
N
N/**@brief Check if the integer provided is a power of two.
N *
N * @param[in]   A   Number to be tested.
N *
N * @return      true if value is power of two.
N * @return      false if value not power of two.
N */
N#define IS_POWER_OF_TWO(A) ( ((A) != 0) && ((((A) - 1) & (A)) == 0) )
N
N/**@brief To convert ticks to millisecond
N * @param[in] time          Number of millseconds that needs to be converted.
N * @param[in] resolution    Units to be converted.
N */
N#define MSEC_TO_UNITS(TIME, RESOLUTION) (((TIME) * 1000) / (RESOLUTION))
N
N
N/**@brief Perform integer division, making sure the result is rounded up.
N *
N * @details One typical use for this is to compute the number of objects with size B is needed to
N *          hold A number of bytes.
N *
N * @param[in]   A   Numerator.
N * @param[in]   B   Denominator.
N *
N * @return      Integer result of dividing A by B, rounded up.
N */
N#define CEIL_DIV(A, B)      \
N    /*lint -save -e573 */   \
N    ((((A) - 1) / (B)) + 1) \
N    /*lint -restore */
X#define CEIL_DIV(A, B)                  ((((A) - 1) / (B)) + 1)      
N
N/**@brief Function for encoding a uint16 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint16_encode(uint16_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x00FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0xFF00) >> 8);
N    return sizeof(uint16_t);
N}
N    
N/**@brief Function for encoding a uint32 value.
N *
N * @param[in]   value            Value to be encoded.
N * @param[out]  p_encoded_data   Buffer where the encoded data is to be written.
N *
N * @return      Number of bytes written.
N */
Nstatic __INLINE uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
Xstatic __inline uint8_t uint32_encode(uint32_t value, uint8_t * p_encoded_data)
N{
N    p_encoded_data[0] = (uint8_t) ((value & 0x000000FF) >> 0);
N    p_encoded_data[1] = (uint8_t) ((value & 0x0000FF00) >> 8);
N    p_encoded_data[2] = (uint8_t) ((value & 0x00FF0000) >> 16);
N    p_encoded_data[3] = (uint8_t) ((value & 0xFF000000) >> 24);
N    return sizeof(uint32_t);
N}
N
N/**@brief Function for decoding a uint16 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint16_t uint16_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint16_t uint16_decode(const uint8_t * p_encoded_data)
N{
N        return ( (((uint16_t)((uint8_t *)p_encoded_data)[0])) | 
N                 (((uint16_t)((uint8_t *)p_encoded_data)[1]) << 8 ));
N}
N
N/**@brief Function for decoding a uint32 value.
N *
N * @param[in]   p_encoded_data   Buffer where the encoded data is stored.
N *
N * @return      Decoded value.
N */
Nstatic __INLINE uint32_t uint32_decode(const uint8_t * p_encoded_data)
Xstatic __inline uint32_t uint32_decode(const uint8_t * p_encoded_data)
N{
N    return ( (((uint32_t)((uint8_t *)p_encoded_data)[0]) << 0)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[1]) << 8)  |
N             (((uint32_t)((uint8_t *)p_encoded_data)[2]) << 16) |
N             (((uint32_t)((uint8_t *)p_encoded_data)[3]) << 24 ));
N}
N
N    
N/**@brief Function for finding the current interrupt level.
N *
N * @return   Current interrupt level.
N * @retval   APP_IRQ_PRIORITY_HIGH    We are running in Application High interrupt level.
N * @retval   APP_IRQ_PRIORITY_LOW     We are running in Application Low interrupt level.
N * @retval   APP_IRQ_PRIORITY_THREAD  We are running in Thread Mode.
N */
Nstatic __INLINE uint8_t current_int_priority_get(void)
Xstatic __inline uint8_t current_int_priority_get(void)
N{
N    uint32_t isr_vector_num = (SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk);
X    uint32_t isr_vector_num = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->ICSR & (0x1FFUL << 0));
N    if (isr_vector_num > 0)
N    {
N        int32_t irq_type = ((int32_t)isr_vector_num - EXTERNAL_INT_VECTOR_OFFSET);
X        int32_t irq_type = ((int32_t)isr_vector_num - 16);
N        return (NVIC_GetPriority((IRQn_Type)irq_type) & 0xFF);
N    }
N    else
N    {
N        return NRF_APP_PRIORITY_THREAD;
X        return 4;
N    }
N}
N
N/** @brief Function for converting the input voltage (in milli volts) into percentage of 3.0 Volts.
N *
N *  @details The calculation is based on a linearized version of the battery's discharge
N *           curve. 3.0V returns 100% battery level. The limit for power failure is 2.1V and
N *           is considered to be the lower boundary.
N *
N *           The discharge curve for CR2032 is non-linear. In this model it is split into
N *           4 linear sections:
N *           - Section 1: 3.0V - 2.9V = 100% - 42% (58% drop on 100 mV)
N *           - Section 2: 2.9V - 2.74V = 42% - 18% (24% drop on 160 mV)
N *           - Section 3: 2.74V - 2.44V = 18% - 6% (12% drop on 300 mV)
N *           - Section 4: 2.44V - 2.1V = 6% - 0% (6% drop on 340 mV)
N *
N *           These numbers are by no means accurate. Temperature and
N *           load in the actual application is not accounted for!
N *
N *  @param[in] mvolts The voltage in mV
N *
N *  @return    Battery level in percent.
N*/
Nstatic __INLINE uint8_t battery_level_in_percent(const uint16_t mvolts)
Xstatic __inline uint8_t battery_level_in_percent(const uint16_t mvolts)
N{
N    uint8_t battery_level;
N
N    if (mvolts >= 3000)
N    {
N        battery_level = 100;
N    }
N    else if (mvolts > 2900)
N    {
N        battery_level = 100 - ((3000 - mvolts) * 58) / 100;
N    }
N    else if (mvolts > 2740)
N    {
N        battery_level = 42 - ((2900 - mvolts) * 24) / 160;
N    }
N    else if (mvolts > 2440)
N    {
N        battery_level = 18 - ((2740 - mvolts) * 12) / 300;
N    }
N    else if (mvolts > 2100)
N    {
N        battery_level = 6 - ((2440 - mvolts) * 6) / 340;
N    }
N    else
N    {
N        battery_level = 0;
N    }
N
N    return battery_level;
N}
N
N/**@brief Function for checking if a pointer value is aligned to a 4 byte boundary.
N *
N * @param[in]   p   Pointer value to be checked.
N *
N * @return      TRUE if pointer is aligned to a 4 byte boundary, FALSE otherwise.
N */
Nstatic __INLINE bool is_word_aligned(void * p)
Xstatic __inline _Bool is_word_aligned(void * p)
N{
N    return (((uint32_t)p & 0x00000003) == 0);
N}
N
N#endif // APP_UTIL_H__
N
N/** @} */
L 38 "..\..\..\Software\Include\ble_stack_handler.h" 2
N#include "compiler_abstraction.h"
N
N#define BLE_STACK_HANDLER_SCHED_EVT_SIZE  0     /**< Size of button events being passed through the scheduler (is to be used for computing the maximum size of scheduler events). For BLE stack events, this size is 0, since the events are being pulled in the event handler. */
N
N/**@brief Application stack event handler type. */
Ntypedef void (*ble_stack_evt_handler_t) (ble_evt_t * p_ble_evt);
N
N/**@brief Type of function for passing events from the BLE stack handler module to the scheduler. */
Ntypedef uint32_t (*ble_stack_evt_schedule_func_t) (void);
N
N/**@brief Macro for initializing the BLE stack event handler.
N *
N * @details It will handle dimensioning and allocation of the memory buffer required for reading
N *          BLE events from the stack, making sure the buffer is correctly aligned. It will also
N *          connect the BLE stack event handler to the scheduler (if specified).
N *
N * @param[in] CLOCK_SOURCE    Low frequency clock source and accuracy (type nrf_clock_lfclksrc_t,
N *                            see sd_softdevice_enable() for details).
N * @param[in] MTU_SIZE        Maximum size of BLE transmission units to be used by this application.
N * @param[in] EVT_HANDLER     Pointer to function to be executed when an event has been received.
N * @param[in] USE_SCHEDULER   TRUE if the application is using the event scheduler, FALSE otherwise.
N *
N * @note Since this macro allocates a buffer, it must only be called once (it is OK to call it
N *       several times as long as it is from the same location, e.g. to do a reinitialization).
N */
N/*lint -emacro(506, BLE_STACK_HANDLER_INIT) */ /* Suppress "Constant value Boolean */
N#define BLE_STACK_HANDLER_INIT(CLOCK_SOURCE, MTU_SIZE, EVT_HANDLER, USE_SCHEDULER)                 \
N    do                                                                                             \
N    {                                                                                              \
N        static uint32_t EVT_BUFFER[CEIL_DIV(sizeof(ble_evt_t) + (MTU_SIZE), sizeof(uint32_t))];    \
N        uint32_t        ERR_CODE;                                                                  \
N        ERR_CODE = ble_stack_handler_init((CLOCK_SOURCE),                                          \
N                                          EVT_BUFFER,                                              \
N                                          sizeof(EVT_BUFFER),                                      \
N                                          (EVT_HANDLER),                                           \
N                                          (USE_SCHEDULER) ? ble_stack_evt_schedule : NULL);        \
N        APP_ERROR_CHECK(ERR_CODE);                                                                 \
N    } while (0)
X#define BLE_STACK_HANDLER_INIT(CLOCK_SOURCE, MTU_SIZE, EVT_HANDLER, USE_SCHEDULER)                     do                                                                                                 {                                                                                                      static uint32_t EVT_BUFFER[CEIL_DIV(sizeof(ble_evt_t) + (MTU_SIZE), sizeof(uint32_t))];            uint32_t        ERR_CODE;                                                                          ERR_CODE = ble_stack_handler_init((CLOCK_SOURCE),                                                                                    EVT_BUFFER,                                                                                        sizeof(EVT_BUFFER),                                                                                (EVT_HANDLER),                                                                                     (USE_SCHEDULER) ? ble_stack_evt_schedule : NULL);                APP_ERROR_CHECK(ERR_CODE);                                                                     } while (0)
N
N/**@brief Function for initializing stack module.
N *
N * @details Enables the SoftDevice and the BLE stack event interrupt handler.
N *
N * @note This function must be called before calling any function in the SoftDevice API.
N *
N * @note Normally initialization should be done using the BLE_STACK_HANDLER_INIT() macro, as that
N *       will both allocate the BLE event buffer, and also align the buffer correctly.
N *
N * @param[in]  clock_source        Low frequency clock source to be used by the SoftDevice.
N * @param[in]  p_evt_buffer        Buffer for holding one BLE stack event. Since we are
N *                                 not using the heap, this buffer must be provided by
N *                                 the application. The buffer must be large enough to hold
N *                                 the biggest stack event the application is supposed to
N *                                 handle. The buffer must be aligned to a 4 byte boundary.
N * @param[in]  evt_buffer_size     Size of BLE stack event buffer.
N * @param[in]  evt_handler         Handler to be called for each received BLE stack event.
N * @param[in]  evt_schedule_func   Function for passing BLE events to the scheduler. Point to
N *                                 ble_stack_evt_schedule() to connect to the scheduler. Set to NULL
N *                                 to make the BLE stack handler module call the event handler
N *                                 directly from the BLE stack event interrupt handler.
N *
N * @retval     NRF_SUCCESS               Successful initialization.
N * @retval     NRF_ERROR_INVALID_PARAM   Invalid parameter (buffer not aligned to a 4 byte
N *                                       boundary) or NULL.
N */
Nuint32_t ble_stack_handler_init(nrf_clock_lfclksrc_t          clock_source,
N                                void *                        p_evt_buffer,
N                                uint16_t                      evt_buffer_size,
N                                ble_stack_evt_handler_t       evt_handler,
N                                ble_stack_evt_schedule_func_t evt_schedule_func);
N
N
N// Functions for connecting the BLE Stack Event Handler to the scheduler:
N
N/**@cond NO_DOXYGEN */
Nvoid intern_ble_stack_events_execute(void);
N
Nstatic __INLINE void ble_stack_evt_get(void * p_event_data, uint16_t event_size)
Xstatic __inline void ble_stack_evt_get(void * p_event_data, uint16_t event_size)
N{
N    APP_ERROR_CHECK_BOOL(event_size == 0);
X    do { const _Bool LOCAL_BOOLEAN_VALUE = (event_size == 0); if (!LOCAL_BOOLEAN_VALUE) { do { app_error_handler((0), 117, (uint8_t*) "..\\..\\..\\Software\\Include\\ble_stack_handler.h"); } while (0); } } while (0);
N    intern_ble_stack_events_execute();
N}
N
Nstatic __INLINE uint32_t ble_stack_evt_schedule(void)
Xstatic __inline uint32_t ble_stack_evt_schedule(void)
N{
N    return app_sched_event_put(NULL, 0, ble_stack_evt_get);
X    return app_sched_event_put(0, 0, ble_stack_evt_get);
N}
N/**@endcond */
N
N#endif // BLE_STACK_HANDLER_H__
N
N/** @} */
L 14 "..\..\..\Software\Source\ble_lib\ble_stack_handler.c" 2
N#include <stdlib.h>
N#include "nordic_common.h"
L 1 "..\..\..\Software\Include\nordic_common.h" 1
N/* Copyright (c) 2008 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is property of Nordic Semiconductor ASA.
N * Terms and conditions of usage are described in detail in NORDIC
N * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
N *
N * Licensees are granted free, non-transferable use of the information. NO
N * WARRANTY of ANY KIND is provided. This heading must NOT be removed from
N * the file.
N */ 
N
N/** @file
N * @brief Common defines and macros for firmware developed by Nordic Semiconductor.
N */
N
N#ifndef NORDIC_COMMON_H__
N#define NORDIC_COMMON_H__
N
N/** Swaps the upper byte with the lower byte in a 16 bit variable */
N//lint -emacro((572),SWAP) // Suppress warning 572 "Excessive shift value"
N#define SWAP(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))
N
N/** The upper 8 bits of a 16 bit value */
N#define MSB(a) (((a) & 0xFF00) >> 8)
N/** The lower 8 bits (of a 16 bit value) */
N#define LSB(a) ((a) & 0xFF)
N
N/** Leaves the minimum of the two arguments */
N/*lint -emacro(506, MIN) */ /* Suppress "Constant value Boolean */ 
N#define MIN(a, b) ((a) < (b) ? (a) : (b))
N/** Leaves the maximum of the two arguments */
N/*lint -emacro(506, MAX) */ /* Suppress "Constant value Boolean */ 
N#define MAX(a, b) ((a) < (b) ? (b) : (a))
N
N#define BIT_0 0x01 /**< The value of bit 0 */
N#define BIT_1 0x02 /**< The value of bit 1 */
N#define BIT_2 0x04 /**< The value of bit 2 */
N#define BIT_3 0x08 /**< The value of bit 3 */
N#define BIT_4 0x10 /**< The value of bit 4 */
N#define BIT_5 0x20 /**< The value of bit 5 */
N#define BIT_6 0x40 /**< The value of bit 6 */
N#define BIT_7 0x80 /**< The value of bit 7 */
N#define BIT_8 0x0100 /**< The value of bit 8 */
N#define BIT_9 0x0200 /**< The value of bit 9 */
N#define BIT_10 0x0400 /**< The value of bit 10 */
N#define BIT_11 0x0800 /**< The value of bit 11 */
N#define BIT_12 0x1000 /**< The value of bit 12 */
N#define BIT_13 0x2000 /**< The value of bit 13 */
N#define BIT_14 0x4000 /**< The value of bit 14 */
N#define BIT_15 0x8000 /**< The value of bit 15 */
N#define BIT_16 0x00010000 /**< The value of bit 16 */
N#define BIT_17 0x00020000 /**< The value of bit 17 */
N#define BIT_18 0x00040000 /**< The value of bit 18 */
N#define BIT_19 0x00080000 /**< The value of bit 19 */
N#define BIT_20 0x00100000 /**< The value of bit 20 */
N#define BIT_21 0x00200000 /**< The value of bit 21 */
N#define BIT_22 0x00400000 /**< The value of bit 22 */
N#define BIT_23 0x00800000 /**< The value of bit 23 */
N#define BIT_24 0x01000000 /**< The value of bit 24 */
N#define BIT_25 0x02000000 /**< The value of bit 25 */
N#define BIT_26 0x04000000 /**< The value of bit 26 */
N#define BIT_27 0x08000000 /**< The value of bit 27 */
N#define BIT_28 0x10000000 /**< The value of bit 28 */
N#define BIT_29 0x20000000 /**< The value of bit 29 */
N#define BIT_30 0x40000000 /**< The value of bit 30 */
N#define BIT_31 0x80000000 /**< The value of bit 31 */
N
N#define UNUSED_VARIABLE(X)  ((void)(X))
N#define UNUSED_PARAMETER(X) UNUSED_VARIABLE(X)
N
N#endif // NORDIC_COMMON_H__
L 16 "..\..\..\Software\Source\ble_lib\ble_stack_handler.c" 2
N#include "app_error.h"
N#include "app_util.h"
N#include "nrf_assert.h"
L 1 "..\..\..\Software\Include\nrf_assert.h" 1
N/*
N * Copyright (c) 2006 Nordic Semiconductor. All Rights Reserved.
N *
N * The information contained herein is confidential property of Nordic Semiconductor. The use,
N * copying, transfer or disclosure of such information is prohibited except by express written
N * agreement with Nordic Semiconductor.
N *
N */
N
N/** @file
N * @brief Utilities for verifying program logic
N */
N
N#ifndef NRF_ASSERT_H_
N#define NRF_ASSERT_H_
N
N#include <stdint.h>
N
N#if defined(DEBUG_NRF) || defined(DEBUG_NRF_USER)
X#if 0L || 0L
S
S/** @brief Function for handling assertions.
S *
S *
S * @note
S * This function is called when an assertion has triggered.
S *
S *
S * @post
S * All hardware is put into an idle non-emitting state (in particular the radio is highly
S * important to switch off since the radio might be in a state that makes it send
S * packets continiously while a typical final infinit ASSERT loop is executing).
S *
S *
S * @param line_num The line number where the assertion is called
S * @param file_name Pointer to the file name
S */
Svoid assert_nrf_callback(uint16_t line_num, const uint8_t *file_name);
S
S/*lint -emacro(506, ASSERT) */ /* Suppress "Constant value Boolean */ 
S/*lint -emacro(774, ASSERT) */ /* Suppress "Boolean within 'if' always evaluates to True" */ \
S
X    
S/** @brief Function for checking intended for production code.
S *
S * Check passes if "expr" evaluates to true. */
S#define ASSERT(expr) \
Sif (expr)                                                                     \
S{                                                                             \
S}                                                                             \
Selse                                                                          \
S{                                                                             \
S  assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);               \
S}
X#define ASSERT(expr) if (expr)                                                                     {                                                                             }                                                                             else                                                                          {                                                                               assert_nrf_callback((uint16_t)__LINE__, (uint8_t *)__FILE__);               }
N#else
N#define ASSERT(expr) //!< Assert empty when disabled
Nvoid assert_nrf_callback(uint16_t line_num, const uint8_t *file_name);
N#endif /* defined(DEBUG_NRF) || defined(DEBUG_NRF_USER) */
N
N#endif /* NRF_ASSERT_H_ */
L 19 "..\..\..\Software\Source\ble_lib\ble_stack_handler.c" 2
N
N
Nstatic ble_stack_evt_handler_t       m_evt_handler;         /**< Application event handler for handling BLE events. */
Nstatic ble_stack_evt_schedule_func_t m_evt_schedule_func;   /**< Pointer to function for propagating button events to the scheduler. */
Nstatic uint8_t *                     m_evt_buffer;          /**< Buffer for receiving BLE events. */
Nstatic uint16_t                      m_evt_buffer_size;     /**< Size of BLE event buffer. */
N
N
N/**@brief Callback function for asserts in the SoftDevice.
N *
N * @details A pointer to this function will be passed to the SoftDevice. This function will be
N *          called if an ASSERT statement in the SoftDevice fails.
N *
N * @param[in]   pc         The value of the program counter when the ASSERT call failed.
N * @param[in]   line_num   Line number of the failing ASSERT call.
N * @param[in]   file_name  File name of the failing ASSERT call.
N */
Nstatic void softdevice_assertion_handler(uint32_t pc, uint16_t line_num, const uint8_t * file_name)
N{
N    UNUSED_PARAMETER(pc);
X    ((void)(pc));
N    assert_nrf_callback(line_num, file_name);
N}
N
N
Nuint32_t ble_stack_handler_init(nrf_clock_lfclksrc_t          clock_source,
N                                void *                        p_evt_buffer,
N                                uint16_t                      evt_buffer_size,
N                                ble_stack_evt_handler_t       evt_handler,
N                                ble_stack_evt_schedule_func_t evt_schedule_func)
N{
N    uint32_t err_code;
N
N    // Check that buffer is correctly aligned
N    if (!is_word_aligned(p_evt_buffer))
N    {
N        return NRF_ERROR_INVALID_PARAM;
X        return ((0x0) + 7);
N    }
N    // Check that buffer is not NULL    
N    if (p_evt_buffer == NULL)
X    if (p_evt_buffer == 0)
N    {
N        return NRF_ERROR_INVALID_PARAM;
X        return ((0x0) + 7);
N    }    
N    
N    // Save configuration
N    m_evt_buffer        = (uint8_t *)p_evt_buffer;
N    m_evt_buffer_size   = evt_buffer_size;
N    m_evt_handler       = evt_handler;
N    m_evt_schedule_func = evt_schedule_func;
N
N    // Initialize SoftDevice
N    err_code = sd_softdevice_enable(clock_source, softdevice_assertion_handler);
N    if (err_code != NRF_SUCCESS)
X    if (err_code != ((0x0) + 0))
N    {
N        return err_code;
N    }
N
N    // Enable BLE event interrupt (interrupt priority has already been set by the stack)
N    return sd_nvic_EnableIRQ(SWI2_IRQn);
N}
N
N
Nvoid intern_ble_stack_events_execute(void)
N{
N    for (;;)
N    {
N        uint32_t err_code;
N        uint16_t evt_len = m_evt_buffer_size;
N
N        // Pull event from stack
N        err_code = sd_ble_evt_get(m_evt_buffer, &evt_len);
N        if (err_code == NRF_ERROR_NOT_FOUND)
X        if (err_code == ((0x0) + 5))
N        {
N            break;
N        }
N        else if (err_code != NRF_SUCCESS)
X        else if (err_code != ((0x0) + 0))
N        {
N            APP_ERROR_HANDLER(err_code);
X            do { app_error_handler((err_code), 95, (uint8_t*) "..\\..\\..\\Software\\Source\\ble_lib\\ble_stack_handler.c"); } while (0);
N        }
N        
N        // Call application's BLE stack event handler
N        m_evt_handler((ble_evt_t *)m_evt_buffer);
N    }
N}
N
N
N/**@brief Function for handling the Application's BLE Stack events interrupt.
N *
N * @details This function is called whenever an event is ready to be pulled.
N */
Nvoid SWI2_IRQHandler(void)
N{
N    if (m_evt_schedule_func != NULL)
X    if (m_evt_schedule_func != 0)
N    {
N        uint32_t err_code = m_evt_schedule_func();
N        APP_ERROR_CHECK(err_code);
X        do { const uint32_t LOCAL_ERR_CODE = (err_code); if (LOCAL_ERR_CODE != ((0x0) + 0)) { do { app_error_handler((LOCAL_ERR_CODE), 113, (uint8_t*) "..\\..\\..\\Software\\Source\\ble_lib\\ble_stack_handler.c"); } while (0); } } while (0);
N    }
N    else
N    {
N        intern_ble_stack_events_execute();
N    }
N}
